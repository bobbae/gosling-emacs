File: graphics,  Node: Top,  Up: (dir)Top
Date: Mon Nov 29 15:33 1982

* menu:
* Frame Buffer::		Frame buffer library documentation.
File: graphics,  Node: Frame Buffer,  Up: (graphics)Top
Date: Mon Nov 29 16:34 1982

* Menu:

* General::		General Information about the Frame Buffer.
* Names::		Naming conventions for Frame Buffer routines.
* Init::		Initialization and configuration subroutines.
* Putting::		Routines to put data into the frame buffer.
* Getting::		Routines to get data from the frame buffer.
* Text::		Routines to put text into the frame buffer.
			Also includes scroll routines.
* Map::			The color map and routines to manipulate it.
* Zoom::		How to zoom and pan the image.
* Display File::	How to build and draw display files.
* Grabber::		Using the real-time digitizer (frame grabber).

File: graphics,  Node: General,  Up: (graphics)Frame Buffer, Next: Names
Date: Mon Nov 29 15:51 1982

The frame buffer consists of 2^18 27 bit words of memory, conceptually
organized as 512 lines of 512  "picture elements" (pixels) with the  origin
(0,0) in the lower left corner of the screen.  (Note that the frame  buffer
is  capable  of  displaying  either   all  512  lines  with  a   consequent
non-standard tv resolution of 559 lines/frame, or displaying 480 lines with
a standard resolution of 525 lines/frame.   In the latter case, the top  32
lines cannot be seen.) The current configuration is the standard television
resolution of 480 visible lines per frame.

The 27 bit word  is split into several  "channels" - 3 8-bit  channels
and 3  1-bit channels.   The  3 8-bit  channels  are assigned  the  channel
numbers 0, 1, and 2 and are  assigned to red, green and blue  respectively.
The three 1-bit channels are assigned the channel numbers 8, 9 and 10  (why
this is the case will become clear soon) and are assigned initially to  the
red, green and blue overlays respectively (see below for explanation of the
overlays).  The channels  are further  broken down  into 1-bit  subchannels
with channels 0-2  each having subchannels  0-7 (thus making  a total of  8
bits) and channels 8-10 being assigned subchannels 8-10 respectively.  Each
channel may be enabled to be written by setting the corresponding bit in an
11-bit word in the  Frame Buffer called the  channel mask.  When writing  a
data word into  the Frame  Buffer, each  bit corresponds  to a  subchannel.
Thus, if the red overlay channel were enabled, writing a pixel value of 256
(bit 8 turned on) would cause a bright red dot to be displayed.  For  calls
involving the red, green and  blue channels (these subroutines include  the
digit 3 in their names),  a logical mask is used  to enable or disable  the
red, green or blue  channels without affecting  the currently set  physical
mask.

>>> Overlay Planes
                    
The overlay planes are 1-bit memory planes which can be used to turn a
color (or colors) on at  full intensity at any point  at which they have  a
value of 1.  They are called overlays because at each point where there  is
a 1 in an  overlay plane, the  corresponding color value  at that point  is
"obscured" by the  full intensity pixel  caused by the  overlay plane;  but
wherever there is a  0 in the overlay  plane, the data "underneath"  "shows
through", achieving the effect of overlaying the picture with the image  in
the overlay planes.  Thus if the red overlay bit is set, the underlying red
bits in channel 0 will not be  seen; but the underlying green or blue  bits
will show through unless the green or blue overlay bits are set.
                              
The initialization routine in this software package maps each  overlay
to a different primary color.  Each overlay can be mapped to any  selection
of zero or more of the three primary colors.  Note that there is no way  to
use an overlay to produce black, that  is, they work in an additive  rather
than a subtractive mode.

File: graphics,  Node: Init,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:04 1982   Previous: Names, Next: Putting

!<+
Fbopen()	Opens the frame buffer device for i/o.  Must be called first.


Fbinit()	Initializes the configuration of  the  frame  buffer,
		routing  each channel to its appropriate color and
		initializing the color map to an identity map.  It
		enables  all  three overlay channels and all three
		of the RGB channels, i.e.  channels 0, 1, 2, 8,  9
		and 10.

Fchn (mask)
F3chn (mask)	There are two channel  masks  used  by  the  Frame
		Buffer  software,  one which is directly mapped to
		the hardware channel mask and one which is used by
		the  RGB  routines  to determine which of the red,
		green and blue values should actually  be  written
		to  the  Frame  Buffer.   These  routines load the
		appropriate channel mask with the mask  value  -
		Fchn  loads  the  physical mask whereas F3chn sets
		the logical mask for the RGB channels (see above).


Frchn (mask)
Fr3chn (mask)
Fschn (mask)
Fs3chn (mask)	These routines are used to reset (R) or set (S) bits in the
		appropriate channel mask without affecting the other bits.
		Any bits which are ones in mask will be cleared to zero or
		set to one, respectively, in the channel mask.


Fbclr (mask)	Clears the channels specified by mask (the usual
		value is -1 to clear all the channels).


Fcurs (on_off)	There exists a  minimal  hardware  cursor  on  the
		Frame  Buffer.   This consists of a blinking pixel
		at the "write position" (the write position is the
		location   of   the   last  pixel  written  to  or
		examined).  Fcurs will turn  this  cursor  on  and
		off.   A zero value of on_off turns the cursor off,
		and a non-zero value turns it on.


Fpcurs (x,y)	This positions the hardware cursor at the position (x,y).  

Fvect (on_off)	This routine takes the Frame Buffer in and out  of
		vector  mode.   If  vector  mode  is  on all boxes
		written will be vectors from the  "min"  point  to
		the  "max" point (see Frput).  On_off of zero turns
		vector mode off, and a non-zero value turns it on.

Fsize(d_height, d_width)
		Sets or resets double height and width modes.
		These are effective on text, vectors and graphic data.  

Freverse(on_off)
		Set or reset reverse write mode.  If reverse write mode is
		turned on (on_off = 1) all data written after this will have
		ones written for zero bits and zeroes written for one bits.
		It can be reset with an argument of 0.  

Fadditive(on_off)
		Set or reset additive write mode.  If this is off (normal
		mode of operation), then text or "graphic data" written to
		the frame buffer will replace the data there, if on
		(on_off=1) it will be or'ed in.  

Fbormode(on_off)
		Set or reset "or mode".  If this is on (on_off = 1), then
		numeric values sent to the frame buffer using one of the put
		routines (either a 3put or a vput) will be ored with the
		numeric value at each pixel.  This interacts with Freverse
		in an unexpected manner - the logical not of the data sent
		is anded with the data already in the frame buffer.

Ftspacing(number)
		This routine changes the spacing between characters in the
		text put calls.  The default spacing is 7 pixels, characters
		are 5 pixels wide.  The number is doubled when using double
		width characters.

File: graphics,  Node: Init,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:04 1982   Previous: Names, Next: Putting

!<+
Fbopen()	Opens the frame buffer device for i/o.  Must be called first.


Fbinit()	Initializes the configuration of  the  frame  buffer,
		routing  each channel to its appropriate color and
		initializing the color map to an identity map.  It
		enables  all  three overlay channels and all three
		of the RGB channels, i.e.  channels 0, 1, 2, 8,  9
		and 10.

Fchn (mask)
F3chn (mask)	There are two channel  masks  used  by  the  Frame
		Buffer  software,  one which is directly mapped to
		the hardware channel mask and one which is used by
		the  RGB  routines  to determine which of the red,
		green and blue values should actually  be  written
		to  the  Frame  Buffer.   These  routines load the
		appropriate channel mask with the mask  value  -
		Fchn  loads  the  physical mask whereas F3chn sets
		the logical mask for the RGB channels (see above).


Frchn (mask)
Fr3chn (mask)
Fschn (mask)
Fs3chn (mask)	These routines are used to reset (R) or set (S) bits in the
		appropriate channel mask without affecting the other bits.
		Any bits which are ones in mask will be cleared to zero or
		set to one, respectively, in the channel mask.


Fbclr (mask)	Clears the channels specified by mask (the usual
		value is -1 to clear all the channels).


Fcurs (on_off)	There exists a  minimal  hardware  cursor  on  the
		Frame  Buffer.   This consists of a blinking pixel
		at the "write position" (the write position is the
		location   of   the   last  pixel  written  to  or
		examined).  Fcurs will turn  this  cursor  on  and
		off.   A zero value of on_off turns the cursor off,
		and a non-zero value turns it on.


Fpcurs (x,y)	This positions the hardware cursor at the position (x,y).  

Fvect (on_off)	This routine takes the Frame Buffer in and out  of
		vector  mode.   If  vector  mode  is  on all boxes
		written will be vectors from the  "min"  point  to
		the  "max" point (see Frput).  On_off of zero turns
		vector mode off, and a non-zero value turns it on.

Fsize(d_height, d_width)
		Sets or resets double height and width modes.
		These are effective on text, vectors and graphic data.  

Freverse(on_off)
		Set or reset reverse write mode.  If reverse write mode is
		turned on (on_off = 1) all data written after this will have
		ones written for zero bits and zeroes written for one bits.
		It can be reset with an argument of 0.  

Fadditive(on_off)
		Set or reset additive write mode.  If this is off (normal
		mode of operation), then text or "graphic data" written to
		the frame buffer will replace the data there, if on
		(on_off=1) it will be or'ed in.  

Fbormode(on_off)
		Set or reset "or mode".  If this is on (on_off = 1), then
		numeric values sent to the frame buffer using one of the put
		routines (either a 3put or a vput) will be ored with the
		numeric value at each pixel.  This interacts with Freverse
		in an unexpected manner - the logical not of the data sent
		is anded with the data already in the frame buffer.

Ftspacing(number)
		This routine changes the spacing between characters in the
		text put calls.  The default spacing is 7 pixels, characters
		are 5 pixels wide.  The number is doubled when using double
		width characters.
!>
File: graphics,  Node: Putting,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:16 1982	 Previous: Init, Next: Getting

!<+

Fpvput (x,y,value)
		Writes value  into  all  enabled  channels  at  the location
		(x,y).   The  8 low-order bits of value will be written into
		all enabled  color  channels; bit 8 will be written into the
		red overlay channel (if enabled), bit 9 into the green
		overlay channel (if  enabled)  and  bit  10  into the blue
		overlay channel (if enabled).


Fp3put (x,y,red,green,blue)
		Writes an RGB point.  Red is written into channel 0,  green
		nto channel 1, and blue into channel 2.  Any or all of these
		writes  may  be  disabled  by clearing  (resetting)  the
		appropriate bit in the RGB channel mask.


Frvput (xmin,xmax,ymin,ymax,value)
		Writes value  into  all  enabled channels  of  all pixels
		in  the box [xmin,xmax] x [ymin,ymax].  (see Fpvput)


Fr3put (xmin,xmax,ymin,ymax,red,green,blue)
		Writes an RGB box.  (see Fp3put)

Fcvput (xc,yc,radius,value)
		Writes a (solid) circle centered at (xc,yc) with radius
		rad.   Value  is  written into all enabled channels.  (see
		Fpvput)

Fc3put (xc,yc,radius,red,green,blue)
		Writes an RGB circle.  (see Fp3put)

Fb3put (xmin,xmax,ymin,ymax,array,n)
		"Byte unpacker".  This routine takes the byte array
		array[3][n] and unpacks it row-wise into  the  area of  the
		screen  from  xmin to xmax and ymin to ymax.   The  element
		array[1][i]  is  red   data, array[2][i]  is  green  and
		array[3][i] is blue.  If xmax is less than  xmin,  the
		write  will  wrap around  the  side of the screen, and
		similarly for ymin and ymax.  The  data  is  written  left
		to right,  bottom  to top a row at a time.  array will be
		packed in the correct format by the routine Fb3get see
		below).  As with Fb3put and Fr3put, only the enabled RGB
		channels will be written.

Fbvput(xmin, xmax, ymin, ymax, array)
		Similar to Fb3put, but writes values from array into all
		enabled channels.

Fv3put (x1, y1, x2, y2, red, green, blue)
		Draw a vector from (x1,y1) to (x2,y2) with the specified
		color.

Fvvput (x1, y1, x2, y2, value)
		Draw a vector from (x1,y1) to (x2,y2) with the specified
		shade.

Fg3put (x, y, data, red, green, blue)
		Put up an eight bit graphic data at position (x,y) with the
		specified color.  The graphic data is  1 pixel high and 8
		pixels wide.  If the additive mode is off, then 0 bits will
		be written as black and 1 bits as the given color.  If
		additive mode is on, the only 1 bits will be written.

Fgvput (x, y, data, value)
		Put up an eight bit graphic data at position (x,y) with the
		specified shade. The graphic data is 1 pixel high and 9
		pixels wide.

Fgb3put (x, y, data, width, n, red, green, blue)
		Put up a buffer of eight bit packed graphic data with the
		appropriate color at position (x,y).  The number of columns
		is specified by width, and the total number of bytes by n.
		Data is an array with n bytes.  The graphic data will be
		written rowwise, and width should be divisible by 8.  The
		number of rows written will thus be n / (width / 8).

Fgbvput (x, y, data, width, n, value)
		Put up a buffer of eight bit packed graphic data with the
		appropriate shade at position (x,y). The number of columns
		is specified by width, and the total number of bytes by n.
File: graphics,  Node: Getting,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:18 1982

!<+
Fp3get (x,y,&red,&green,&blue)
		Reads the red, green and blue values of the  pixel at (x,y).
		The variables red, green, and blue should be shorts.

Fb3get (xmin,xmax,ymin,ymax,&array,n)
		Reads the area from xmin to xmax and  ymin  to ymax  on  the
		screen  into  the byte array array which  should  be
		dimensioned array[3][n].   See Fb3put.

Fpoget (x,y,&value)
		Reads the value of the overlays  at  (x,y)  into value  so
		that if Fpvput were then called with value, the same data
		would be rewritten.  I.e., channel 8 is  read  into  bit  8,
		channel 9 into bit 9, and channel 10 into bit 10.  Value
		should be a short.
!>
File: graphics,  Node: Text,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:22 1982

!<+
Ftvput (x,y,text,value)
		Writes the string text with shade value into all enabled
		channels.  The string is positioned such that the lower left
		corner of the first character is at the point (x,y).  Each
		character is 7 pixels wide by 9 pixels high in single height
		and width mode, 14 x 18 in double width and height mode.

Ft3put(x,y,text,red,green,blue)
		Puts colored text at position (x,y).

Fscroll(nlines)
		Scroll the frame buffer by nlines scanlines.  This relocates
		not only the image displayed, but also the memory addresses,
		so that (0,0) is always the lower left corner of the screen.

Fshome()
		Scroll the screen to the home position.  

Ftscroll()
		Scroll the screen up by the correct number of scanlines for
		a line of text, and erase that many lines at the bottom of
		the screen.  The vertical size (*Note Init::) is taken into
		account.  
File: graphics,  Node: Text,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:23 1982,  Prev: Getting, Next: Map

!<+
Ftvput (x,y,text,value)
		Writes the string text with shade value into all enabled
		channels.  The string is positioned such that the lower left
		corner of the first character is at the point (x,y).  Each
		character is 7 pixels wide by 9 pixels high in single height
		and width mode, 14 x 18 in double width and height mode.

Ft3put(x,y,text,red,green,blue)
		Puts colored text at position (x,y).

Fscroll(nlines)
		Scroll the frame buffer by nlines scanlines.  This relocates
		not only the image displayed, but also the memory addresses,
		so that (0,0) is always the lower left corner of the screen.

Fshome()
		Scroll the screen to the home position.  

Ftscroll()
		Scroll the screen up by the correct number of scanlines for
		a line of text, and erase that many lines at the bottom of
		the screen.  The vertical size (*Note Init::) is taken into
		account.  
File: graphics,  Node: Map,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:23 1982, Prev: Text, Next: Zoom

File: graphics,  Node: Getting,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:24 1982,	 Prev: Putting, Next: Text

!<+
Fp3get (x,y,&red,&green,&blue)
		Reads the red, green and blue values of the  pixel at (x,y).
		The variables red, green, and blue should be shorts.

Fb3get (xmin,xmax,ymin,ymax,&array,n)
		Reads the area from xmin to xmax and  ymin  to ymax  on  the
		screen  into  the byte array array which  should  be
		dimensioned array[3][n].   See Fb3put.

Fpoget (x,y,&value)
		Reads the value of the overlays  at  (x,y)  into value  so
		that if Fpvput were then called with value, the same data
		would be rewritten.  I.e., channel 8 is  read  into  bit  8,
		channel 9 into bit 9, and channel 10 into bit 10.  Value
		should be a short.
!>
File: graphics,  Node: Map,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:29 1982, Prev: Text, Next: Zoom

!<+
Fm3put (maploc, red, green, blue)
		Sets location maploc in the color map to the  given red,
		green and blue values.  If any channels have been masked,
		the cor- responding channel in the map will not be changed.
		Maploc must be from {0..255}

Fm3get (maploc, &red, &green, &blue)
		Reads the red, green and blue values  at location maploc in
		the color map into red, green, and blue (which should be
		shorts).

Fmbput (startloc, map)
		Puts the array of shorts map[3][256] into the color map
		starting at location startloc, and wrapping around if
		startloc is greater than 255 or less than 0.

Fmbget (startloc, map)
		Reads the color map starting at location starting into the
		array map[3][256].

Fmselect (R_ch, G_ch, B_ch)

		Directs the output to the rgb video drivers based on the
		following:
!<			  0:	Red
			  1:	Green
			  2:	Blue
			  3:	Digitizer
!>
		(These are the only valid values.)

!>

Note:  if Fbinit has not been called, some strange results  may  become
apparent while trying to load the color map.
File: graphics,  Node: Zoom,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:34 1982,  Prev: Map,  Next: Display File

!<+
Fzoom (power)	This routine turns on the zoom (and with  it  pan) and zooms
		by an amount determined by power.  Valid arguments are:   1,
		2, 4, and 8.


Fzpan (x, y)	This routine has two functions:  it  controls the position
		of the crosshair cursor (see below) and, when zoomed,
		controls the  center  of the  zoomed area.  I.e.  the cursor
		will always be at (x,y), but when zoomed the center  of  the
		screen  will also be at (x,y).  There is currently a
		hardware bug which causes the cursor to show up at (x, y+4).


Fzcursor (on_off)
		This routine turns the crosshair cursor on or off.  The
		default is off.   (0:  off    1:  on.)

Fzwrap (on_off)
		This routine determines whether the image will wrap around
		at the edges.  The default is on (Set by Fzoom).  (0:  off
		1:  on.)

Fzblink (on_off)
		This routine will cause the cursor to blink when it is on.
		The default is off.   (0:  off    1:  on.)


Fz_display (x, y, color_flag, position_flag)
		This routine can be used in conjuction with Fzpan to display
		the value of the pixel in the crosshaircursor (position
		x,y).  If color_flag is non-zero, the red, green, and blue
		values of the pixel will be displayed.  If position_flag is
		non-zero, then the position of the cursor will also be
		displayed.  The numbers are written into the overlay planes.

Fz_off ()
		This routine disables zoom and pan.

!>File: graphics,  Node: Display File,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:39 1982,	      Prev: Zoom, Next: Grabber

The frame buffer software has the capability to build "display files".  A
display file is an array containing a list of frame buffer commands which
can be written to the frame buffer in one operation.  This capability can
tremendously speed up frame buffer updates, at the cost, of course, of
storage space.  A display file can grow quite rapidly.  For example, a
Fp3put will consume 10 words of array space and a Fr3put, about 14 words.
There is no way to put readback operations in a display file.  If a readback
operation is initiated during display file build, it will be immediately
executed, thus making it easy to build display files based on information
contained in the frame buffer.  (This is not strictly true, and the best
policy is not to do readback operations during display file generation.)
There are three routines which are used to build and display display files.

!<+
Fdstart(buffer, nbuf, full_sub)
		Initiates a display file.   All subsequent frame buffer
		calls will not affect the frame buffer, but instead will add
		frame buffer commands to the display file.   An exception
		to this is frame buffer readback calls, which may work
		correctly, and may not (this will be fixed at some undefined
		time in the future - currently, the user is advised not to
		read while building a display file).   The arguments are:
!<+
buffer		A large amount of storage, nominally an integer array.  It
		will contain the display file which is formatted as follows:
!<+
Word 0:		The number of words used for actual display list storage.

Word 1:		A flag which indicates whether any absolute mode
		instructions were generated.  It is zero if so, and non-zero
		if not.  It will be zero if absolute mode was entered at any
		time while generating the display file, even if no absolute
		mode commands were actually sent to the frame buffer.  This
		could cause base offset mode commands executed after drawing
		a display file to appear in the wrong place.

Words 2,3:	The final (x,y) postion generated by the display file.  It
		is absolute if word 1 is zero and relative to the starting
		position if word 1 is non-zero.

Words 4-n:	The actual display list.  Word 0 gives the number of words
		used.
!>

nbuf		The number of words in buffer.

full_sub	The address of a subroutine which will be called if the
		display list becomes full.  It is called in the form
		(*full_sub)(buffer), and is expected to empty the buffer
		somehow.  Words 1-3 should not be expected to be correct for
		a partial buffer.  A 0 for this argument means that no
		subroutine is supplied.  In this case, Fddraw is called
		using buffer.  Thus, the display file software may be used
		to provide a layer of buffering between the user software
		and the frame buffer.  (At present, it is not recommended to
		do this in relative or base offset mode.) There is no way to
		determine from the user program that the display file has
		overflowed except by checking the length in the first word.
!>

Fdstop()	Closes a display file, setting the values of words 1-3 of
		the display file buffer and restoring the software to its
		normal mode.  Subsequent frame buffer calls will be written
		to the frame buffer.

Fddraw(buffer)	Draws the display file contained in buffer.
!>
File: graphics,  Node: Grabber,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:49 1982,	 Prev: Display File

!<:
Fgrab (cont, shift, nframes):
		Activates the digitizer, which will read into  all enabled
		channels.   If cont is non-zero then the "grabbing" will be
		continuous until either a  call is made to Fgrab with
		cont=0 or the frame grabber is deselected (by, for example,
		modifying the map).  Zoom   is   disabled  during  the  frame
		grabbing operation.  Shift specifies  how  many  bits  the
		input   will   be  shifted  down  by,  and  nframes specifies
		how  many  frames  to  add  if  not  in continuous  mode.
		Note that the "frame averager" adds the digitized (and
		shifted) input to whatever is  in  the  blue channel and
		then puts the result back  into  all  enabled  channels.
		Thus,  frame averaging  will  only occur if the blue channel
		is enabled.  The 3 overlay planes act  as  low  order bits
		of   the   blue  channel  (thus  making  it effectively 11
		bits) during the averaging process.  Thus  if  the  input
		is shifted more than 2 bits, more accurate results  will  be
		obtained  if  the overlays  are enabled.  (They must then be
		cleared at the end of  the  process,  as  they  will  show
		mostly the noise in the signal).  If nframes=1 then no
		addition  occurs  and  the  input  is  written straight into
		the selected channels.
!>
File: graphics,  Node: Init,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:46 1982   Previous: Names, Next: Putting

!<:
Fbopen():	Opens the frame buffer device for i/o.  Must be called first.


Fbinit():	Initializes the configuration of  the  frame  buffer,
		routing  each channel to its appropriate color and
		initializing the color map to an identity map.  It
		enables  all  three overlay channels and all three
		of the RGB channels, i.e.  channels 0, 1, 2, 8,  9
		and 10.

Fchn (mask):
F3chn (mask):	There are two channel  masks  used  by  the  Frame
		Buffer  software,  one which is directly mapped to
		the hardware channel mask and one which is used by
		the  RGB  routines  to determine which of the red,
		green and blue values should actually  be  written
		to  the  Frame  Buffer.   These  routines load the
		appropriate channel mask with the mask  value  -
		Fchn  loads  the  physical mask whereas F3chn sets
		the logical mask for the RGB channels (see above).


Frchn (mask):
Fr3chn (mask):
Fschn (mask):
Fs3chn (mask):	These routines are used to reset (R) or set (S) bits in the
		appropriate channel mask without affecting the other bits.
		Any bits which are ones in mask will be cleared to zero or
		set to one, respectively, in the channel mask.


Fbclr (mask):	Clears the channels specified by mask (the usual
		value is -1 to clear all the channels).


Fcurs (on_off):	There exists a  minimal  hardware  cursor  on  the
		Frame  Buffer.   This consists of a blinking pixel
		at the "write position" (the write position is the
		location   of   the   last  pixel  written  to  or
		examined).  Fcurs will turn  this  cursor  on  and
		off.   A zero value of on_off turns the cursor off,
		and a non-zero value turns it on.


Fpcurs (x,y):	This positions the hardware cursor at the position (x,y).  

Fvect (on_off):	This routine takes the Frame Buffer in and out  of
		vector  mode.   If  vector  mode  is  on all boxes
		written will be vectors from the  "min"  point  to
		the  "max" point (see Frput).  On_off of zero turns
		vector mode off, and a non-zero value turns it on.

Fsize(d_height, d_width):
		Sets or resets double height and width modes.
		These are effective on text, vectors and graphic data.  

Freverse(on_off):
		Set or reset reverse write mode.  If reverse write mode is
		turned on (on_off = 1) all data written after this will have
		ones written for zero bits and zeroes written for one bits.
		It can be reset with an argument of 0.  

Fadditive(on_off):
		Set or reset additive write mode.  If this is off (normal
		mode of operation), then text or "graphic data" written to
		the frame buffer will replace the data there, if on
		(on_off=1) it will be or'ed in.  

Fbormode(on_off):
		Set or reset "or mode".  If this is on (on_off = 1), then
		numeric values sent to the frame buffer using one of the put
		routines (either a 3put or a vput) will be ored with the
		numeric value at each pixel.  This interacts with Freverse
		in an unexpected manner - the logical not of the data sent
		is anded with the data already in the frame buffer.

Ftspacing(number):
		This routine changes the spacing between characters in the
		text put calls.  The default spacing is 7 pixels, characters
		are 5 pixels wide.  The number is doubled when using double
		width characters.
!>
File: graphics,  Node: Putting,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:47 1982	 Previous: Init, Next: Getting

!<:

Fpvput (x,y,value):
		Writes value  into  all  enabled  channels  at  the location
		(x,y).   The  8 low-order bits of value will be written into
		all enabled  color  channels; bit 8 will be written into the
		red overlay channel (if enabled), bit 9 into the green
		overlay channel (if  enabled)  and  bit  10  into the blue
		overlay channel (if enabled).


Fp3put (x,y,red,green,blue):
		Writes an RGB point.  Red is written into channel 0,  green
		nto channel 1, and blue into channel 2.  Any or all of these
		writes  may  be  disabled  by clearing  (resetting)  the
		appropriate bit in the RGB channel mask.


Frvput (xmin,xmax,ymin,ymax,value):
		Writes value  into  all  enabled channels  of  all pixels
		in  the box [xmin,xmax] x [ymin,ymax].  (see Fpvput)


Fr3put (xmin,xmax,ymin,ymax,red,green,blue):
		Writes an RGB box.  (see Fp3put)

Fcvput (xc,yc,radius,value):
		Writes a (solid) circle centered at (xc,yc) with radius
		rad.   Value  is  written into all enabled channels.  (see
		Fpvput)

Fc3put (xc,yc,radius,red,green,blue):
		Writes an RGB circle.  (see Fp3put)

Fb3put (xmin,xmax,ymin,ymax,array,n):
		"Byte unpacker".  This routine takes the byte array
		array[3][n] and unpacks it row-wise into  the  area of  the
		screen  from  xmin to xmax and ymin to ymax.   The  element
		array[1][i]  is  red   data, array[2][i]  is  green  and
		array[3][i] is blue.  If xmax is less than  xmin,  the
		write  will  wrap around  the  side of the screen, and
		similarly for ymin and ymax.  The  data  is  written  left
		to right,  bottom  to top a row at a time.  array will be
		packed in the correct format by the routine Fb3get see
		below).  As with Fb3put and Fr3put, only the enabled RGB
		channels will be written.

Fbvput(xmin, xmax, ymin, ymax, array):
		Similar to Fb3put, but writes values from array into all
		enabled channels.

Fv3put (x1, y1, x2, y2, red, green, blue):
		Draw a vector from (x1,y1) to (x2,y2) with the specified
		color.

Fvvput (x1, y1, x2, y2, value):
		Draw a vector from (x1,y1) to (x2,y2) with the specified
		shade.

Fg3put (x, y, data, red, green, blue):
		Put up an eight bit graphic data at position (x,y) with the
		specified color.  The graphic data is  1 pixel high and 8
		pixels wide.  If the additive mode is off, then 0 bits will
		be written as black and 1 bits as the given color.  If
		additive mode is on, the only 1 bits will be written.

Fgvput (x, y, data, value):
		Put up an eight bit graphic data at position (x,y) with the
		specified shade. The graphic data is 1 pixel high and 9
		pixels wide.

Fgb3put (x, y, data, width, n, red, green, blue):
		Put up a buffer of eight bit packed graphic data with the
		appropriate color at position (x,y).  The number of columns
		is specified by width, and the total number of bytes by n.
		Data is an array with n bytes.  The graphic data will be
		written rowwise, and width should be divisible by 8.  The
		number of rows written will thus be n / (width / 8).

Fgbvput (x, y, data, width, n, value):
		Put up a buffer of eight bit packed graphic data with the
		appropriate shade at position (x,y). The number of columns
		is specified by width, and the total number of bytes by n.
File: graphics,  Node: Getting,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:47 1982,	 Prev: Putting, Next: Text

!<:
Fp3get (x,y,&red,&green,&blue):
		Reads the red, green and blue values of the  pixel at (x,y).
		The variables red, green, and blue should be shorts.

Fb3get (xmin,xmax,ymin,ymax,&array,n):
		Reads the area from xmin to xmax and  ymin  to ymax  on  the
		screen  into  the byte array array which  should  be
		dimensioned array[3][n].   See Fb3put.

Fpoget (x,y,&value):
		Reads the value of the overlays  at  (x,y)  into value  so
		that if Fpvput were then called with value, the same data
		would be rewritten.  I.e., channel 8 is  read  into  bit  8,
		channel 9 into bit 9, and channel 10 into bit 10.  Value
		should be a short.
!>
File: graphics,  Node: Text,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:48 1982,  Prev: Getting, Next: Map

!<:
Ftvput (x,y,text,value):
		Writes the string text with shade value into all enabled
		channels.  The string is positioned such that the lower left
		corner of the first character is at the point (x,y).  Each
		character is 7 pixels wide by 9 pixels high in single height
		and width mode, 14 x 18 in double width and height mode.

Ft3put(x,y,text,red,green,blue):
		Puts colored text at position (x,y).

Fscroll(nlines):
		Scroll the frame buffer by nlines scanlines.  This relocates
		not only the image displayed, but also the memory addresses,
		so that (0,0) is always the lower left corner of the screen.

Fshome():
		Scroll the screen to the home position.  

Ftscroll():
		Scroll the screen up by the correct number of scanlines for
		a line of text, and erase that many lines at the bottom of
		the screen.  The vertical size (*Note Init::) is taken into
		account.  
!>
File: graphics,  Node: Map,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:48 1982, Prev: Text, Next: Zoom

!<:
Fm3put (maploc, red, green, blue):
		Sets location maploc in the color map to the  given red,
		green and blue values.  If any channels have been masked,
		the cor- responding channel in the map will not be changed.
		Maploc must be from {0..255}

Fm3get (maploc, &red, &green, &blue):
		Reads the red, green and blue values  at location maploc in
		the color map into red, green, and blue (which should be
		shorts).

Fmbput (startloc, map):
		Puts the array of shorts map[3][256] into the color map
		starting at location startloc, and wrapping around if
		startloc is greater than 255 or less than 0.

Fmbget (startloc, map):
		Reads the color map starting at location starting into the
		array map[3][256].

Fmselect (R_ch, G_ch, B_ch):

		Directs the output to the rgb video drivers based on the
		following:
!<			  0:	Red
			  1:	Green
			  2:	Blue
			  3:	Digitizer
!>
		(These are the only valid values.)

!>

Note:  if Fbinit has not been called, some strange results  may  become
apparent while trying to load the color map.
File: graphics,  Node: Zoom,  Up: (graphics)Frame Buffer
Date: Mon Nov 29 16:48 1982,  Prev: Map,  Next: Display File

!<:
Fzoom (power):	This routine turns on the zoom (and with  it  pan) and zooms
		by an amount determined by power.  Valid arguments are:   1,
		2, 4, and 8.


Fzpan (x, y):	This routine has two functions:  it  controls the position
		of the crosshair cursor (see below) and, when zoomed,
		controls the  center  of the  zoomed area.  I.e.  the cursor
		will always be at (x,y), but when zoomed the center  of  the
		screen  will also be at (x,y).  There is currently a
		hardware bug which causes the cursor to show up at (x, y+4).


Fzcursor (on_off):
		This routine turns the crosshair cursor on or off.  The
		default is off.   (0:  off    1:  on.)

Fzwrap (on_off):
		This routine determines whether the image will wrap around
		at the edges.  The default is on (Set by Fzoom).  (0:  off
		1:  on.)

Fzblink (on_off):
		This routine will cause the cursor to blink when it is on.
		The default is off.   (0:  off    1:  on.)


Fz_display (x, y, color_flag, position_flag):
		This routine can be used in conjuction with Fzpan to display
		the value of the pixel in the crosshaircursor (position
		x,y).  If color_flag is non-zero, the red, green, and blue
		values of the pixel will be displayed.  If position_flag is
		non-zero, then the position of the cursor will also be
		displayed.  The numbers are written into the overlay planes.

Fz_off ():	This routine disables zoom and pan.

!>File: graphics,  Node: Display File,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 04:02 1982,	      Prev: Zoom, Next: Grabber

The frame buffer software has the capability to build "display files".  A
display file is an array containing a list of frame buffer commands which
can be written to the frame buffer in one operation.  This capability can
tremendously speed up frame buffer updates, at the cost, of course, of
storage space.  A display file can grow quite rapidly.  For example, a
Fp3put will consume 10 words of array space and a Fr3put, about 14 words.
There is no way to put readback operations in a display file.  If a readback
operation is initiated during display file build, it will be immediately
executed, thus making it easy to build display files based on information
contained in the frame buffer.  (This is not strictly true, and the best
policy is not to do readback operations during display file generation.)
There are three routines which are used to build and display display files.

!<(
Fdstart(buffer, nbuf, full_sub)
short buffer[nbuf];
int nbuf;
int (*full_sub)();
		Initiates a display file.   All subsequent frame buffer
		calls will not affect the frame buffer, but instead will add
		frame buffer commands to the display file.

Args:		buffer: the "display file" will be built in this array.

		nbuf: the size of buffer.

		full_sub: a subroutine to be called when the buffer fills up.

Notes:	      - buffer should be fairly large.

	      - the buffer format is
!<:
Word 0:		The number of words used for actual display list storage.

Word 1:		A flag which indicates whether any absolute mode
		instructions were generated.  It is zero if so, and non-zero
		if not.  It will be zero if absolute mode was entered at any
		time while generating the display file, even if no absolute
		mode commands were actually sent to the frame buffer.  This
		could cause base offset mode commands executed after drawing
		a display file to appear in the wrong place.

Words 2,3:	The final (x,y) postion generated by the display file.  It
		is absolute if word 1 is zero and relative to the starting
		position if word 1 is non-zero.

Words 4-n:	The actual display list.  Word 0 gives the number of words
		used.
!>

		Full_sub is called in the form (*full_sub)(buffer), and is
		expected to empty the buffer somehow.  Words 1-3 should not
		be expected to be correct for a partial buffer.  

		If NULL is supplied as the full_sub, Fddraw will be called
		using buffer when buffer is full.  Thus, the display file
		software may be used to provide a layer of buffering between
		the user software and the frame buffer.  (At present, it is
		not recommended to do this in relative or base offset mode.)

	      -	There is no way to determine from the user program that the
		display file has overflowed except by checking the length in
		the first word.

	      - It is recommended that no readback calls be made while
		building a display file.  They will not work properly and
		neither will the display file.

Fdstop()
		Closes a display file, setting the values of words 1-3 of
		the display file buffer and restoring the software to its
		normal mode.  Subsequent frame buffer calls will be written
		to the frame buffer.

Fddraw(buffer)
short buffer[];
		Draws the display file contained in buffer.

Args:		buffer: a display file built using Fdstart.
!>
ffer.
!>
File: graphics,  Node: Init,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 02:22 1982,  Previous: Names, Next: Putting

!<(
Fbopen()
		Opens the frame buffer device for i/o.  Must be called first.


Fbinit()
		Initializes the configuration of  the  frame  buffer.
Notes:	      -	Routes  each channel to its appropriate color.
	      -	Initializes the color map to a map which attempts to
		compensate for non-linearities in the system.
	      - Enables  all  three overlay channels and all three
		of the RGB channels, i.e.  channels 0, 1, 2, 8,  9
		and 10.

Fchn (mask)
F3chn (mask)
int mask;
		Set channel masks.

Args:		mask: A number which will be loaded into the appropriate
		channel mask.

Notes:	      -	There are two channel  masks  used  by  the  Frame
		Buffer  software,  one which is directly mapped to
		the hardware channel mask and one which is used by
		the  RGB  routines  to determine which of the red,
		green and blue values should actually  be  written
		to  the  Frame  Buffer. Fchn  loads  the  physical mask
		whereas F3chn sets the logical mask for the RGB channels.


Frchn (mask)
Fr3chn (mask)
Fschn (mask)
Fs3chn (mask)
int mask;
		These routines are used to reset (R) or set (S) bits in the
		appropriate channel mask without affecting the other bits.
Args:		mask: bits which are ones in mask will be cleared to zero or
		set to one, respectively, in the channel mask.

Fbclr (mask)
int mask;
		Clear the screen.
Args:		mask: specifies which channels to clear (the usual
		value is -1 to clear all the channels).

Notes:	      - An argument of 0 will clear the channels selected by the
		current physical mask.

Fcurs (on_off)
int on_off;
		Turn the blinking-dot cursor on or off.
Args:		on_off: 0 for off, 1 for on.

Notes:	      -	There exists a  minimal  hardware  cursor  on  the
		Frame  Buffer.   This consists of a blinking pixel
		at the "write position" (the write position is the
		location   of   the   last  pixel  written  to  or
		examined).


Fpcurs (x,y)
int x, y;
		This positions the hardware blinking-dot cursor.
Args:		x, y: where to put it.

Fvect (on_off)
int on_off;
		This routine takes the Frame Buffer in and out  of
		vector  mode.   
Args:		on_off: 0 for off, 1 for on.
Notes:	      - If  vector  mode  is  on all boxes written will be vectors
		from the  "min"  point  to the  "max" point (see Frput).

Fsize(d_height, d_width)
int d_height, d_width;
		Sets or resets double height and width modes.
Args:		d_height, d_width: 0 for single height/width and 1 for
		double.
Notes:	       - These are effective on text, vectors and graphic data.  

Freverse(on_off)
int on_off;
		Set or reset reverse write mode.
Args:		on_off: 0 for off, 1 for on.
Notes:	      -	If reverse write mode is turned on (on_off = 1) all data
		written after this will have ones written for zero bits and
		zeroes written for one bits.

Fadditive(on_off)
int on_off;
		Set or reset additive write mode.  
Args:		on_off: 0 for off, 1 for on.
Notes:	      -	If this is off (normal mode of operation), then text or
		"graphic data" written to the frame buffer will replace the
		data there, if on, only the "1" bits in the text or graphic
		data pattern will be written.

Fbormode(on_off)
int on_off;
		Set or reset "or mode".  
Args:		on_off: 0 for off, 1 for on.
Notes:	      -	If this is on, then numeric values sent to the frame buffer
		using one of the put routines (either a 3put or a vput) will
		be ored with the numeric value at each pixel.  
	      -	This interacts with Freverse in an unexpected manner - the
		logical not of the data sent is anded with the data already
		in the frame buffer.

Ftspacing(number)
int number;
		This routine changes the spacing between characters in the
		text put calls.  
Args:		number: the number of pixels between the lower left corner
		of adjacent characters in a text string.
Notes:	      - The default spacing is 7 pixels, characters are 5 pixels
		wide.  
	      -	The number is doubled when using double width characters.
!>
File: graphics,  Node: Putting,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 04:11 1982	 Previous: Init, Next: Getting

!<(

Fpvput (x,y,value)
int x, y, value;
		Set a single pixel to a given shade.

Args:		x, y: the location of the pixel to be changed.

		value: the shade value to be written into the pixel.

Notes:	      -	Writes value  into  all  enabled  channels  at  the location
		(x,y).   The  8 low-order bits of value will be written into
		all enabled  color  channels; bit 8 will be written into the
		red overlay channel (if enabled), bit 9 into the green
		overlay channel (if  enabled)  and  bit  10  into the blue
		overlay channel (if enabled).


Fp3put (x,y,red,green,blue)
int x, y, red, green, blue;
		Writes an RGB point.  

Args:		Red: written into channel 0

		Green: written into channel 1

		Blue: written into channel 2

Notes:	      - Any or all of these writes  may  be  disabled  by clearing
		(resetting)  the appropriate bit in the RGB channel mask.


Frvput (xmin,xmax,ymin,ymax,value)
int xmin, xmax, ymin, ymax, value;
		Sets a whole box to a given shade.

Args:		xmin, xmax, ymin, ymax: The region [xmin,xmax] x [ymin,ymax]
		will be affected.

		value: written into  all  enabled channels  of  all pixels
		in  the box .  (see Fpvput)


Fr3put (xmin,xmax,ymin,ymax,red,green,blue)
int xmin, xmax, ymin, ymax, red, green, blue;
		Writes an RGB box.  (see Fp3put)

Args:		xmin, xmax, ymin, ymax: boundaries of the box.

		red, green, blue: the color to be written.

Fcvput (xc,yc,radius,value)
int xc, yc, radius, value;
		Sets a circular region of the frame buffer to a given shade.

Args:		xc, yc: coordinates of the center of the circle.

		radius: radius of the circle.

		value: written into all enabled channels of all pixels in
		the (solid) circle.

Notes:	      - Since the aspect ratio of the pixels on the screen is not
		square, the circle comes out elliptical.

Fc3put (xc,yc,radius,red,green,blue)
int xc, yc, radius, red, green, blue;
		Writes an RGB circle.

Args:		xc, yc, radius: Describe the circle.

		red, green, blue: The color to be written.


Fb3put (xmin,xmax,ymin,ymax,array,n)
int xmin, xmax, ymin, ymax;
char array[3][n];
int n;
		Unpack an array of pixel data into a rectangular region of
		the frame buffer. "Byte unpacker".

Args:		xmin, xmax, ymin, ymax:  The bounds of the region.

		array: a byte (char) array dimensioned 3 by n.  This
		contains the data to be written.

		n: the array "row size".
Notes:
	      - Array is unpacked row-wise into  the  area of  the
		screen  from  xmin to xmax and ymin to ymax.   The  element
		array[0][i]  is  red   data, array[1][i]  is  green  and
		array[2][i] is blue.  

	      -	The  data  is  written  left to right,  bottom  to top a row
		at a time.  

	      - N is the offset in the array between the start of each
		color, not the number of pixels in the region.  For best
		results, N should be greater than or equal to the number of
		pixels in the region ((1+xmax-xmin)*(1+ymax-ymin)).

	      -	If xmax is less than  xmin,  the write  will  wrap around
		the  side of the screen, and similarly for ymin and ymax.

	      -	Array will be packed in the correct format by the routine
		Fb3get (*note Fb3get: getting.).  As with Fb3put and Fr3put,
		only the enabled RGB channels will be written.

Fbvput(xmin, xmax, ymin, ymax, array)
int xmin, xmax, ymin, ymax;
char array[];
		Similar to Fb3put, but writes values from array into all
		enabled channels.

Args:		xmin, xmax, ymin, ymax: Describe the region.

		array: the data to be written to the region.

Notes:	      - The size of the array should be greater than or equal to the
		number of pixels in the region.

Fvvput (x1, y1, x2, y2, value):
int x1, y1, x2, y2, value;
		Draw a straight line between two points with a specified
		color.

Args:		x1, y1: The coordinates of the first point.

		x2, y2: The coordinates of the second point.

		value: written into all enabled channels along the line.

Notes:	      - The "clipping" algorithm employed by the frame buffer
		software does not work well for lines.

Fv3put (x1, y1, x2, y2, red, green, blue)
int x1, y1, x2, y2, red, green, blue;
		Draw a straight line between two points with a specified
		color.

Args:		x1, y1: The coordinates of the first point.

		x2, y2: The coordinates of the second point.

		red, green, blue: The color of the line.

Notes:	      - The "clipping" algorithm employed by the frame buffer
		software does not work well for lines.


Fgvput (x, y, data, value):
int x, y;
char data;
int value;
		Write a "graphic datum" to the frame buffer.

Args:		x, y: The starting position (left end).

		data: An 8 bit pattern which will be "written" into the 8
		pixels from (x,y) through (x+7,y).

		value: The value to be written at the "1" bits.

Notes:	      -	If the additive mode is off, then 0 bits will be written as
		black and 1 bits as the given shade.  If additive mode is
		on, the only 1 bits will be written.


Fg3put (x, y, data, red, green, blue)
int x, y;
char data;
int red, green, blue;
		Write a "graphic datum" to the frame buffer.

Args:		x, y: The starting position (left end).

		data: An 8 bit pattern which will be "written" into the 8
		pixels from (x,y) through (x+7,y).

		red, green, blue: The color to be written at the "1" bits.

Notes:	      -	If the additive mode is off, then 0 bits will be written as
		black and 1 bits as the given color.  If additive mode is
		on, the only 1 bits will be written.

Fgbvput (x, y, data, width, n, value):
int x, y;
char data[n];
int width, n, value;
		Load a bit map into a rectangular region of the frame
		buffer.

Args:		x, y: the starting point (lower left corner).

		data: the bit map.

		width: the width (in pixels) of the region to be written.

		n: the total number of bytes to be written.

		value: the shade to be written at the "1" bits.

Notes:	      - Width should be divisible by 8.

	      - The region written will be (n/(width/8)) lines high.

	      - N should be divisible by (width/8).

Fgb3put (x, y, data, width, n, red, green, blue):
int x, y;
char data[n];
int width, n, red, green, blue;
		Write a bitmap in a specified color.

Args:		x, y: the starting point (lower left corner).

		data: the bit map.

		width: the width (in pixels) of the region to be written.

		n: the total number of bytes to be written.

		red, green, blue: the color to be written at the "1" bits.

Notes:	      - Width should be divisible by 8.

	      - The region written will be (n/(width/8)) lines high.

	      - N should be divisible by (width/8).
!>
>
File: graphics,  Node: Getting,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 03:35 1982,	 Prev: Putting, Next: Text

!<(
Fp3get (x, y, red, green, blue)
int x, y;
short *red, *green, *blue;
		Read back the color at a pixel.

Args:		x, y: the coordinates of the pixel to be read.

		red, green, blue: pointers to the locations in which the
		color components will be saved.  The variables pointed to
		should be short ints (16 bits).

Fpoget (x, y, value)
int x, y;
short *value;
		Read the value of the overlay planes at a pixel.

Args:		x, y: the coordinates of the pixel.

		value: the value will be returned through this pointer.

Notes:	     -	If Fpvput were to be called with value, the same data would be
		rewritten into the overlay planes.  I.e., channel 8 is  read
		into  bit  8, channel 9 into bit 9, and channel 10 into bit
		10.


Fb3get (xmin, xmax, ymin, ymax, array, n)
int xmin, xmax, ymin, ymax;
char array[3][n];
int n;
		Read back a rectangular region of the screen into an array.

Args:		xmin, xmax, ymin, ymax: describe the region to be read.

		array: the data will be read into this, with red data
		starting at array[0][0], green at array[1][0], and blue at
		array[2][0].

Notes:	      - This is the "inverse" of Fb3put.


!>
File: graphics,  Node: Text,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 03:40 1982,  Prev: Getting, Next: Map

!<(
Ftvput (x,y,text,value)
int x, y;
char *text;
int value;
		Display a text string with a given shade.

Args:		x, y: the starting point of the string.

		text: a string which will be displayed.

		value: the shade in which it will be displayed.

Notes:	      -	The string is positioned such that the lower left corner of
		the first character is at the point (x,y).  

	      -	Each character is 7 pixels wide by 9 pixels high in single
		height and width mode, 14 x 18 in double width and height
		mode.

	      - Normally, each character has a "black box" around it.  This
		can be eliminated by using the "additive mode"
		(*note additive: init.)

Ft3put(x,y,text,red,green,blue)
int x, y;
char *text;
int red, green, blue;
		Puts colored text on the screen.

Args:		x, y: starting point of the string.

		text: the string itself.

		red, green, blue: the color it will be displayed in.


Fscroll(nlines)
int nlines;
		Scroll the frame buffer.

Args:		nlines: the number of lines to scroll.  Positive is up and
		negative is down.

Notes:	      -	This relocates not only the image displayed, but also the
		memory addresses, so that (0,0) is always the lower left
		corner of the screen.

Fshome()
		Scroll the screen to the home position.  

Ftscroll()
		Scroll the screen up by the correct number of scanlines for
		a line of text, and erase that many lines at the bottom of
		the screen.  

Notes:	      -	The vertical size (*Note Init::) is taken into
		account.  
!>
File: graphics,  Node: Map,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 05:41 1982, Prev: Text, Next: Zoom

!<(
Fm3put (maploc, red, green, blue)
int maploc, red, green, blue;
		Set a color map entry to a color.

Args:		maploc: the location in the color map to be modified.

		red, green, blue: the color to set it to.

Notes:	      -	If any channels have been masked, the corresponding
		channel in the map will not be changed.  Maploc must be from
		{0..255}

	      - What this really does is to set the given location in the
		red color map to the red value, the location in the green
		color map to the green value, etc.  Thus, the color (red,
		green, blue) will be displayed at a pixel only if all three
		maps have the same input (maploc), i.e. all three channels
		in the frame buffer memory have the same value at that pixel.

Fm3get (maploc, red, green, blue)
int maploc;
short *red, *green, *blue;
		Read the contents of a color map location.

Args:		maploc: the map entry to be read.

		red, green, blue: the contents will be returned via these
		pointers.


Fmbput (startloc, map)
int startloc;
short map[3][256];
		Set the entire map at once.

Args:		startloc: the location in the map at which to start loading.

		map: the data to be loaded.

Notes:	      - If startloc is not 0, then the loading will wrap around.
		The map can be easily rotated by the sequence of calls
!<		Fmbget(0,map);
		Fmbput(1,map);
!>

Fmbget (startloc, map)
int startloc;
short map[3][256];
		Read back the whole color map.

Args:		startloc: the location to start reading at.

		map: the result comes back here.

Notes:	      -	This one wraps around too.


Fmselect (R_ch, G_ch, B_ch)
int R_ch, G_ch, B_ch;
		Determine where the input for each map comes from.

Args:		R_ch, G_ch, B_ch: selects an input for each map from the
		following list:
!<.			  0:	Red
			  1:	Green
			  2:	Blue
			  3:	Digitizer
!>		(These are the only valid values.)

!>

Note:  if Fbinit has not been called, some strange results  may  become
apparent while trying to load the color map.
File: graphics,  Node: Zoom,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 03:56 1982,  Prev: Map,  Next: Display File

!<(
Fzoom (power)
int power;
		Turn on zoom and pan.

Args:		power: the amount to zoom by.  Legal values are 1, 2, 4 or 8.

Notes:	      - It tries to do something reasonable with illegal inputs.

Fzpan (x, y)
int x, y;
		Pan the screen.

Args:		x, y: the coordinates of the pixel which will be centered on
		the screen.

Notes:	      -	This routine has two functions:  it  controls the position
		of the crosshair cursor (see below) and, when zoomed,
		controls the  center  of the  zoomed area.  I.e.  the cursor
		will always be at (x,y), but when zoomed the center  of  the
		screen  will also be at (x,y).  

	      -	There is currently a hardware bug which causes the cursor to
		show up at (x, y+4).


Fzcursor (on_off)
int on_off;
		Control display of the crosshair cursor.

Args:		on_off: 0 is off, 1 is on.

Notes:	      - default is off.

Fzwrap (on_off)
int on_off;
		Control whether the image will wrap around the edges of the
		screen.

Args:		on_off: if 0, no wrapping will take place.  If 1, the image
		will wrap around.

Notes:	      - Default is on.


Fzblink (on_off)
int on_off;
		This routine will cause the cursor to blink when it is on.

Args:		on_off: 0 is no blink, 1 is blink.

Notes:	      - Default is no blink.


Fz_display (x, y, color_flag, position_flag)
int x, y, color_flag, position_flag;
		Display the color and/or position of the given pixel on the
		screen.

Args:		x, y: the pixel to pick on.

		color_flag: if non-zero, the RGB components of the pixel
		color will be displayed.

		position_flag: if non-zero, the position of the pixel will
		be displayed.

Notes:	      -	The numbers are written into the overlay planes.

Fz_off ()
		This routine disables zoom and pan.

!>
File: graphics,  Node: Grabber,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 04:07 1982,	 Prev: Display File

!<(
Fgrab (cont, shift, nframes)
int cont, shift, nframes;
		Activates the digitizer, which will read into  all enabled
		channels.   

Args:		cont: if 0, a finite number of frames will be "grabbed".  If
		1, grabbing will be continuous until stopped.

		shift: the input from the digitizer will be shifted down by
		this many bits.

		nframes: the number of frames to grab (and possibly
		average).  Ignored if cont is non-zero.

Notes:	      -	Continuous grabbing runs until either a  call is made to
		Fgrab with cont=0 or the frame grabber is deselected (by,
		for example, modifying the map).  

	      -	Zoom   is   disabled  during  the  frame grabbing operation.

	      -	Note that the "frame averager" adds the digitized (and
		shifted) input to whatever is  in  the  blue channel and
		then puts the result back  into  all  enabled  channels.
		Thus,  frame averaging  will  only occur if the blue channel
		is enabled.  The 3 overlay planes act  as  low  order bits
		of   the   blue  channel  (thus  making  it effectively 11
		bits) during the averaging process.  Thus  if  the  input
		is shifted more than 2 bits, more accurate results  will  be
		obtained  if  the overlays  are enabled.  (They must then be
		cleared at the end of  the  process,  as  they  will  show
		mostly the noise in the signal).  

	      - Best results are usually obtained when averaging by
		clearing the blue channel and the overlays before starting
		the grabber.

	      -	If nframes=1 then no addition  occurs  and  the  input  is
		written straight into the selected channels.
!>

File: graphics,  Node: Map,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 05:42 1982, Prev: Text, Next: Zoom

!<(
Fm3put (maploc, red, green, blue)
int maploc, red, green, blue;
		Set a color map entry to a color.

Args:		maploc: the location in the color map to be modified.

		red, green, blue: the color to set it to.

Notes:	      -	If any channels have been masked, the corresponding
		channel in the map will not be changed.  Maploc must be from
		{0..255}

	      - What this really does is to set the given location in the
		red color map to the red value, the location in the green
		color map to the green value, etc.  Thus, the color (red,
		green, blue) will be displayed at a pixel only if all three
		maps have the same input (maploc), i.e. all three channels
		in the frame buffer memory have the same value at that pixel.

Fm3get (maploc, red, green, blue)
int maploc;
short *red, *green, *blue;
		Read the contents of a color map location.

Args:		maploc: the map entry to be read.

		red, green, blue: the contents will be returned via these
		pointers.


Fmbput (startloc, map)
int startloc;
short map[3][256];
		Set the entire map at once.

Args:		startloc: the location in the map at which to start loading.

		map: the data to be loaded.

Notes:	      - If startloc is not 0, then the loading will wrap around.
		The map can be easily rotated by the sequence of calls
!<		Fmbget(0,map);
		Fmbput(1,map);
!>

Fmbget (startloc, map)
int startloc;
short map[3][256];
		Read back the whole color map.

Args:		startloc: the location to start reading at.

		map: the result comes back here.

Notes:	      -	This one wraps around too.


Fmselect (R_ch, G_ch, B_ch)
int R_ch, G_ch, B_ch;
		Determine where the input for each map comes from.

Args:		R_ch, G_ch, B_ch: selects an input for each map from the
		following list:
!<.			  0:	Red
			  1:	Green
			  2:	Blue
			  3:	Digitizer
!>\		(These are the only valid values.)

!>

Note:  if Fbinit has not been called, some strange results  may  become
apparent while trying to load the color map.
File: graphics,  Node: Init,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 06:06 1982,  Previous: Names, Next: Putting

!<(
Fbopen()
		Opens the frame buffer device for i/o.  Must be called first.

Fbclose()
		Closes the frame buffer and releases it for another user.

Fbinit()
		Initializes the configuration of  the  frame  buffer.
Notes:	      -	Routes  each channel to its appropriate color.
	      -	Initializes the color map to a map which attempts to
		compensate for non-linearities in the system.
	      - Enables  all  three overlay channels and all three
		of the RGB channels, i.e.  channels 0, 1, 2, 8,  9
		and 10.

Fchn (mask)
F3chn (mask)
int mask;
		Set channel masks.

Args:		mask: A number which will be loaded into the appropriate
		channel mask.

Notes:	      -	There are two channel  masks  used  by  the  Frame
		Buffer  software,  one which is directly mapped to
		the hardware channel mask and one which is used by
		the  RGB  routines  to determine which of the red,
		green and blue values should actually  be  written
		to  the  Frame  Buffer. Fchn  loads  the  physical mask
		whereas F3chn sets the logical mask for the RGB channels.


Frchn (mask)
Fr3chn (mask)
Fschn (mask)
Fs3chn (mask)
int mask;
		These routines are used to reset (R) or set (S) bits in the
		appropriate channel mask without affecting the other bits.
Args:		mask: bits which are ones in mask will be cleared to zero or
		set to one, respectively, in the channel mask.

Fbclr (mask)
int mask;
		Clear the screen.
Args:		mask: specifies which channels to clear (the usual
		value is -1 to clear all the channels).

Notes:	      - An argument of 0 will clear the channels selected by the
		current physical mask.

Fcurs (on_off)
int on_off;
		Turn the blinking-dot cursor on or off.
Args:		on_off: 0 for off, 1 for on.

Notes:	      -	There exists a  minimal  hardware  cursor  on  the
		Frame  Buffer.   This consists of a blinking pixel
		at the "write position" (the write position is the
		location   of   the   last  pixel  written  to  or
		examined).


Fpcurs (x,y)
int x, y;
		This positions the hardware blinking-dot cursor.
Args:		x, y: where to put it.

Fvect (on_off)
int on_off;
		This routine takes the Frame Buffer in and out  of
		vector  mode.   
Args:		on_off: 0 for off, 1 for on.
Notes:	      - If  vector  mode  is  on all boxes written will be vectors
		from the  "min"  point  to the  "max" point (see Frput).

Fsize(d_height, d_width)
int d_height, d_width;
		Sets or resets double height and width modes.
Args:		d_height, d_width: 0 for single height/width and 1 for
		double.
Notes:	       - These are effective on text, vectors and graphic data.  

Freverse(on_off)
int on_off;
		Set or reset reverse write mode.
Args:		on_off: 0 for off, 1 for on.
Notes:	      -	If reverse write mode is turned on (on_off = 1) all data
		written after this will have ones written for zero bits and
		zeroes written for one bits.

Fadditive(on_off)
int on_off;
		Set or reset additive write mode.  
Args:		on_off: 0 for off, 1 for on.
Notes:	      -	If this is off (normal mode of operation), then text or
		"graphic data" written to the frame buffer will replace the
		data there, if on, only the "1" bits in the text or graphic
		data pattern will be written.

Fbormode(on_off)
int on_off;
		Set or reset "or mode".  
Args:		on_off: 0 for off, 1 for on.
Notes:	      -	If this is on, then numeric values sent to the frame buffer
		using one of the put routines (either a 3put or a vput) will
		be ored with the numeric value at each pixel.  
	      -	This interacts with Freverse in an unexpected manner - the
		logical not of the data sent is anded with the data already
		in the frame buffer.

Fbmode(mode)
int mode;
		Change the way the software interprets coordinates.

Args:		mode: one of the following values:
!<.			0: all coordinates are absolute (default)
			1: coordinates are relative to current position
			2: coordinates are relative to a preset base.
!>\		Any other value is illegal.


Fbase(xbase, ybase)
int xbase, ybase;
		Set the base for base-offset coordinate mode.

Args:		xbase, ybase: the coordinates of the point relative to which
		all subsequent coordinates will be interpreted.


Fwhere(xyselect, value)
int xyselect, value;
		Determine where on the screen a coordinate will fall.

Args:		xyselect: If 0, value will be taken as an x coordinate,
		otherwise as a y coordinate.

		value: will be mapped according to the current mode and
		returned as the function value.

Notes:	      - No clipping is performed, thus decisions can be made about
		the visibility of a point based on the returned value.

	      - This routine is of limited utility to the user, but is made
		available if needed.


Fbclip(xmin, xmax, ymin, ymax)
int xmin, xmax, ymin, ymax;
		Set the software clipping boundaries.

Args:		xmin, xmax, ymin, ymax:  All subsequent put operations will
		be confined to the rectangular region
		[xmin, xmax] x [ymin, ymax].

Notes:	      - initial clipping boundaries are [0,511] x [0,479].


!>
!<+
Fbtestmode	a global (int) variable which will cause debugging
		actions.  If set to 0 (the default), the software behaves
		normally.  If set to a positive value, the framebuffer will
		never be accessed.  If set to a non-zero value, all data
		"sent" to the frame buffer will be printed (in octal) on
		stderr.  The fbtrn program can be used to change these into
		(more or less) readable instruction mnemonics.
!>
File: graphics,  Node: Putting,  Up: (graphics)Frame Buffer
Date: Fri Jan 21 20:28 1983	 Previous: Init, Next: Getting

!<(

Fpvput (x,y,value)
int x, y, value;
		Set a single pixel to a given shade.

Args:		x, y: the location of the pixel to be changed.

		value: the shade value to be written into the pixel.

Notes:	      -	Writes value  into  all  enabled  channels  at  the location
		(x,y).   The  8 low-order bits of value will be written into
		all enabled  color  channels; bit 8 will be written into the
		red overlay channel (if enabled), bit 9 into the green
		overlay channel (if  enabled)  and  bit  10  into the blue
		overlay channel (if enabled).


Fp3put (x,y,red,green,blue)
int x, y, red, green, blue;
		Writes an RGB point.  

Args:		Red: written into channel 0

		Green: written into channel 1

		Blue: written into channel 2

Notes:	      - Any or all of these writes  may  be  disabled  by clearing
		(resetting)  the appropriate bit in the RGB channel mask.


Frvput (xmin,xmax,ymin,ymax,value)
int xmin, xmax, ymin, ymax, value;
		Sets a whole box to a given shade.

Args:		xmin, xmax, ymin, ymax: The region [xmin,xmax] x [ymin,ymax]
		will be affected.

		value: written into  all  enabled channels  of  all pixels
		in  the box .  (see Fpvput)


Fr3put (xmin,xmax,ymin,ymax,red,green,blue)
int xmin, xmax, ymin, ymax, red, green, blue;
		Writes an RGB box.  (see Fp3put)

Args:		xmin, xmax, ymin, ymax: boundaries of the box.

		red, green, blue: the color to be written.

Fcvput (xc,yc,radius,value)
int xc, yc, radius, value;
		Sets a circular region of the frame buffer to a given shade.

Args:		xc, yc: coordinates of the center of the circle.

		radius: radius of the circle.

		value: written into all enabled channels of all pixels in
		the (solid) circle.

Notes:	      - Since the aspect ratio of the pixels on the screen is not
		square, the circle comes out elliptical.

Fc3put (xc,yc,radius,red,green,blue)
int xc, yc, radius, red, green, blue;
		Writes an RGB circle.

Args:		xc, yc, radius: Describe the circle.

		red, green, blue: The color to be written.


Fevput (xc, yc, xradius, yradius, value)
int xc, yc, xradius, yradius, value;
		Set an elliptical region to a single shade.

Args:		xc, yc: The center of the ellipse.

		xradius, yradius: the radii in the x and y directions.
		
		value: the shade to set each pixel to.

Notes:	      - All ellipses have their axes aligned with the x and y axes.

	      - Very narrow ellipses do not work well.

Fe3put (xc, yc, xradius, yradius, red, green, blue)
		Set an elliptical region to a color.

Args:		xc, yc: The center of the ellipse.

		xradius, yradius: the radii in the x and y directions.
		
		red, green, blue: the color to write into all pixels within
		the ellipse.

Notes:	      - All ellipses have their axes aligned with the x and y axes.

	      - Very narrow ellipses do not work well.


Fb3put (xmin,xmax,ymin,ymax,array,n)
int xmin, xmax, ymin, ymax;
char array[3][n];
int n;
		Unpack an array of pixel data into a rectangular region of
		the frame buffer. "Byte unpacker".

Args:		xmin, xmax, ymin, ymax:  The bounds of the region.

		array: a byte (char) array dimensioned 3 by n.  This
		contains the data to be written.

		n: the array "row size".
Notes:
	      - Array is unpacked row-wise into  the  area of  the
		screen  from  xmin to xmax and ymin to ymax.   The  element
		array[0][i]  is  red   data, array[1][i]  is  green  and
		array[2][i] is blue.  

	      -	The  data  is  written  left to right,  bottom  to top a row
		at a time.  

	      - N is the offset in the array between the start of each
		color, not the number of pixels in the region.  For best
		results, N should be greater than or equal to the number of
		pixels in the region ((1+xmax-xmin)*(1+ymax-ymin)).

	      -	If xmax is less than  xmin,  the write  will  wrap around
		the  side of the screen, and similarly for ymin and ymax.

	      -	Array will be packed in the correct format by the routine
		Fb3get (*note Fb3get: getting.).  As with Fb3put and Fr3put,
		only the enabled RGB channels will be written.

Fbvput(xmin, xmax, ymin, ymax, array)
int xmin, xmax, ymin, ymax;
char array[];
		Similar to Fb3put, but writes values from array into all
		enabled channels.

Args:		xmin, xmax, ymin, ymax: Describe the region.

		array: the data to be written to the region.

Notes:	      - The size of the array should be greater than or equal to the
		number of pixels in the region.

Fvvput (x1, y1, x2, y2, value):
int x1, y1, x2, y2, value;
		Draw a straight line between two points with a specified
		color.

Args:		x1, y1: The coordinates of the first point.

		x2, y2: The coordinates of the second point.

		value: written into all enabled channels along the line.

Notes:	      - The "clipping" algorithm employed by the frame buffer
		software does not work well for lines.

Fv3put (x1, y1, x2, y2, red, green, blue)
int x1, y1, x2, y2, red, green, blue;
		Draw a straight line between two points with a specified
		color.

Args:		x1, y1: The coordinates of the first point.

		x2, y2: The coordinates of the second point.

		red, green, blue: The color of the line.

Notes:	      - The "clipping" algorithm employed by the frame buffer
		software does not work well for lines.


Fgvput (x, y, data, value):
int x, y;
char data;
int value;
		Write a "graphic datum" to the frame buffer.

Args:		x, y: The starting position (left end).

		data: An 8 bit pattern which will be "written" into the 8
		pixels from (x,y) through (x+7,y).

		value: The value to be written at the "1" bits.

Notes:	      -	If the additive mode is off, then 0 bits will be written as
		black and 1 bits as the given shade.  If additive mode is
		on, the only 1 bits will be written.


Fg3put (x, y, data, red, green, blue)
int x, y;
char data;
int red, green, blue;
		Write a "graphic datum" to the frame buffer.

Args:		x, y: The starting position (left end).

		data: An 8 bit pattern which will be "written" into the 8
		pixels from (x,y) through (x+7,y).

		red, green, blue: The color to be written at the "1" bits.

Notes:	      -	If the additive mode is off, then 0 bits will be written as
		black and 1 bits as the given color.  If additive mode is
		on, the only 1 bits will be written.

Fgbvput (x, y, data, width, n, value):
int x, y;
char data[n];
int width, n, value;
		Load a bit map into a rectangular region of the frame
		buffer.

Args:		x, y: the starting point (lower left corner).

		data: the bit map.

		width: the width (in pixels) of the region to be written.

		n: the total number of bytes to be written.

		value: the shade to be written at the "1" bits.

Notes:	      - Width should be divisible by 8.

	      - The region written will be (n/(width/8)) lines high.

	      - N should be divisible by (width/8).

Fgb3put (x, y, data, width, n, red, green, blue):
int x, y;
char data[n];
int width, n, red, green, blue;
		Write a bitmap in a specified color.

Args:		x, y: the starting point (lower left corner).

		data: the bit map.

		width: the width (in pixels) of the region to be written.

		n: the total number of bytes to be written.

		red, green, blue: the color to be written at the "1" bits.

Notes:	      - Width should be divisible by 8.

	      - The region written will be (n/(width/8)) lines high.

	      - N should be divisible by (width/8).
!>
File: graphics,  Node: Getting,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 06:14 1982,	 Prev: Putting, Next: Text

!<(
Fp3get (x, y, red, green, blue)
int x, y;
short *red, *green, *blue;
		Read back the color at a pixel.

Args:		x, y: the coordinates of the pixel to be read.

		red, green, blue: pointers to the locations in which the
		color components will be saved.  The variables pointed to
		should be short ints (16 bits).

Fpoget (x, y, value)
int x, y;
short *value;
		Read the value of the overlay planes at a pixel.

Args:		x, y: the coordinates of the pixel.

		value: the value will be returned through this pointer.

Notes:	     -	If Fpvput were to be called with value, the same data would be
		rewritten into the overlay planes.  I.e., channel 8 is  read
		into  bit  8, channel 9 into bit 9, and channel 10 into bit
		10.


Fpvget (x, y, value)
int x, y;
short *value;
		Read a value back from a pixel.

Args:		x, y: the coordinates of the pixel.

		value: the value will be returned through this pointer.

Notes:	     -	This reads the bitwise OR of the data in all enabled
		channels.


Fb3get (xmin, xmax, ymin, ymax, array, n)
int xmin, xmax, ymin, ymax;
char array[3][n];
int n;
		Read back a rectangular region of the screen into an array.

Args:		xmin, xmax, ymin, ymax: describe the region to be read.

		array: the data will be read into this, with red data
		starting at array[0][0], green at array[1][0], and blue at
		array[2][0].

Notes:	      - This is the "inverse" of Fb3put.


!>
File: graphics,  Node: Text,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 06:15 1982,  Prev: Getting, Next: Map

!<(
Ftvput (x,y,text,value)
int x, y;
char *text;
int value;
		Display a text string with a given shade.

Args:		x, y: the starting point of the string.

		text: a string which will be displayed.

		value: the shade in which it will be displayed.

Notes:	      -	The string is positioned such that the lower left corner of
		the first character is at the point (x,y).  

	      -	Each character is 7 pixels wide by 9 pixels high in single
		height and width mode, 14 x 18 in double width and height
		mode.

	      - Normally, each character has a "black box" around it.  This
		can be eliminated by using the "additive mode"
		(*note additive: init.)

Ft3put(x,y,text,red,green,blue)
int x, y;
char *text;
int red, green, blue;
		Puts colored text on the screen.

Args:		x, y: starting point of the string.

		text: the string itself.

		red, green, blue: the color it will be displayed in.


Ftspacing(number)
int number;
		This routine changes the spacing between characters in the
		text put calls.  
Args:		number: the number of pixels between the lower left corner
		of adjacent characters in a text string.
Notes:	      - The default spacing is 7 pixels, characters are 5 pixels
		wide.  
	      -	The number is doubled when using double width characters.


Fscroll(nlines)
int nlines;
		Scroll the frame buffer.

Args:		nlines: the number of lines to scroll.  Positive is up and
		negative is down.

Notes:	      -	This relocates not only the image displayed, but also the
		memory addresses, so that (0,0) is always the lower left
		corner of the screen.

Fshome()
		Scroll the screen to the home position.  

Ftscroll()
		Scroll the screen up by the correct number of scanlines for
		a line of text, and erase that many lines at the bottom of
		the screen.  

Notes:	      -	The vertical size is taken into account.  
!>
File: graphics,  Node: Map,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 06:22 1982, Prev: Text, Next: Zoom

!<(
Fminit()
		Reset the map to power-up state.

Notes:	      - This wipes out the color map loaded by Fbinit (*note Init::)
		which is supposed to compensate for non-linearities in the
		output system.  It may also screw up the state of other
		portions of the frame buffer.  It's pretty drastic.

Fm3put (maploc, red, green, blue)
int maploc, red, green, blue;
		Set a color map entry to a color.

Args:		maploc: the location in the color map to be modified.

		red, green, blue: the color to set it to.

Notes:	      -	If any channels have been masked, the corresponding
		channel in the map will not be changed.  Maploc must be from
		{0..255}

	      - What this really does is to set the given location in the
		red color map to the red value, the location in the green
		color map to the green value, etc.  Thus, the color (red,
		green, blue) will be displayed at a pixel only if all three
		maps have the same input (maploc), i.e. all three channels
		in the frame buffer memory have the same value at that pixel.

Fm3get (maploc, red, green, blue)
int maploc;
short *red, *green, *blue;
		Read the contents of a color map location.

Args:		maploc: the map entry to be read.

		red, green, blue: the contents will be returned via these
		pointers.


Fmbput (startloc, map)
int startloc;
short map[3][256];
		Set the entire map at once.

Args:		startloc: the location in the map at which to start loading.

		map: the data to be loaded.

Notes:	      - If startloc is not 0, then the loading will wrap around.
		The map can be easily rotated by the sequence of calls
!<		Fmbget(0,map);
		Fmbput(1,map);
!>

Fmbget (startloc, map)
int startloc;
short map[3][256];
		Read back the whole color map.

Args:		startloc: the location to start reading at.

		map: the result comes back here.

Notes:	      -	This one wraps around too.


Fmselect (R_ch, G_ch, B_ch)
int R_ch, G_ch, B_ch;
		Determine where the input for each map comes from.

Args:		R_ch, G_ch, B_ch: selects an input for each map from the
		following list:
!<.			  0:	Red
			  1:	Green
			  2:	Blue
			  3:	Digitizer
!>\		(These are the only valid values.)


Fvideo( red, green, blue )
int red, green, blue;
		Change the inputs to the Digital-to-Analog converters.

Args:		red, green, blue: integers as above, except that 0 through 2
		select which color map supplies the input.

Notes:	      - Initial state is (0, 1, 2).


Foverlay(one, two, three)
int one, two, three;
		Alter the color assigned to each overlay plane.

Args:		one, two, three:  each of these is a bit mask determining
		the primary color(s) which the corresponding overlay turns
		on.

Notes:	      - The initial state is (1, 2, 4) with overlay one red, overlay
		two green and overlay three blue.


!>

Note:  if Fbinit has not been called, some strange results  may  become
apparent while trying to load the color map.
File: graphics,  Node: Zoom,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 06:25 1982,  Prev: Map,  Next: Display File

!<(
Fzoom (power)
int power;
		Turn on zoom and pan.

Args:		power: the amount to zoom by.  Legal values are 1, 2, 4 or 8.

Notes:	      - It tries to do something reasonable with illegal inputs.

Fzpan (x, y)
int x, y;
		Pan the screen.

Args:		x, y: the coordinates of the pixel which will be centered on
		the screen.

Notes:	      -	This routine has two functions:  it  controls the position
		of the crosshair cursor (see below) and, when zoomed,
		controls the  center  of the  zoomed area.  I.e.  the cursor
		will always be at (x,y), but when zoomed the center  of  the
		screen  will also be at (x,y).  

	      -	There is currently a hardware bug which causes the cursor to
		show up at (x, y+4).


Fzcursor (on_off)
int on_off;
		Control display of the crosshair cursor.

Args:		on_off: 0 is off, 1 is on.

Notes:	      - default is off.

Fzwrap (on_off)
int on_off;
		Control whether the image will wrap around the edges of the
		screen.

Args:		on_off: if 0, no wrapping will take place.  If 1, the image
		will wrap around.

Notes:	      - Default is on.


Fzcrop(crop)
int crop;
		Crops the image to only 1/2 or 1/4 of the screen.

Args:		crop: if 0, then there is no cropping of the image.  If 1,
		the image is cropped to 1/2 of the screen size (i.e., only
		1/4 of the total image is visible), and if 2, the image is
		cropped to 1/4 of the screen size.

Notes:	      - I have yet to think of a good use for this one.


Fzblink (on_off)
int on_off;
		This routine will cause the cursor to blink when it is on.

Args:		on_off: 0 is no blink, 1 is blink.

Notes:	      - Default is no blink.


Fz_display (x, y, color_flag, position_flag)
int x, y, color_flag, position_flag;
		Display the color and/or position of the given pixel on the
		screen.

Args:		x, y: the pixel to pick on.

		color_flag: if non-zero, the RGB components of the pixel
		color will be displayed.

		position_flag: if non-zero, the position of the pixel will
		be displayed.

Notes:	      -	The numbers are written into the overlay planes.

Fz_off ()
		This routine disables zoom and pan.

!>
File: graphics,  Node: Grabber,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 06:25 1982,	 Prev: Display File

!<(
Fgrab (cont, shift, nframes)
int cont, shift, nframes;
		Activates the digitizer, which will read into  all enabled
		channels.   

Args:		cont: if 0, a finite number of frames will be "grabbed".  If
		1, grabbing will be continuous until stopped.

		shift: the input from the digitizer will be shifted down by
		this many bits.

		nframes: the number of frames to grab (and possibly
		average).  Ignored if cont is non-zero.

Notes:	      -	Continuous grabbing runs until either a  call is made to
		Fgrab with cont=0 or the frame grabber is deselected (by,
		for example, modifying the map).  

	      -	Zoom   is   disabled  during  the  frame grabbing operation.

	      -	Note that the "frame averager" adds the digitized (and
		shifted) input to whatever is  in  the  blue channel and
		then puts the result back  into  all  enabled  channels.
		Thus,  frame averaging  will  only occur if the blue channel
		is enabled.  The 3 overlay planes act  as  low  order bits
		of   the   blue  channel  (thus  making  it effectively 11
		bits) during the averaging process.  Thus  if  the  input
		is shifted more than 2 bits, more accurate results  will  be
		obtained  if  the overlays  are enabled.  (They must then be
		cleared at the end of  the  process,  as  they  will  show
		mostly the noise in the signal).  

	      - Best results are usually obtained when averaging by
		clearing the blue channel and the overlays before starting
		the grabber.

	      -	If nframes=1 then no addition  occurs  and  the  input  is
		written straight into the selected channels.


Fungrab()
		Stop the frame grabber.

!>

File: graphics,  Node: Names,  Up: (graphics)Frame Buffer
Date: Wed Dec  1 07:08 1982,   Prev: General, Next: Init


The naming convention which is  (mostly) followed by the Frame  Buffer
routines is as follows: The first  character is always an "F".  The  second
character denotes  the type  of  object which  will  be written,  read,  or
whatever; thus "p" for points, "r"  for rectangle, "c" for circle, "b"  for
buffer.  The third character may be a "3" to denote an RGB call or a "v" to
denote a straight value write.  If a mask is specified in an RGB call,  the
mask is  a  logical rather  than  a  physical mask.   The  remaining  three
characters denote the action being taken, e.g.  "put", "get", etc.
File: graphics,  Node: Top,  Up: (dir)Top
Date: Fri Jan 21 19:22 1983

* menu:
* User Programs::		Graphics programs for general use.
* Frame Buffer::		Frame buffer library documentation.
* Megatek::			Subroutine package for Megatek.
* MUltiPicture System::		Subroutine package for MPS.
* PS300::			Documentation for the PS300.
File: graphics,  Node: User Programs,  Up: (graphics)Top
Date: Fri Jan 21 19:30 1983

* menu:
* Blockit::
* Colors::		Interactive selection of RGB color values.
* Domap::		Set up frame buffer color map.
* Falign::		
* FBCaption::		Add captions to frame buffer images.
* CLear:Fbclr:		Clear frame buffer.
* FBTrn::
* Wedge:Fbwedge:	Display wedge of intensities.
* Getfb::		Restore frame buffer image from disk file.
* GRabit::
* Ldmap::		Load color map on frame buffer.
* LOgmap::		Load logarithmic scale color map on frame buffer.
* Paint::		Interactive painting on frame buffer.
* Shapedit::		PSL (lisp) system with geometry loaded.
* Svfb::		Save frame buffer image into disk file.
* Tcolors::		Interactive selection of transparency colors & values.
* Zoom::		Interactive zooming and panning of frame buffer image.
File: graphics,  Node: User Programs,  Up: (graphics)Top
Date: Fri Jan 21 19:32 1983,		Next: Frame Buffer

* menu:
* Blockit::
* Colors::		Interactive selection of RGB color values.
* Domap::		Set up frame buffer color map.
* Falign::		
* FBCaption::		Add captions to frame buffer images.
* CLear:Fbclr:		Clear frame buffer.
* FBTrn::
* Wedge:Fbwedge:	Display wedge of intensities.
* Getfb::		Restore frame buffer image from disk file.
* GRabit::
* Ldmap::		Load color map on frame buffer.
* LOgmap::		Load logarithmic scale color map on frame buffer.
* Paint::		Interactive painting on frame buffer.
* Shapedit::		PSL (lisp) system with geometry loaded.
* Svfb::		Save frame buffer image into disk file.
* Tcolors::		Interactive selection of transparency colors & values.
* Zoom::		Interactive zooming and panning of frame buffer image.
File: graphics,  Node: Frame Buffer,  Up: (graphics)Top
Date: Fri Jan 21 19:33 1983,	Prev: User Programs, Next: Megatek

* Menu:

* General::		General Information about the Frame Buffer.
* Names::		Naming conventions for Frame Buffer routines.
* Init::		Initialization and configuration subroutines.
* Putting::		Routines to put data into the frame buffer.
* Getting::		Routines to get data from the frame buffer.
* Text::		Routines to put text into the frame buffer.
			Also includes scroll routines.
* Map::			The color map and routines to manipulate it.
* Zoom::		How to zoom and pan the image.
* Display File::	How to build and draw display files.
* Grabber::		Using the real-time digitizer (frame grabber).

File: graphics,  Node: Megatek,  Up: (graphics)Top
Date: Fri Jan 21 19:34 1983,	Prev: Frame Buffer, Next: MultiPicture System

* menu:
File: graphics,  Node: PS300,  Up: (graphics)Top
Date: Fri Jan 21 19:34 1983,	Prev: MultiPictureSystem

* menu:
File: graphics,  Node: MUltiPicture System,  Up: (graphics)Top
Date: Fri Jan 21 19:35 1983,	Prev: Megatek, Next: PS300

* menu:
File: graphics,  Node: PS300,  Up: (graphics)Top
Date: Fri Jan 21 19:35 1983,	Prev: MultiPicture System

* menu:
File: graphics,  Node: Megatek,  Up: (graphics)Top
Date: Fri Jan 21 19:44 1983,	Prev: Frame Buffer, Next: MultiPicture System

This node contains a menu!


* menu:
* Introduction: meg-intro:
* Programming Considerations::
* Subroutines::
* Matrix Routines::
* Syntax Summary::
* Sample program::
File: graphics,  Node: Megatek,  Up: (graphics)Top
Date: Fri Jan 21 20:05 1983,	Prev: Frame Buffer, Next: MultiPicture System

This node contains a menu!
!<Verbatim

                         Grafic User's Manual for the
                                 Megatek 7000
                     C Language --- UNIX Operating System


                 COMPUTER AIDED DESIGN AND GRAPHICS LABORATORY
                       SCHOOL OF MECHANICAL ENGINEERING

                               PURDUE UNIVERSITY

                                As modified by
                         Jim Guyton, Rand Corporation
                     Spencer W. Thomas, University of Utah

!>

* menu:
* Introduction: meg-intro:
* Programming Considerations::
* Subroutines::
* Matrix Routines::
* SYntax Summary::
* SAmple program::
File: graphics,  Node: meg-intro,  Up: (graphics)Megatek
Date: Fri Jan 21 20:07 1983,	Next: Programming Considerations

>>> Introduction

  GRAFIC   is  an  interactive  graphics  package  for  the  Digital  Equipment
Corporation VAX and Megatek 7000. GRAFIC allows users to  execute  programs  in
the  VAX which produce graphical output on the Megatek screen and request input
from devices interfaced to the Megatek.  Communication between the Megatek  and
the host is accomplished through a high speed parallel data transmission path.

  The  C  procedures  provided  enable the creation and manipulation of picture
"segments" as well as requesting input.  A segment is a  user-defined  grouping
of  display  information.    It contains lines, symbols, and display subroutine
calls. Segments are identified by integer numbers.

  Another important unit is the display subroutine, hereafter referred to as  a
"sub".    Subs  are  identified  by  integer  numbers. A sub is a collection of
plotting instructions which the user defines and later "calls" into a  segment.
A sub is defined with a call to sub and displayed with a call to getsub.

  The  routines  in  this package begin with "m" to denote that they operate on
the Megatek. This allows inter-mixing of calls at the device level for  several
different devices.

>>> Compilation and Linking Procedure

  A  C  program  which calls the GRAFIC procedures must be entered in the host.
It  must   be   linked   with   the   GRAFIC   procedures   which   reside   in
/usr/local/lib/libmg.a.  The  commands  to compile, link, and run a file called
test.c using UNIX are shown below:  

                    %cc test.c -lmg
                    %test




File: graphics,  Node: Programming Considerations,  Up: (graphics)Megatek
Date: Fri Jan 21 20:08 1983,	Prev: Meg-intro, Next: Subroutines

The following principles should be followed when using the GRAFIC system:
!<-
   - msetup  must  be  called  prior  to  any  other  display  routine  to
     initialize the display structure in the Megatek.

   - The following procedures require that a seg or sub be open:  mgetsub,
     mintsty,  mmark,  mnumget, mplot, mplot3, mreset, mstrget and mstring
     and mvport.  A segment or sub  is  open  after  a  call  to  mseg(n),
     msub(n),  or  mappend(n).  There is only one segment or sub open at a
     time and all display commands generate display instructions which  go
     into that segment or sub.

   - Any time a segment is open, its current status may be saved by a call
     to  mmark.  Later, if the segment is still open or has been re-opened
     with a call to mappend, the segment may be returned to the state when
     the last call to mmark was executed by calling mreset.

   - The maximum segment number + the maximum sub number must  not  exceed
     32.

   - The available area for plotting is from -2048 to 2047 units in the x,
     y  and z directions.  All vectors must be in the range -2048 to 2047.
     The Megatek can not store numbers outside this range.   The  absolute
     screen origin (0,0,0) is in the center of the screen.

   - Due to the Megatek architecture, when a dashed line is drawn, it will
     disable  blink  and dim for the rest of the vectors that are drawn in
     that segment.

   - Many Megatek commands are buffered (saved in the host) to reduce  the
     load  on  the system. The buffer is flushed (displayed) automatically
     whenever a routine requests input from the Megatek.  The  buffer  may
     also be flushed explicitly by a call to mflush.

   - In  order  to  avoid  naming  conflicts the user should not write any
     routines or define any global variables  whose  names  begin  with  a
     capital  'M'  or  capital  'G'.    GRAFIC  uses those letters for its
     internal routines and variables.   Also,  the  user  should  exercise
     caution  when naming routines that begin with a lower-case 'm' as all
     user-callable routines in the Megatek graphics package begin  with  a
     lower-case 'm'.
!>
File: graphics,  Node: Subroutines,  Up: Megatek, Next: Matrix Routines
Date: Fri Jan 21 20:10 1983,	Prev: Programming Considerations

* menu:

File: graphics,  Node: Subroutines,  Up: Megatek, Next: Matrix Routines
Date: Fri Jan 21 20:15 1983,	Prev: Programming Considerations

The  following is an alphabetical list of C-callable procedures and functions
in the GRAFIC library.  (The second name 

* menu:

* Append: mappend:
File: graphics,  Node: Subroutines,  Up: Megatek, Next: Matrix Routines
Date: Fri Jan 21 20:22 1983,	Prev: Programming Considerations

The  following is an alphabetical list of C-callable procedures and functions
in the GRAFIC library.  (The second name in the menu list is the actual name
of the routine.  The first name is provided for easier access through the 
menu.)

* menu:

* Append: mappend:
* Blank: mblank:
* BLInk: mblink:
* Colmap: mcolmap:
* CUrsor: mcursor:
* Dim: mdim:
* DIR: mdir:
* End: mend:
* ERase: merase:
* Flush: mflush:
* Getsub: mgetsub:
* GETXy: mgetxy:
* Intsty: mintsty:
* Keybrd: mkeybrd:
* Local: mlocal:
* Mark: mmark:
* MOve: mmove:
* Numget: mnumget:
* Plot: mplot:
* PLOT3: mplot3:
* Reset: mreset:
* RKnob: mrknob:
* RSwit: mrswit:
* Seg: mseg:
* SET: mset:
* SETKnob: msetknob:
* SETSwit: msetswit:
* SETUp: msetup:
* SETX: msetxy:
* STrget: mstrget:
* STRIng: mstring:
* SUb: msub:
* Vport: mvport:
* Xform: mxform:
* XYlim: mxylim:
File: graphics,  Node: mappend,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:28 1983,	Next: mblank

!<(

mappend(iseg)
int iseg;
		Reopen a segment or sub at its last active state.

Args:		iseg:  the number of the seg or sub to be reopened.
		if > 0 it is a seg,
		if < 0 it is a sub.

Notes:        - The current viewport is reset to what it was when  the  seg
		or sub was last open.  

!>viewport is reset to what it was when  the  seg
               or sub was last open.  

!>File: graphics,  Node: mappend,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:38 1983,	Next: mblank

mappend(iseg)
int iseg;

      Purpose: Reopen a segment or sub at its last active state.
    Arguments: 
               iseg:  the number of the seg or sub to be reopened.
               if > 0 it is a seg,
               if < 0 it is a sub.

        Notes: 
             - The current viewport is reset to what it was when  the  seg
               or sub was last open.  

File: graphics,  Node: mblank,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:39 1983,	Prev: mappend, Next: mblink

mblank(iseg)
int iseg;

      Purpose: Turn the display of a segment on or off.
    Arguments: 
               iseg:  the number of the segment.
               if > 0 turn the segment display off,
               if < 0 turn the segment display back on.

File: graphics,  Node: mblink,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:40 1983,	Prev: mblank, Next: mcolmap

mblink(iseg)
int iseg;

      Purpose: Cause the display of a segment to start or stop blinking.
    Arguments: 
               iseg:  The number of the segment.
               if > 0 start blinking,
               if < 0 stop blinking.

File: graphics,  Node: mcolmap,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:41 1983,	Prev: mblink, Next: mcursor

mcolmap(colors)
short colors[16][3];

      Purpose: Modify  the  mapping  from  intensities  (0-15) to colors on the
               raster display.
    Arguments: 
               colors: the  red,  green  and  blue  components  of  the  colors
               corresponding  to  the  16  different possible intensity levels.
               colors[i][0] is the red component for intensity i,  etc.    Only
               the lowest 4 bits are significant.

        Notes: 
             - The  black and white intensity levels (on the vector scope)
               are not affected by this subroutine.

File: graphics,  Node: mcursor,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:42 1983,	Prev: mcolmap, Next: mdim

mcursor(iseg)
int iseg;

      Purpose: Segment iseg is continuously (60 times per second) moved to  the
               x,y coordinates which are read from the joystick or tablet, thus
               making it a 2D cursor.  
    Arguments: 
               iseg:  the segment number.
               if > 0 attach,
               if < 0 detach.

        Notes: 
             - mblink may not be called on the cursor segment.
             - Although  transformations  and  3D  vectors will work, they
               should really not be used since this is only a 2D cursor.
             - The cursor is tracked by the Megatek,  independent  of  the
               host.
             - iseg need not be the current segment.
             - It  is possible to have more than one segment as the cursor
               simultaneously.
             - iseg is associated with the current xydevice at the time to
               the call to mcursor. Thus, it is possible to have  separate
               cursors  for  the joystick and tablet by calling cursor and
               changing the current  xydevice  (by  mset)  in  the  proper
               order.  

File: graphics,  Node: mdim,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:44 1983,	Prev: mcursor, Next: mdir

mdim(iseg,intens)
int iseg,intens;

      Purpose: Change  the  beginning  intensity  of  a segment. Initially, all
               segments begin at the highest intensity, 15.  
    Arguments: 
               iseg: the segment number.
               intens:  the new intensity of this segment.  intens must  be  in
               the range 0-15.

File: graphics,  Node: mdir,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:46 1983,	Prev: mdim, Next: mend

mdir(dx,dy,button)
int *dx,*dy,*button;

      Purpose: mdir  returns  the  deflections  of the Megatek joystick and the
               state of the button.  
    Arguments: 
               dx,dy:    the  addresses  of  the  variables  to   receive   the
               deflections of the joystick.
               button:  the address of the variable to receive the value of the
               button.

        Notes: 
             - The  values  returned represent the current position of the
               joystick corresponding to the following grid:  
                               Y

                              +3
                               |
                               |
                               |
                       -3------+-----+3 X
                               |
                               |
                               |
                              -3
             - button will be 1 if the button is depressed, 0 otherwise.

File: graphics,  Node: mend,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:47 1983,	Prev: mdir, Next: merase

mend()

      Purpose: Close the Megatek and flush all buffers.
    Arguments: 
               None.

        Notes: 
             - This routine is not generally used. It is provided for some
               special cases that require it. These usually are  concerned
               with using more than one device in the same job.  

File: graphics,  Node: merase,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:49 1983,	Prev: mend, Next: mevent

merase()

      Purpose: Erase and reinitialize the display.
    Arguments: 
               None.

File: graphics,  Node: mflush,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:51 1983,	Prev: mevent, Next: mgetsub

mflush()

      Purpose: Flush the Megatek's buffers in the  host  so  that  all  vectors
               "plotted" will be visible.
    Arguments: 
               None.

        Notes: 
             - This routine is useful if "sleep" is called in a program.

              1  keyboard
                       2  keyset
                       4  joystick button
                       8  tablet
                       16 knob
                       32 switch
             - Unfortunately, when the joystick button  is  depressed  and
               the  current  interrupt  type  is  button down (1 or 3) the
               event is not reset until the button is released.

File: graphics,  Node: Subroutines,  Up: Megatek, Next: Matrix Routines
Date: Fri Jan 21 20:49 1983,	Prev: Programming Considerations

The  following is an alphabetical list of C-callable procedures and functions
in the GRAFIC library.  (The second name in the menu list is the actual name
of the routine.  The first name is provided for easier access through the 
menu.)

* menu:

* Append: mappend:
* Blank: mblank:
* BLInk: mblink:
* Colmap: mcolmap:
* CUrsor: mcursor:
* Dim: mdim:
* DIR: mdir:
* End: mend:
* ERase: merase:
* EVent: mevent:
* Flush: mflush:
* Getsub: mgetsub:
* GETXy: mgetxy:
* Intsty: mintsty:
* Keybrd: mkeybrd:
* Local: mlocal:
* Mark: mmark:
* MOve: mmove:
* Numget: mnumget:
* Plot: mplot:
* PLOT3: mplot3:
* Reset: mreset:
* RKnob: mrknob:
* RSwit: mrswit:
* Seg: mseg:
* SET: mset:
* SETKnob: msetknob:
* SETSwit: msetswit:
* SETUp: msetup:
* SETX: msetxy:
* STrget: mstrget:
* STRIng: mstring:
* SUb: msub:
* Vport: mvport:
* Xform: mxform:
* XYlim: mxylim:
File: graphics,  Node: mevent,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:50 1983,	Prev: merase, Next: mflush

int mevent()

      Purpose: Wait  until  one  of  the peripherals is activated and return an
               integer identifying that peripheral.
    Arguments: 
               None.

        Notes: 
             - The following values are returned:  
                       1  keyboard
                       2  keyset
                       4  joystick button
                       8  tablet
                       16 knob
                       32 switch
             - Unfortunately, when the joystick button  is  depressed  and
               the  current  interrupt  type  is  button down (1 or 3) the
               event is not reset until the button is released.

File: graphics,  Node: mgetsub,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:51 1983,	Prev: mflush, Next: mgetxy

mgetsub(isub)
int isub;

      Purpose: Insert  a  call  to the display sub isub into the currently open
               segment.
    Arguments: 
               isub:  the number of the display sub which is to be called.

File: graphics,  Node: mgetxy,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:52 1983,	Prev: mgetsub, Next: mintsty

mgetxy(x,y,button)
int *x,*y,*button;

      Purpose: Return the current x,y coordinates  from  the  current  xydevice
               (joystick or tablet).
    Arguments: 
               x,y:  the addresses of the variables to receive the current x,y.
               button:    the  address  of  the variable to receive the current
               state of the button.

        Notes: 
             - button will be 1 if it is depressed, 0 otherwise.
             - The current xydevice may be changed with mset.

File: graphics,  Node: mintsty,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:54 1983,	Prev: mgetxy, Next: mkeybrd

mintsty(intens)
int intens;

      Purpose: Set the intensity for subsequent display information in the open
               segment or sub.
    Arguments: 
               intens:  the new intensity in the range 0-15.

        Notes: 
             - Unless changed by dim, the initial intensity of  a  segment
               is 15.
             - The intensity may also be changed by a call on mset("fore",
               color).

File: graphics,  Node: mkeybrd,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:54 1983,	Prev: mintsty, Next: mlocal

int mkeybrd()

      Purpose: Return a keyboard strike seen on the Megatek keyboard. The value
               returned is in 8 bit ascii with the parity bit 0.
    Arguments: 
               None.

        Notes: 
             - If no keyboard strike occurred, 0 is returned.
             - The  function  keys  are  returned  as 8 bit ascii with the
               parity bit 1.  This means that normal keyboard keys will be
               returned as numbers <= 0177,  and  function  keys  will  be
               returned as numbers >= 0300.
             - There  is  a 10 character buffer in the Megatek, so in some
               cases, it may be  necessary  to  flush  the  buffer  before
               reading from the keyboard. The buffer may be flushed by:  

                           while( mkeybrd() ) /* null */;

File: graphics,  Node: mlocal,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:55 1983,	Prev: mkeybrd, Next: mmark

int mlocal(m,addr)
float m[4][4];
int addr;

      Purpose: Place a transformation matrix in a segment.
    Arguments: 
               m:  the transformation matrix to use
               addr:    the address to put the matrix. If addr = 0 then put the
               matrix at the current location in the display list.

        Notes: 
             - mlocal returns the current address  in  the  display  list.
               This  allows the program to change the matrix once it is in
               the display list.
             - Only one matrix is used at any one time. Matrices  are  not
               concatenated.
             - See Appendix C for a sample program that uses mlocal.

File: graphics,  Node: mmark,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:56 1983,	Prev: mlocal, Next: mmove

mmark()

      Purpose: mmark,  in  effect,  inserts a flag into the display list of the
               open segment to remember its current state. Display  information
               subsequently  added to the display list may then be deleted by a
               call to reset.
    Arguments: 
               None.

        Notes: 
             - mmark  is  useful  when  tracking  or  creating   temporary
               displays.  It  allows  the  user  to  return to the current
               display state of the segment after additional  display  has
               been added.
             - Each segment can have one active mark.
             - mmark saves the current dash pattern, blink pattern, color,
               transformation  matrix,  blink  value, blank value, and dim
               value.  It also saves all vectors, getsubs  and  characters
               drawn up to that point and the current viewport.

File: graphics,  Node: mmove,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:56 1983,	Prev: mmark, Next: mnumget

mmove(iseg,x,y)
int iseg,x,y;

      Purpose: Move a segment to the absolute screen point (x,y).
    Arguments: 
               iseg:  the number of the segment to be moved.
               x,y:    the  screen  coordinates  to which the segment should be
               moved.

        Notes: 
             - mmove changes the absolute  origin  of  a  segment  (or  in
               effect the center of the screen for the segment).
             - The segment iseg need not be open, nor does move effect the
               currently open segment.
             - mmove  actually uses the transformation matrix to translate
               the segment. For this reason, you should not use mmove on a
               segment in which you also use  mxform.  If  you  are  using
               mxform, use trans in place of mmove.

File: graphics,  Node: mnumget,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:57 1983,	Prev: mmove, Next: mplot

double mnumget(x,y,prompt,maxdig,flag)
int x,y;
char *prompt;
int maxdig;
int *flag;

      Purpose: Permit   a  number  to  be  entered  on  the  Megatek  keyboard,
               displayed, and returned to the host.
    Arguments: 
               x,y:  the position on the Megatek screen where the prompt is  to
               be displayed.
               prompt:  a string to be used as the prompt.
               maxdig:    the  maximum  number  of digits to accept.  flag:  an
               error flag that returns:  
                       0 if a valid number was returned
                       1 if a invalid number was entered
                       2 if no number was entered

        Notes: 
             - This routine uses mmark and mreset in  the  currently  open
               segment.
             - Typing  the  DEL  key  allows  the  user  to  start over in
               entering the number.
             - Control-h is the backspace.
             - A carriage return terminates the input.
             - The number  entered  is  returned  as  a  double  precision
               number.
             - Decimal points are allowed in the input number.
             - Octal  numbers  may  be input by preceding the input number
               with a zero.

File: graphics,  Node: mplot,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:57 1983,	Prev: mnumget, Next: mplot3

mplot(x,y,pen)
int x,y,pen;

      Purpose: Plot a straight line in the currently open segment or sub.
    Arguments: 
               x,y:  the coordinates of the point to which the line  should  be
               drawn.
               pen:  the pen code for the line type:  
                       2  Plot a solid vector.
                       3  Plot a blank vector (reposition).
                       4  Plot a dashed vector.
                       5  Plot a single point at (x,y).

        Notes: 
             - After calling mseg or msub, the beam position is (0,0,0)
             - Plot  actually  draws  a  3-dimensional  vector  using  the
               current Z value.

File: graphics,  Node: mplot3,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:58 1983,	Prev: mplot, Next: mreset

mplot3(x,y,z,pen)
int x,y,z,pen;

      Purpose: Plot a 3D vector in the currently open seg or sub.
    Arguments: 
               x,y,z:  the coordinates of the point to which the line should be
               drawn.
               pen:  the same as for mplot.

File: graphics,  Node: mreset,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:59 1983,	Prev: mplot3, Next: mrknob

mreset()

      Purpose: Return the currently open  segment  to  the  marked  state.  The
               display information added to the segment since the call to mmark
               will be deleted and the seg state is returned.
    Arguments: 
               None.

        Notes: 
             - mreset   is   the   complementary   routine  to  mmark.  It
               essentially "backs up" and  erases  the  end  of  the  open
               segment.
             - The  segment  to  be mreset must still be open or must have
               been re-opened by a call to mappend.
             - The viewport is also reset.

File: graphics,  Node: mrknob,  Up: (graphics)Subroutines
Date: Fri Jan 21 20:59 1983,	Prev: mreset, Next: mrswit

mrknob(knobno, val)
int knobno;
short *val

      Purpose: Read the value of a knob.
    Arguments: 
               knobno: The number of the knob to read.  This should be  in  the
               range  0-7,  or  -1 if a knob event is being responded to (i.e.,
               mevent returned a knob event).  The knobs are numbered  left  to
               right, top to bottom, i.e.  
                       0       1
                       2       3
                       4       5
                       6       7
               val:  The  value  read  from  the  knob  is  returned  into this
               variable.

File: graphics,  Node: mrswit,  Up: (graphics)Subroutines
Date: Fri Jan 21 21:00 1983,	Prev: mrknob, Next: mseg

mrswit(switno, val)
int switno;
short *val;

      Purpose: Read a switch/light combination.
    Arguments: 
               switno: The number of the switch to be read.   This  is  in  the
               range   0-15.      The   switches  are  numbered  left-to-right,
               top-to-bottom.  The number may be -1 if mevent returned a switch
               event.  In this case, the switch which caused the event will  be
               read.
               val:  The  value  will be returned here.  See the megatek manual
               for meaning of "value".

File: graphics,  Node: mseg,  Up: (graphics)Subroutines
Date: Fri Jan 21 21:00 1983,	Prev: mrswit, Next: mset

mseg(iseg)
int iseg;

      Purpose: Create or delete a segment.
    Arguments: 
               iseg:  the segment number.
               if > 0 create the segment,
               if < 0 delete the segment,
               if = 0 delete all segments (clear screen).

File: graphics,  Node: mset,  Up: (graphics)Subroutines
Date: Fri Jan 21 21:01 1983,	Prev: mseg, Next: msetknob

mset(option,value)
char *option;
int value;

      Purpose: Set global display parameters for the Megatek.
    Arguments: 
               option:  the option to be set.
               value:  the value to be used.
               Currently defined options and values are:
               Option                Range                 Initially
               rota[tion]            0<=value<=3           0
               scal[e]               0<=value<=7           3
               dash[pattern]         any 16-bits           052525
               blin[kpattern]        0<=value<=15          1
               erro[rlevel]          1<=value<=5           3
               xyin[terrupt]         0<=value<=5           1
               joys[tick]                                  joystick
               tabl[et]                                    joystick
               rela[tive]                                  absolute
               abso[lute]                                  absolute
               fore[ground]          color spec            white
               back[ground]          color spec            black
               

        Notes: 
             - Only   the   first   four   characters  of  an  option  are
               significant.

             - "rotation" sets the  current  text  rotation.    The  value
               specifies how many quadrants ccw to rotate the text.
             - "scale"  specifies  the  current  text  size.    The  value
               specifies how many times the  smallest  size  to  use.  For
               example size 5 is 5 times larger than size 0.  Size 0 is 12
               units high and 12 wide including inter-character spacing.
             - "dashpattern"  specifies  the  pattern  to use when drawing
               dashed lines. The value is a bit pattern to use for drawing
               the dashed lines.  The pattern in in effect for the  entire
               segment.
             - "blinkpattern"  specifies  the  pattern to blink in for the
               current segment.   The  value  specifies  which  predefined
               pattern is to be used.
             - "errorlevel"  specifies  the  maximum  level  of  errors to
               ignore. The possible levels are:  
                       6       SYSTEM
                       5       FATAL
                       4       WARNING
                       3       CAUTION
                       2       COMMENT
                       1       NOTE
             - "xyinterrupt" specifies  when  the  current  xydevice  will
               interrupt (and wake up mevent). The possible values are:  
                       0       no interrupts
                       1       interrupt on button down
                       2       interrupt on button up
                       3       interrupt on button down and up
                       4       interrupt at 100HZ intervals
                       5       interrupt at 100HZ intervals
                               while button down
             - "joystick" sets the current xydevice to be the joystick.
             - "tablet" sets the current xydevice to be the tablet.
             - "relative"  and  "absolute"  specify  the  current  type of
               vectors being drawn.
             - "foreground" and "background" can be used to set entries in
               the color lookup table.  "background" always sets  entry  0
               (the  background  color).  "foreground" is used to select a
               color for drawing with.  The current intensity (as  set  by
               mintsty)  is  associated  with  the  color.   Colors may be
               selected from the set of names red,  green,  blue,  yellow,
               magenta,  cyan,  white, black, gray, orange, brown, purple,
               or may be  specified  numerically.    To  specify  a  color
               numerically,  a  string  of  the  form "red,green,blue,b&w"
               should be given, with the numbers red, green, blue, and b&w
               in the range 0-15.  For example,  a  pink  color  might  be
               "15,12,12,15".    The b&w entry is the intensity to be used
               on the vector drawing display.

File: graphics,  Node: msetknob,  Up: (graphics)Subroutines
Date: Fri Jan 21 21:02 1983,	Prev: mset, Next: msetswit

msetknob(knobno, string, value)
int knobno, value;
char *string;

      Purpose: Set knob attributes.
    Arguments: 
               knobno: selects the knob which will be affected  by  the  string
               and value selection.
               string,value: Selected from the set below:
               Option                Range                 Initially
               mini[mum]             -32768 - 32767        ?
               maxi[mum]             -32768 - 32767        ?
               gain                  0 - 65536             ?
               valu[e]               -32768 - 32767        0
               thre[shold]           0 - 32767             ?
               freq[uency]           0 - 32767             ?

        Notes: 
             - Initial  values  are  generally  not known, and not useful.
               Always initialize the knobs.
             - minimum and maximum are the  smallest  and  largest  number
               that  the  dial  will ever return.  Once the knob value has
               reached a limit, further turns in the same  direction  will
               have no effect.  There is no way to disable this.
             - Gain  is the amount that the value will change for a single
               dial turn.
             - Value just sets the current value.
             - Threshold determines the amount of  change  needed  in  the
               value before an event will be generated.
             - Frequency  sets  the  interrupt  rate  in  continuous  mode
               update.  Each unit is a multiple of 5 milliseconds.

File: graphics,  Node: msetswit,  Up: (graphics)Subroutines
Date: Fri Jan 21 21:02 1983,	Prev: msetknob, Next: msetup

msetswit(switno, string, value)
int switno, value;
char *string;

      Purpose: Set attributes and values for the switches and lights.
    Arguments: 
               switno: The switch which will be affected.  Range is 0 to 15.
               string, value: See table below:
               Option                Range                 Initially
               coup[le]              0 or 1                1 (couple)
               togg[le]              0 or 1                1 (toggle)
               valu[e]               0 or 1                0 (when not pressed)
                                                                               inte[rrupt]0-30(disabled)
               ligh[t]               0-3                   0 (off)

        Notes: 
             - The couple option selects whether the actions of the switch
               and the light are coupled.  If not, pressing the switch has
               no effect on the light.
             - The toggle option selects  whether  switch  presses  should
               toggle the value or if the value should be 1 only while the
               switch is pressed (momentary).
             - The  value  option sets the current value of the switch (in
               toggle mode), or whether the value should be 0  or  1  when
               the switch is not pressed (in momentary mode).
             - The  interrupt  option selects the type of interrupts which
               should be received from the switch.  The values are 
                       0       No interrupts ever.
                       1       Interrupt when the switch is pressed
                       2       Interrupt when the switch is released
                       3       Interrupt both times
             - Finally, the light option controls  what  the  light  looks
               like.  The values are 
                       0       Light off
                       1       Light on
                       2       Light blinking at 1Hz
                       3       Light blinking at 8Hz
               If  the light is coupled to the switch, pressing the switch
               will turn the light off if it is on (or blinking), and  off
               if it is on.

File: graphics,  Node: msetup,  Up: (graphics)Subroutines
Date: Fri Jan 21 21:03 1983,	Prev: msetswit, Next: msetxy

msetup()

      Purpose: Initialize the graphics package.
    Arguments: 
               None.

        Notes: 
             - It  is  suggested  that  the  call  to  msetup be the first
               executable statement.
             - msetup returns a value to indicate success or failure.   In
               most cases it can be ignored. Special applications may wish
               to use the value returned. The values returned are:  
                       -1      could not open Megatek
                       0       successful open
                       1       successful open, global structure
                               was not reset
               These values are intended for the world level routines, but
               may be used on the device level if desired.

File: graphics,  Node: msetxy,  Up: (graphics)Subroutines
Date: Fri Jan 21 21:04 1983,	Prev: msetup, Next: mstrget

msetxy(x,y)
int x,y;

      Purpose: Set the current position of the cursor to x,y.
    Arguments: 
               x,y:  The screen coordinates to set the cursor to.

        Notes: 
             - If  msetxy  is used with mxylim, the programmer should take
               care to call msetxy after he has called mxylim since mxylim
               also moves the cursor location.

File: graphics,  Node: mstrget,  Up: (graphics)Subroutines
Date: Fri Jan 21 21:04 1983,	Prev: msetxy, Next: mstring

mstrget(x,y,prompt,max,array)
int x,y;
char *prompt;
int max;
char *array;

      Purpose: Read and display characters at screen location (x,y).
    Arguments: 
               x,y:  the screen position to display the prompt at.
               prompt:  A string to be used for a prompt.
               max:  the maximum number of characters to be accepted.
               array:  the location to store the string in.

        Notes: 
             - One should be  aware  that  mstrget  calls  mmark,  mreset,
               mstring,  and  mkeybrd  to  manage the display and read the
               characters. Characters are read and displayed as  they  are
               typed.
             - Pushing the DEL key allows the user to start over.
             - Control-h is the backspace.
             - A carriage return terminates the input.

File: graphics,  Node: mstring,  Up: (graphics)Subroutines
Date: Fri Jan 21 21:04 1983,	Prev: mstrget, Next: msub

mstring(format,args)
char *format;

      Purpose: Display the string at the current beam position.
    Arguments: 
               format:  the format as if for printf.
               args:  arguments as specified in the format.

        Notes: 
             - This routine is exactly like printf, except that it outputs
               its string at the current beam position.
             - For example:  

                   mstring("This is a string") produces
                           This is a string
                   mstring("Height = %d",24) produces
                           Height = 24

             - The current text scale and rotation are used.

File: graphics,  Node: msub,  Up: (graphics)Subroutines
Date: Fri Jan 21 21:05 1983,	Prev: mstring, Next: mvport

msub(isub)
int isub;

      Purpose: Create  a  display  subroutine. msub is identical to mseg except
               that a display sub is not displayed until it is "called" into  a
               segment by a mgetsub call.
    Arguments: 
               isub:  the display number.

        Notes: 
             - It  is  important  that  the  pen  location  be returned to
               (0,0,0) at the end of the definition of a sub.  The call to
               the sub from a segment  is  a  single  display  instruction
               (djms),  hence  the segment assumes that the sub will leave
               the beam at the same position as when the sub was called.
             - This is usually used to conserve space in the display list,
               when many copies of the same object are drawn.

File: graphics,  Node: mvport,  Up: (graphics)Subroutines
Date: Fri Jan 21 21:06 1983,	Prev: msub, Next: mxform

mvport(xl,yb,xr,yt)
int xl,yb,xr,yt;

      Purpose: Set the current viewport. All vectors drawn after this  will  be
               clipped to the viewport.
    Arguments: 
               xl,yb:   the lower left corner of the new viewport.  xr,yt:  the
               upper right corner of the new viewport.

        Notes: 
             - Each segment has a separate viewport.
             - When entered, each segment has a viewport equal to the full
               screen.

File: graphics,  Node: mxform,  Up: (graphics)Subroutines
Date: Fri Jan 21 21:07 1983,	Prev: mvport, Next: mxylim

mxform(iseg,m)
int iseg;
float m[4][4];

      Purpose: Make matrix m the transformation matrix in segment iseg.
    Arguments: 
               iseg:  the segment to use.
               m:  the 4x4 matrix to become the new transformation matrix.

        Notes: 
             - mxform will send any  matrix  that  you  give  it  and  the
               Megatek  will try to interpret it as a valid transformation
               matrix. Therefore it is up to the user to insure that he is
               sending a valid matrix.
             - This  matrix  is  the  concatenation  of  the  standard  3D
               rotation,  scaling and translation matrix.  See the Megatek
               documentation for further details.
             - See Appendix A for some routines  to  aid  in  forming  and
               manipulating a transformation matrix.

File: graphics,  Node: mxylim,  Up: (graphics)Subroutines
Date: Fri Jan 21 21:07 1983,	Prev: mxform

mxylim(xl,yb,xr,yt)
int xl,yb,xr,yt;

      Purpose: Establish  the  ranges  within  which  the cursor will track the
               xydevice and therefore the range of values that may be  returned
               by mgetxy.
    Arguments: 
               xl,yb:  the lower-left corner of the cursor viewport xr,yt:  the
               upper-right corner of the cursor viewport.

        Notes: 
             - mxylim  changes the position of the cursor to be within the
               boundaries of the cursor viewport.

File: graphics,  Node: Matrix Routines,  Up: (graphics)Megatek
Date: Fri Jan 21 21:10 1983, 	Prev: Subroutines, Next: Syntax Summary

  Several  routines  are  provided  to  assist  in  creating  and  manipulating
transformation matrices. They are:  

ident(m)
float m[4][4];

               sets m equal to the identity matrix

mmult(m1,m2,m3)
float m1[4][4],m2[4][4],m3[4][4];

               multiplies m1 by m2 and stores the result in m3.  m3 may  be  m1
               or m2

vmult(v1,m1,v2)
float v1[4],m1[4][4],v2[4];

               multiplies  the  1x4 vector v1 by the 4x4 matrix m1 yielding the
               1x4 vector v2.

rotate(m,rx,ry,rz)
float m[4][4],rx,ry,rz;

               rotates m rx,ry,rz degrees

scale(m,sx,sy,sz)
float m[4][4],sx,sy,sz;

               scales m sx,sy,sz times

trans(m,tx,ty,tz)
float m[4][4],tx,ty,tz;

               translates m tx,ty,tz units

mkrotat(m,rx,ry,rz)
float m[4][4],rx,ry,rz;

               forms  a  rotation  matrix  for   concatenation   with   another
               transformation matrix

mkscale(m,sx,sy,sz)
float m[4][4],sx,sy,sz;

               forms   a   scaling   matrix   for  concatenation  with  another
               transformation matrix

mktrans(m,tx,ty,tz)
float m[4][4],tx,ty,tz;

               forms  a  translation  matrix  for  concatenation  with  another
               transformation matrix




File: graphics,  Node: SYntax Summary,  Up: (graphics)Megatek
Date: Fri Jan 21 21:11 1983,	Prev: Matrix Routines, Next: Sample Program

  Syntax summary for subroutines:  

    mappend(iseg)
    mblank(iseg)
    mblink(iseg)
    mcolmap(colors)
    mcursor(iseg)
    mdim(iseg,intens)
    mdir(&dx,&dy,&button)
    mend()
    merase()
    int mevent()
    mflush()
    mgetxy(&x,&y,&button)
    mgetsub(isub)
    mintsty(intens)
    int mkeybrd()
    int mlocal(m, addr)
    mmark()
    mmove(iseg,x,y)
    mmult(m1,m2,m3)
    double mnumget(x,y,prompt,maxdig,&flag)
    mplot(x,y,pen)
    mplot3(x,y,z,pen)
    mreset()
    mrknob(knobno, &val)
    mrswit(knobno, &val)
    mseg(iseg)
    mset(option,value)
    msetknob(knobno, option, value)
    msetswit(knobno, option, value)
    int msetup()
    mstrget(x,y,prompt,max,&array)
    mstring(format,args)
    msub(isub)
    mvport(xl,yb,xr,yt)
    mxform(iseg,m)
    mxylim(left,bottom,right,top)



File: graphics,  Node: SAmple program,  Up: (graphics)Megatek
Date: Fri Jan 21 21:12 1983,	Prev: Syntax Summary

  This  program  will draw two boxes centered on (0 , 0 , 0).  It will scale up
one , and then rotate the  boxes  around  the  origin  in  opposite  directions
forever.

    main()
    {
            float m[4][4] , m1[4][4];
            register int addr , addr1;

            msetup();

            /* first create a 3D box */
            msub(1);
            mplot3(-300 , -300 , 300 , 3);
            mplot3(300 , -300 , 300 , 2);
            mplot3(300 , 300 , 300 , 2);
            mplot3(-300 , 300 , 300 , 2);
            mplot3(-300 , -300 , 300 , 2);
            mplot3(-300 , -300 , -300 , 3);
            mplot3(300 , -300 , -300 , 2);
            mplot3(300 , 300 , -300 , 2);
            mplot3(-300 , 300 , -300 , 2);
            mplot3(-300 , -300 , -300 , 2);
            mplot3(-300 , -300 , 300 , 3);
            mplot3(-300 , -300 , -300 , 2);
            mplot3(300 , -300 , 300 , 3);
            mplot3(300 , -300 , -300 , 2);
            mplot3(-300 , 300 , 300 , 3);
            mplot3(-300 , 300 , -300 , 2);
            mplot3(300 , 300 , 300 , 3);
            mplot3(300 , 300 , -300 , 2);
            mplot3(0 , 0 , 0 , 3);

            mseg(1);

            /* rotate the first box 30 degrees */

            ident(m);
            rotate(m , 30. , 30. , 30.);
            addr = mlocal( m , 0);
            mgetsub(1);

            /* rotate the second box 30 degrees and
                    scale it in size 3 times */

            ident(m1);
            rotate(m1 , 30. , 30. , 30.);
            scale(m1 , 3. , 3. , 3.);
            addr1 = mlocal( m1 , 0 );
            mgetsub(1);

            /* note there is only one copy of the box
                    in the display list at this time */

            mflush();

            for(;;){
                    /* rotate the boxes around each other forever */
                    rotate(m , 2. , 2. , 2.);
                    rotate(m1 , -2. , -2. , -2.);
                    mlocal(m , addr);
                    mlocal(m1 , addr1);
            }
    }
File: graphics,  Node: MUltiPicture System,  Up: (graphics)Top
Date: Fri Jan 21 21:22 1983,	Prev: Megatek, Next: PS300

(This node has a menu!)

This  document  describes  the  current software  package  for the MultiPicture
System on the University of Utah  Computer  Science  Dept.  Graphics  Lab  Unix
system.    All specifications are subject to change without notice.  To use the
symbolic definitions for certain values, the file <mps.h> must be  included  in
the  C program.  The routines are available from the library -lps.  In general,
if an error is detected during program execution, the program will be  aborted.
The  only  errors  currently  detected  are  those  which cause the hardware to
timeout.  This is generally  caused  by  filling  up  the  MultiPicture  System
refresh buffer.

* menu:
* Initialization::
* Displaying Data::
* Matrix Handling::
* INTeraction::
File: graphics,  Node: Initialization,  Up: (graphics)MUltiPicture System
Date: Fri Jan 21 21:21 1983,	Next: Displaying Data

PSinit(nticks, null)
                This  routine  must  be  called  before  any other MultiPicture
                System  routines.    It  initializes  the  MultiPicture  System
                hardware  and  the  software  data  structures.    Nticks is an
                integer specifying the number of 1/120 sec ticks  per  refresh.
                The  screen  will be refreshed no more often than this.  If the
                image is too complex, the refresh may be less  often,  however.
                The  second  argument  is  ignored,  and  is  included only for
                compatibility with previous software versions.  A value of 0 is
                returned on success, and -1  on  failure.    In  the  event  of
                failure, an error message is printed.

PSnewframe()    This  routine  must  be  called  to  cause the data sent to the
                MultiPicture System to be displayed.

File: graphics,  Node: Displaying Data,  Up: (graphics)MUltiPicture System
Date: Fri Jan 21 21:22 1983,	Prev: Initialization, Next: Matrix Handling

The following routines are used to display data on the MultiPicture System.

PSdraw3d(data, npts, mode, interp, w)
                Draw 3 dimensional data on the MultiPicture System.  Data is an
                integer array [npts][3], npts is the number  of  points  to  be
                drawn.    Mode  describes  the "connectedness" of the data, and
                should be drawn from the following set:

                MDMD            Move to the first point, draw a line from there
                                to the second, move to the third, etc.

                DMDM            Draw a line from the current  position  to  the
                                first point, move to the second, . . .

                MDDD            Move  to  the  first point, then draw connected
                                lines from each point to the next.

                DDDD            Draw from the current  position  to  the  first
                                point, then from there to the second point, . .
                                .

                DOTS            Move  the  beam  to each point in turn.  If the
                                line texture is set  to  dots  (see  PStexture,
                                below),  a dot will be drawn at each point.  If
                                not, then nothing will be drawn.

                Interp determines the interpretation of  the  numerical  values
                and may assume the following values:

                BASE_OFF        The  first  point is interpreted as an absolute
                                position, subsequent points  are  offsets  from
                                the base point.

                OFFSET          All  points  are  offsets  from  the previously
                                defined base point.

                ABS_REL         The first point is an absolute  position,  each
                                point  is interpreted as a relative offset from
                                the preceding point.

                REL             The first point is a relative offset  from  the
                                current  position,  all  following  points  are
                                treated as relative offsets from the  preceding
                                point.

                ABS             All points are absolute positions.

                W is the homogeneous divisor.  

PSdraw2d(data, npts, mode, interp, z, w)
                Data  is  an  integer  array  [npts][2],  npts is the number of
                points to be drawn.  Mode, interp, and w are as in PSdraw3d.  Z
                is the z coordinate to be appended to each (x, y) value to make
                a 3 dimensional position.  This is  typically  0  when  drawing
                only 2 dimensional data.

PStext(text)    Put  a text string on the MultiPicture System.  The string will
                start at the current position,  and  will  be  drawn  with  the
                current size, slant, and orientation.  Text is a text string.

PSblink(on_off) Controls blinking of displayed data.  All data which is sent to
                the MultiPicture System after the call to PSblink will blink if
                on_off  is  non-zero.   If on_off is zero, then subsequent data
                will not blink.

PSdash(on_off)  This subroutine provides an easy way to get dashed  lines.    A
                larger  selection  of dash styles is provided by PStexture (see
                below).  If on_off is non-zero, data drawn after  the  call  to
                PSdash  will be displayed as medium dashed lines.  If on_off is
                zero, solid lines will be drawn.

PStexture(texture)
                Provides control over line texture.  Texture may be one of  the
                following values:

                0               Solid lines.

                1               Dot   mode.    A  dot  will  be  drawn  at  the
                                conclusion of each beam motion.

                2               Short Dashes.

                3               Medium Short Dashes.  This  is  the  size  dash
                                produced by PSdash().

                4               Medium Long Dashes.

                5               Long dashes.

                6               Long-Short Dashes.

                7               Long-Short-Short Dashes.

PSchar(csize, [ysize, tilt])
                This  subroutine  sets the character generator characteristics.
                If csize is from 0 to 7, then it gives the horizontal dimension
                of the character, ysize gives the vertical dimension, and  tilt
                determines  the  orientation.  If tilt is 0, the characters are
                horizontal, if non-zero, the characters are rotated 90  degrees
                so  strings  will  run  from  bottom to top of the screen.  The
                actual character size is approximately .07*(size+1) inches  for
                csize  between  0  and  7.  If csize is from 8 to 23, it is the
                only parameter used  and  specifies  both  character  size  and
                slant,  with  character  sizes  8  to 15 representing unslanted
                characters, and sizes from 16 to 23 slanted  characters.    The
                sizes  are  given  below for sizes 8 to 15, for sizes 16 to 23,
                add 8 to the size number given below.

                8               0.14 inches

                9               0.03 inches

                10              0.06 inches

                11              0.10 inches

                12              0.16 inches

                13              0.27 inches

                14              0.45 inches

                15              0.74 inches

File: graphics,  Node: Matrix Handling,  Up: (graphics)MUltiPicture System
Date: Fri Jan 21 21:23 1983,	Prev: Displaying Data, Next: Interaction

This  section describes the subroutines used  to  manipulate  the  MultiPicture
System  matrices.  All parameters are integers unless otherwise specified.  The
MultiPicture System contains a hardware matrix stack 16 matrices deep including
the current transformation matrix. All line data is passed through  the  matrix
multiplier before being displayed.

PSpush()        Push  the  current transformation onto the stack.  Makes a copy
                of the current transformation matrix and  pushes  it  onto  the
                matrix stack.  The transformation matrix is unchanged.

PSpop()         Pop  the  transformation  matrix  off  the top of the stack and
                replace  the  current  transformation  matrix  with  it.    The
                contents of the current transformation matrix are destroyed.

PSrotate(angle, axis)
                Preconcatenate  a rotation matrix to the current transformation
                matrix.  Angle is a floating point number giving the  value  in
                radians  of  the  angle  to  rotate through.  All rotations are
                counter-clockwise about the given axis.   Axis  is  an  integer
                with  the value 1 to rotate about the X axis, 2 to rotate about
                the Y axis, and 3 to rotate about the Z axis.

PSscale(xscale, yscale, zscale, w)
                Preconcatenate a scaling matrix to the  current  transformation
                matrix.    Xscale,  yscale  and  zscale are the scaling factors
                along the three axes.  These are all divided by w  to  get  the
                actual scale factor applied.

PStranslate(xt, yt, zt, w)
                Preconcatenate    a   translation   matrix   to   the   current
                transformation matrix.  Xt,  yt  and  zt  are  the  translation
                distances  along  each axis.  Again, w is a homogeneous scaling
                factor.

PSwindow(left, right, bottom, top, hither, yon, eye, scale)
                Preconcatenate a windowing matrix to the current transformation
                matrix.  Generally  this  is  the  first  (i.e.,  most  global)
                transformation  applied,  and  it  is  only  applied once.  The
                parameters are described below.  

                left, right     The left and right boundaries of the window  at
                                the hither clipping plane. (x values)

                bottom, top     The  top and bottom boundaries of the window at
                                the hither clipping plane. (y values)

                hither, yon     The hither and yon clipping planes. (Z values)

                eye             The  eye  position.   There is some interaction
                                between this and the hither and yon  values  to
                                allow   specification   of   certain   infinite
                                distances, or to indicate the absence of hither
                                and/or yon clipping  planes.    If  yon=hither,
                                then  no  yon clipping will be performed (i.e.,
                                the  yon  clipping  plane  will  be  placed  at
                                infinity).   If eye=hither, then no perspective
                                transformation will be  generated,  the  window
                                will  produce  an  orthographic projection with
                                the eye at infinity.  If all three  are  equal,
                                then  an  orthographic  projection  with  no  z
                                clipping will be performed.    In  this  latter
                                case, no depth cueing will appear either.

                scale           This is the homogeneous divisor.

PSviewport(left, right, bottom, top, hither, yon)
                While  this  subroutine  does  not  affect  the  transformation
                matrix, it is closely related.  It sets the  hardware  viewport
                onto which the viewing window will be mapped.  The values left,
                right, bottom and top should be in the range [-2047, 2047], and
                the values of hither and yon (controlling brightness) should be
                in the range [0,63].  Hither should be greater than yon to give
                proper depth cueing.

PSsetmat(m)     A low level routine to load the matrix m[4][4] into the current
                transformation   matrix.      The   previous  contents  of  the
                transformation matrix are lost.

PSgetmat(m)     Read the current transformation matrix into the integer 4 by  4
                matrix m. 

PSconcat(m)     Preconcatenate  the  matrix  m  to  the  current transformation
                matrix.


File: graphics,  Node: INTeraction,  Up: (graphics)MUltiPicture System
Date: Fri Jan 21 21:24 1983,	Prev: Matrix Handling

The  routines  described in this section are used to access the  input  devices
and  modify  the  cursor position.  The hit testing routines are also described
below.

tbget(x, y, pen)
                Read the position and status of the tablet puck.  The pen value
                has 4 bits indicating the status of  the  4  buttons.    The  z
                button corresponds to bit 0 (1), with buttons 1-3 corresponding
                to  bits  1-3  (2,4,8).    The parameters should be pointers to
                integers.

PenChanged(pen) A simple finite state machine which tests the bottom (z) bit of
                the pen value and compares  it  to  the  previous  value.    It
                returns the following values:

                0               if the button was previously up, and still is.

                1               if  the  button  was previously up, but is down
                                this time.

                2               if the button was previously down and still is.

                3               if the button was previously down,  but  is  up
                                this time.

                This   routine   needs  to  be  'primed',  usually  by  calling
                PenChanged(0) before the first use.  

tbset(xmin, xmax, ymin, ymax)
                Sets the range of x and y values into which the physical tablet
                values will be mapped.   Initial  setting  is  (-32767,  32767,
                -32767, 32767).

PSknob(knob)    Read  the  value  from  a  knob.  Returns the knob value as the
                value of the function.  Knob should be an  integer  designating
                the  desired  knob.  For our system, it is in the range 0 to 7,
                with the knobs being numbered 
                        0   4
                        1   5
                        2   6
                        3   7

PScursor(stat, x, y, pen)
                set the position of the MultiPicture System cursor.    Stat  is
                zero  to  stop cursor display and non-zero to start or continue
                it.    X  and  y  are  the  cursor  position   in   the   range
                [-32767, 32767],  and pen is zero for a dim cursor and non-zero
                for a bright cursor.

PScurset(cursor, mode)
                A primitve method of setting  the  shape  of  the  MultiPicture
                System  cursor.    Cursor  should  be  an  integer array [4][2]
                containing the points defining the cursor  shape.    The  point
                values  should  be referenced to a [-32767, 32767] range.  They
                are interpreted in the relative mode,  with  the  cursor  (x,y)
                position  as  the  starting point.  Mode is chosen from the set
                {MDMD, DMDM, MDDD, DDDD}.

PSbeginHit(centerX, centerY, half, scale)
                Begin hit testing.  This routine defines a hit  testing  window
                centered  at  the  point (centerX, centerY) with a half size of
                half.  Scale is the homogeneous divisor.  The routine  disables
                output  to  the  refresh  buffer  and  returns.  Hit testing is
                performed  by  drawing  the  entities  to  be  tested,  calling
                PStestHit  after each one to determine if it was visible in the
                hit window.

PStestHit()     Returns a 0 if no lines or text were visible in the hit  window
                since  the  last  call  to  PStestHit,  or  since  the  call to
                PSbeginHit if  this  is  the  first  call  to  PStestHit.    If
                something was visible, returns 1.

PSendHit()      Ends  hit  testing, popping the hit window off the matrix stack
                and re-enabling refresh buffer output.


File: graphics,  Node: PS300,  Up: (graphics)Top
Date: Fri Jan 21 21:26 1983,	Prev: MultiPicture System

No info documentation available for PS300.  See the excellent hard
copy manuals and/or consult a local wizard for information.

File: graphics,  Node: User Programs,  Up: (graphics)Top
Date: Fri Jan 21 23:24 1983,		Next: Frame Buffer

* menu:
* Blockit::		Block the input.
* Colors::		Interactive selection of RGB color values.
* Domap::		Set up frame buffer color map.
* Falign::		Put up alignment bars on frame buffer.
* FBCaption::		Add captions to frame buffer images.
* CLear:Fbclr:		Clear frame buffer.
* FBTrn::		Translate frame buffer instructions for humans.
* Wedge:Fbwedge:	Display wedge of intensities.
* Getfb::		Restore frame buffer image from disk file.
* GRabit::		Frame grabber.
* Ldmap::		Load color map on frame buffer.
* LOgmap::		Load logarithmic scale color map on frame buffer.
* Paint::		Interactive painting on frame buffer.
* Shapedit::		PSL (lisp) system with geometry loaded.
* SVfb::		Save frame buffer image into disk file.
* Tcolors::		Interactive selection of transparency colors & values.
* Zoom::		Interactive zooming and panning of frame buffer image.
File: graphics,  Node: Blockit,  Up: (graphics)User Programs
Date: Fri Jan 21 23:16 1983

BLOCKIT(UTAH-GR)        UNIX Programmer's Manual	    BLOCKIT(UTAH-GR)

NAME
	blockit - block the input data

SYNOPSIS
	blockit [blocksize [fillvalue]] [file ...]

DESCRIPTION
	Take input from stdin and write it out in blocks of a given
	size.  A default fill value for the last block may be given.
 
	Options are:
	
	blocksize
		given in terms of 512 byte blocks, maximum is 32.

	fillvalue
		an integer which will be used to fill out the last
		partial block.

BUGS

File: graphics,  Node: Falign,  Up: (graphics)User Programs
Date: Fri Jan 21 23:17 1983


FALIGN(UTAH-GR)	    UNIX Programmer's Manual		    FALIGN(UTAH-GR)

NAME
	falign - draws alignment bars on the frame buffer

SYNOPSIS
	falign

DESCRIPTION

	Used for aligning the monitor.

BUGS
File: graphics,  Node: FBCaption,  Up: (graphics)User Programs
Date: Fri Jan 21 23:18 1983


FBCAPTION(UTAH-GR)    UNIX Programmer's Manual	    FBCAPTION(UTAH-GR)

NAME
	fbcaption - put captions into the overlay planes of the fb

SYNOPSIS
	fbcaption [-c] [-d] [-x xpos] [-y ypos] caption

DESCRIPTION
	Options are:

	-c	clear the overlay planes first

	-d	double size chars (10x14 instead of 5x7)

	-x xpos
		specify xposition of lower left corner

	-y ypos
		specify yposition of lower left corner

	caption	
		the caption (usually in quotes if it has spaces in it)

	If the x position is not specified, the string is centered.
	If the y position is not specified, the string is put at the top
	of the screen.

BUGS
	The caption may not begin with a digit or a '-'.  This is an
	unfortunate scanargs restriction.

File: graphics,  Node: Fbclr,  Up: (graphics)User Programs
Date: Fri Jan 21 23:19 1983


FBCLR(UTAH-GR)	    UNIX Programmer's Manual		    FBCLR(UTAH-GR)

NAME
	fbclr - clear frame buffer

SYNOPSIS
	fbclr [-c r g b ] [-v value ] [channel]

DESCRIPTION
	The program clears the frame buffer.  Options allow clearing
	to various colors, or clearing only certain planes.
 
	Options are:
	
	-c r g b 
		clear to specified color.  r, g, and b are in the 
		range 0-256

	-v value
		clear all three (r,g,b) channels to value.  Value
		is also in range 0-256

	channel
		clear only channels specified by the channel mask.
		See general frame buffer documentation for more
		information on the channels (*note general::).

BUGS



File: graphics,  Node: FBTrn,  Up: (graphics)User Programs
Date: Fri Jan 21 23:22 1983


FBTRN(UTAH-GR)	    UNIX Programmer's Manual		    FBTRN(UTAH-GR)

NAME
	fbtrn - translate fb instructions to a human readable form

SYNOPSIS
	fbtrn [-o] [file]

DESCRIPTION
	Output goes to standard out.

	Options are:
	
	-o	???

	file	optional name of file for input

BUGS

File: graphics,  Node: Fbwedge,  Up: (graphics)User Programs
Date: Fri Jan 21 23:22 1983


FBWEDGE(UTAH-GR)          UNIX Programmer's Manual	    FBWEDGE(UTAH-GR)

NAME
	fbwedge - puts a density wedge on the frame buffer

SYNOPSIS
	fbwedge [textline]

DESCRIPTION
	This program is generally used for photo labs and studying
	the color response of the monitor.  The optional text 
	string will appear on the screen.  If it contains any spaces
	it should be enclosed in quotes.

BUGS

File: graphics,  Node: Getfb,  Up: (graphics)User Programs
Date: Fri Jan 21 23:22 1983


GETFB(UTAH-GR)	    UNIX Programmer's Manual		    GETFB(UTAH-GR)

NAME
	getfb - restores a file save with svfb

SYNOPSIS
	getfb [-BO] [-p x y] file

DESCRIPTION
	If the file was not created by svfb, getfb asks if it is ok to
	continue.  A 'y' or 'Y' answer will cause the file to be copied
	to the frame buffer anyway.

	Options are:

	-B	If the file was saved with -B or -O, restore the background
		color before restoring the image data.

	-O	If the file was saved with -B or -O, restore the image data in
		overlay mode.  Only areas of the original image which were not
		the background color are restored.  The rest of the image
		already in the frame buffer is undisturbed.

	-p x y	Reposition the image.  The original lower left corner is
		positioned at [x, y] before restoring the image.  A warning:
		A saved image should not be repositioned so that any saved data
		wraps around the X borders.  If the file was not saved with -B
		or -O, this includes background areas.

	file	Name of file to restore.

BUGS

File: graphics,  Node: GRabit,  Up: (graphics)User Programs
Date: Fri Jan 21 23:23 1983


GRABIT(UTAH-GR)	    UNIX Programmer's Manual		    GRABIT(UTAH-GR)

NAME
	grabit - use the frame grabber

SYNOPSIS
	grabit [-wbgr] [-osc] [nframes] [shift]

DESCRIPTION

	Options are:

	-wbgr	channels affected can be white(r, g, and b channels), 
		or just one of r, g, and b.  Default is all channels.

	-cso	mode can be continuous, single, or off

	nframes	0 - 255

	shift	0 - 11

BUGS

File: graphics,  Node: Shapedit,  Up: (graphics)User Programs
Date: Fri Jan 21 23:24 1983

Sorry, no information available on shapedit.
File: graphics,  Node: SVfb,  Up: (graphics)User Programs
Date: Fri Jan 21 23:24 1983


SVFB(UTAH-GR)	    UNIX Programmer's Manual		    SVFB(UTAH-GR)

NAME
	svfb - save a region of the fb to a file

SYNOPSIS
	svfb [-b] [-SBO] [-m] [-c red green blue] [xmin xmax ymin ymax] [file]

DESCRIPTION
	Save the region [xmin,xmax] x [ymin,ymax] into the file.
	The file may be copied to the frame buffer and the region will
	end up based at the origin, or the program getfb may be run
	to position it at an arbitrary location.
 	
	The program attempts to compress flat-colored areas as
	much as possible.  This means that it is reasonable to
	save the entire screen, since it will not take up much more
	file space than saving only the interesting portion of the
	image.	

	Options are:

	xmin ... ymax are optional bounds of the region to be saved.  If
		these are not given, and the -b flag is not given, the whole
		screen will be saved.

	-b	the user interactively positions a box around the area
		to be saved using the zoom cursor.  Mostly
		self-explanatory.  The magenta corner of the box must be the
		upper right corner, and the white corner must be the lower left
		corner.

	-m	causes the color map to be saved as well as the image.

	-O	"Overlay mode".  Only non-background pixels are saved /
		restored.  Background is the color under the lower left corner
		of the save box, or it may be specified with the -c option.

	-B	Save the background by causing the screen to be cleared to the
		background color when the file is restored, then restore the
		image in overlay mode.

	The -B and -O options may be reversed retroactively by the
	getfb program.

	-c red green blue
		Specify the background color for -B or -O mode saves.

	-S 	causes the image to be saved as a straight box, with no special
		background processing.  Only the portion of the screen which is
		saved will be affected when the image is restored.

	file	Optional output file.  If not specified, stdout is used.

BUGS
File: graphics,  Node: User Programs,  Up: (graphics)Top
Date: Fri Jan 21 23:25 1983,		Next: Frame Buffer

* menu:
* Blockit::		Block the input.
* Colors::		Interactive selection of RGB color values.
* Domap::		Set up frame buffer color map.
* Falign::		Put up alignment bars on frame buffer.
* FBCaption::		Add captions to frame buffer images.
* CLear:Fbclr:		Clear frame buffer.
* FBTrn::		Translate frame buffer instructions for humans.
* Wedge:Fbwedge:	Display wedge of intensities.
* Getfb::		Restore frame buffer image from disk file.
* GRabit::		Frame grabber.
* Ldmap::		Load color map on frame buffer.
* LOgmap::		Load logarithmic scale color map on frame buffer.
* Paint::		Interactive painting on frame buffer.
* Shapedit::		PSL (lisp) system with geometry loaded.
* SVfb::		Save frame buffer image into disk file.
* Tcolors::		Interactive selection of transparency colors & values.
* Zoom:Zoom-pgm:	Interactive zooming and panning of frame buffer image.
File: graphics,  Node: Zoom-pgm,  Up: (graphics)User Programs
Date: Fri Jan 21 23:25 1983


ZOOM(UTAH-GR)	    UNIX Programmer's Manual		    ZOOM(UTAH-GR)

NAME
	zoom - interactive zoom and pan on the frame buffer

SYNOPSIS
	zoom [-c] [-p] [-C] [power]

DESCRIPTION
	The image on the frame buffer is continuously zoomed and panned
	using frame buffer hardware.  Interactive control is via the
	tablet.
 
	Options are:
	
	-c	[color] A cross-hair cursor is displayed and the RGB
		value of the pixel under the cursor is continuously
		updated and displayed in the overlay planes.

	-p	[position] A cross-hair cursor is displayed and the
		xy-coordinate value of the pixel under the cursor is
		continuously updated and displayed in the overlay planes.

	-C	[cursor] Just the cross-hair cursor is displayed.  Without
		any of these first three flags, there is no cursor.

	power	Power of the zoom.  May be 1, 2, 4, or 8.  Default if 
		nothing is specified is 4.

BUGS

File: graphics,  Node: Colors,  Up: (graphics)User Programs
Date: Sat Jan 22 01:03 1983


COLORS(UTAH-GR)	    UNIX Programmer's Manual		    COLORS(UTAH-GR)

NAME
	colors - interactive color selection

SYNOPSIS
	colors

DESCRIPTION
	The colors program allows interactive selection of colors using
	the frame buffer.  Interaction is via the tablet.

	The screen contains six vertical bars in the center.  The three
	on the left are for adjusting the range of values in RGB (red,
	green, blue) space, and the three on the right are for adjusting
	HSV (hue, saturation, value).  Obviously the two sets of bars 
	not independent, and adjustment in one set will cause changes
	to occur in the displayed values on the other set of bars.  The
	gray-outlined square on the right side of the screen is continuously
	updated with the currently selected color value (usually called the
	cue box).  Selecting the cue box will cause the current RGB values
	to be printed to the standard output (normally the terminal).  
	The large white box in the lower right portion of the screen
	is the quit box.

	This program is generally used to select "pleasing" colors for
	various graphics applications, since choosing values for RGB
	without a display tends to be very non-intuitive.

BUGS

File: graphics,  Node: Tcolors,  Up: (graphics)User Programs
Date: Sat Jan 22 01:04 1983

TCOLORS(UTAH-GR)        UNIX Programmer's Manual  	    TCOLORS(UTAH-GR)

NAME
	tcolors - interactive program to play with transparent colors

SYNOPSIS
	tcolors

DESCRIPTION
	The tcolors program allows interactive adjustment of both color and
	transparency values, with a special transparency display to show how
	the various colors interact as transparent sheets.  The program
	was developed because selection of rgb and transparency values which
	work well together is at least on order of magnitude more difficult
	than pulling rgb values the look good together out of thin air!

	The center of the screen looks like the colors program and behaves 
	similarly. (See *note colors::).

	The left side of the screen is the transparency display. It contains
	a background area with four overlapping transparent sheets.  This is
	the main area of interest for examining the effects of transparency.

	The five boxes on the lower part of the screen correspond to the
	four transparent sheets, with the leftmost one corresponding to
	the farthest-away sheet.  The far right box corresponds to the 
	background.  All five boxes indicate the current "pure" color
	of the corresponding sheet or background.  That is, the color of
	these boxes is not affected by transparency adjustments.  

	The boxes are used to adjust the transparency values of the sheets
	in the transparency display.  Tablet picks inside one of the boxes
	will change the transparency value, resulting in an update of
	the transparency display.  The current transparency value in
	each box is displayed by a vertical gray bar in the box.  When
	the bar is all the way to the right, the sheet will be opaque;
	when all the way to the left, it will be totally transparent.
	The initial value is for all of the sheets is to be opaque.  The
	background is always opaque, and hence does not have a transparency
	adjustment.

	The gray-outlined box on the right side of the screen is the
	cue box, as in the colors program.

	There is a menu in the upper right corner of the screen with
	buttons as follows:

	quit	exit the program
	
	select box
		the next selected box becomes the "current" box, and 
		its color becomes the "current" color.  Adjustments
		in the color bars will affect the "current" box, and 
		the corresponding sheet in the transparency display, as
		well as the cue box.

	set box
		the next selected box is set to the "current" color 
		(as shown in the cue box) and the transparency display
		is updated accordingly.

	print box
		prints the rgb and transparency values of the next 
		selected box.


BUGS
	Not really a bug, but since the transparency values start at
	fully opaque, it's hard to see the indicator bars in the 
	boxes.  You have to know that they're there, and what it is
	that they do.

File: graphics,  Node: Paint,  Up: (graphics)User Programs
Date: Sat Jan 22 01:04 1983


PAINT(UTAH-GR)	    UNIX Programmer's Manual		    PAINT(UTAH-GR)

NAME
	paint - interactive program for painting on the frame buffer

SYNOPSIS
	paint

DESCRIPTION
	The paint program allows interactive picture drawing using
	the frame buffer and tablet.

	The screen is divided into two areas: the painting area which
	fills the entire screen most of the time, and the menu area
	which is a narrow band at the top of the screen.  When painting
	in the lower area, the menu scrolls up and disappears.  As the
	pen is moved toward the top of the screen the menu will reappear
	for selection.  When the program is exited, the menu is scrolled
	one final time so that only the painted image remains on the
	display.

	The menu area is divided into several distinct sections, each
	of which is described below, beginning at the left side of the
	screen.

	palette	
		the palette is the rainbow area together with the 
		shades of gray next to it.  Tablet picks in this
		area cause a new "current" color to be selected,
		corresponding to the value of the pixel under the
		cursor.

	cue box
		the white-outlined box next to the gray part of the
		palette is the cue box, which always displays the 
		currently selected color.  It is continuously updated
		as the pen is moved around in the palette area.

	color box
		is used to select colors from the painting area, since
		it is sometimes difficult to reselect the exact color
		from the pallette which has already been used in the
		painting.  When the color box is selected, it will change
		to black, indicating that the next pick made in the 
		painting area will change the "current" color, rather
		than perform a paint as usual.

	background box
		is used to set the color of the background.  This box 
		requires confirmation.  The first pick changes the 
		color of the background box to the "current" color.  The
		second pick causes the entire painting area to be cleared
		to the color shown.  Note that this is effectively the
		"erase" mechanism, so be careful using it.

	square/circle box
		is used to change the shape of the brush from square to
		circular.  It is a toggle, and the label in the box 
		indicates the current shape of the brush.

	brush size box
		is used to adjust the brush size.  The displayed figure
		shows the current brush size and shape.  Adjustment of 
		the brush size is done by picking in this box.  A rectangular
		brush will make a rectangle with one corner at the cursor.
		(This is well defined, since the rectangle is always 
		centered in the brush size box).  The circular brush will
		make a circle with perimeter touching the cursor point.

	quit box
		exits the program.  Requires confirmation.  If you hit it
		accidentally, just do something else for the next pick and
		processing will proceed normally.
	
BUGS
	Only way to get any reasonable amount of interaction is to
	eat the entire machine.
	Color box is not friendly because it disappears off the screen
	for the second step of the action.  It is often hard to tell
	if you got the pick or not.

	It is possible to get the circular brush too big, which messes up
	the menu and a small portion of the painting area.
File: graphics,  Node: Domap,  Up: (graphics)User Programs
Date: Sat Jan 22 01:06 1983

		No information on domap yet.
File: graphics,  Node: Ldmap,  Up: (graphics)User Programs
Date: Sat Jan 22 01:06 1983

		No information on ldmap yet.
File: graphics,  Node: LOgmap,  Up: (graphics)User Programs
Date: Sat Jan 22 01:07 1983

		No information on logmap yet.
File: graphics,  Node: Blockit,  Up: (graphics)User Programs
Date: Sat Jan 22 01:07 1983,	Next: colors

BLOCKIT(UTAH-GR)        UNIX Programmer's Manual	    BLOCKIT(UTAH-GR)

NAME
	blockit - block the input data

SYNOPSIS
	blockit [blocksize [fillvalue]] [file ...]

DESCRIPTION
	Take input from stdin and write it out in blocks of a given
	size.  A default fill value for the last block may be given.
 
	Options are:
	
	blocksize
		given in terms of 512 byte blocks, maximum is 32.

	fillvalue
		an integer which will be used to fill out the last
		partial block.

BUGS

File: graphics,  Node: Colors,  Up: (graphics)User Programs
Date: Sat Jan 22 01:07 1983,	Prev: blockit, Next: domap


COLORS(UTAH-GR)	    UNIX Programmer's Manual		    COLORS(UTAH-GR)

NAME
	colors - interactive color selection

SYNOPSIS
	colors

DESCRIPTION
	The colors program allows interactive selection of colors using
	the frame buffer.  Interaction is via the tablet.

	The screen contains six vertical bars in the center.  The three
	on the left are for adjusting the range of values in RGB (red,
	green, blue) space, and the three on the right are for adjusting
	HSV (hue, saturation, value).  Obviously the two sets of bars 
	not independent, and adjustment in one set will cause changes
	to occur in the displayed values on the other set of bars.  The
	gray-outlined square on the right side of the screen is continuously
	updated with the currently selected color value (usually called the
	cue box).  Selecting the cue box will cause the current RGB values
	to be printed to the standard output (normally the terminal).  
	The large white box in the lower right portion of the screen
	is the quit box.

	This program is generally used to select "pleasing" colors for
	various graphics applications, since choosing values for RGB
	without a display tends to be very non-intuitive.

BUGS

File: graphics,  Node: Domap,  Up: (graphics)User Programs
Date: Sat Jan 22 01:08 1983,	Prev: colors, Next: falign

		No information on domap yet.
File: graphics,  Node: Falign,  Up: (graphics)User Programs
Date: Sat Jan 22 01:08 1983,	Prev: domap, Next: fbcaption


FALIGN(UTAH-GR)	    UNIX Programmer's Manual		    FALIGN(UTAH-GR)

NAME
	falign - draws alignment bars on the frame buffer

SYNOPSIS
	falign

DESCRIPTION

	Used for aligning the monitor.

BUGS
File: graphics,  Node: FBCaption,  Up: (graphics)User Programs
Date: Sat Jan 22 01:08 1983,	Prev: falign, Next: fbclr


FBCAPTION(UTAH-GR)    UNIX Programmer's Manual	    FBCAPTION(UTAH-GR)

NAME
	fbcaption - put captions into the overlay planes of the fb

SYNOPSIS
	fbcaption [-c] [-d] [-x xpos] [-y ypos] caption

DESCRIPTION
	Options are:

	-c	clear the overlay planes first

	-d	double size chars (10x14 instead of 5x7)

	-x xpos
		specify xposition of lower left corner

	-y ypos
		specify yposition of lower left corner

	caption	
		the caption (usually in quotes if it has spaces in it)

	If the x position is not specified, the string is centered.
	If the y position is not specified, the string is put at the top
	of the screen.

BUGS
	The caption may not begin with a digit or a '-'.  This is an
	unfortunate scanargs restriction.

File: graphics,  Node: Fbclr,  Up: (graphics)User Programs
Date: Sat Jan 22 01:10 1983,	Prev: fbcaption, Next: fbtrn


FBCLR(UTAH-GR)	    UNIX Programmer's Manual		    FBCLR(UTAH-GR)

NAME
	fbclr - clear frame buffer

SYNOPSIS
	fbclr [-c r g b ] [-v value ] [channel]

DESCRIPTION
	The program clears the frame buffer.  Options allow clearing
	to various colors, or clearing only certain planes.
 
	Options are:
	
	-c r g b 
		clear to specified color.  r, g, and b are in the 
		range 0-256

	-v value
		clear all three (r,g,b) channels to value.  Value
		is also in range 0-256

	channel
		clear only channels specified by the channel mask.
		See general frame buffer documentation for more
		information on the channels (*note general::).

BUGS




File: graphics,  Node: FBTrn,  Up: (graphics)User Programs
Date: Sat Jan 22 01:10 1983,	Prev: fbclr, Next: fbwedge


FBTRN(UTAH-GR)	    UNIX Programmer's Manual		    FBTRN(UTAH-GR)

NAME
	fbtrn - translate fb instructions to a human readable form

SYNOPSIS
	fbtrn [-o] [file]

DESCRIPTION
	Output goes to standard out.

	Options are:
	
	-o	???

	file	optional name of file for input

BUGS

File: graphics,  Node: Fbwedge,  Up: (graphics)User Programs
Date: Sat Jan 22 01:10 1983,	Prev: fbtrn, Next: getfb


FBWEDGE(UTAH-GR)          UNIX Programmer's Manual	    FBWEDGE(UTAH-GR)

NAME
	fbwedge - puts a density wedge on the frame buffer

SYNOPSIS
	fbwedge [textline]

DESCRIPTION
	This program is generally used for photo labs and studying
	the color response of the monitor.  The optional text 
	string will appear on the screen.  If it contains any spaces
	it should be enclosed in quotes.

BUGS

File: graphics,  Node: Getfb,  Up: (graphics)User Programs
Date: Sat Jan 22 01:11 1983,	Prev: fbwedge, Next: grabit


GETFB(UTAH-GR)	    UNIX Programmer's Manual		    GETFB(UTAH-GR)

NAME
	getfb - restores a file save with svfb

SYNOPSIS
	getfb [-BO] [-p x y] file

DESCRIPTION
	If the file was not created by svfb, getfb asks if it is ok to
	continue.  A 'y' or 'Y' answer will cause the file to be copied
	to the frame buffer anyway.

	Options are:

	-B	If the file was saved with -B or -O, restore the background
		color before restoring the image data.

	-O	If the file was saved with -B or -O, restore the image data in
		overlay mode.  Only areas of the original image which were not
		the background color are restored.  The rest of the image
		already in the frame buffer is undisturbed.

	-p x y	Reposition the image.  The original lower left corner is
		positioned at [x, y] before restoring the image.  A warning:
		A saved image should not be repositioned so that any saved data
		wraps around the X borders.  If the file was not saved with -B
		or -O, this includes background areas.

	file	Name of file to restore.

BUGS

File: graphics,  Node: GRabit,  Up: (graphics)User Programs
Date: Sat Jan 22 01:11 1983,	Prev: getfb, Next: ldmap


GRABIT(UTAH-GR)	    UNIX Programmer's Manual		    GRABIT(UTAH-GR)

NAME
	grabit - use the frame grabber

SYNOPSIS
	grabit [-wbgr] [-osc] [nframes] [shift]

DESCRIPTION

	Options are:

	-wbgr	channels affected can be white(r, g, and b channels), 
		or just one of r, g, and b.  Default is all channels.

	-cso	mode can be continuous, single, or off

	nframes	0 - 255

	shift	0 - 11

BUGS

File: graphics,  Node: Ldmap,  Up: (graphics)User Programs
Date: Sat Jan 22 01:11 1983,	Prev: grabit, Next: logmap

		No information on ldmap yet.
File: graphics,  Node: LOgmap,  Up: (graphics)User Programs
Date: Sat Jan 22 01:11 1983,	Prev: ldmap, Next: paint

		No information on logmap yet.
File: graphics,  Node: Paint,  Up: (graphics)User Programs
Date: Sat Jan 22 01:12 1983,	Prev: logmap, Next: shapedit


PAINT(UTAH-GR)	    UNIX Programmer's Manual		    PAINT(UTAH-GR)

NAME
	paint - interactive program for painting on the frame buffer

SYNOPSIS
	paint

DESCRIPTION
	The paint program allows interactive picture drawing using
	the frame buffer and tablet.

	The screen is divided into two areas: the painting area which
	fills the entire screen most of the time, and the menu area
	which is a narrow band at the top of the screen.  When painting
	in the lower area, the menu scrolls up and disappears.  As the
	pen is moved toward the top of the screen the menu will reappear
	for selection.  When the program is exited, the menu is scrolled
	one final time so that only the painted image remains on the
	display.

	The menu area is divided into several distinct sections, each
	of which is described below, beginning at the left side of the
	screen.

	palette	
		the palette is the rainbow area together with the 
		shades of gray next to it.  Tablet picks in this
		area cause a new "current" color to be selected,
		corresponding to the value of the pixel under the
		cursor.

	cue box
		the white-outlined box next to the gray part of the
		palette is the cue box, which always displays the 
		currently selected color.  It is continuously updated
		as the pen is moved around in the palette area.

	color box
		is used to select colors from the painting area, since
		it is sometimes difficult to reselect the exact color
		from the pallette which has already been used in the
		painting.  When the color box is selected, it will change
		to black, indicating that the next pick made in the 
		painting area will change the "current" color, rather
		than perform a paint as usual.

	background box
		is used to set the color of the background.  This box 
		requires confirmation.  The first pick changes the 
		color of the background box to the "current" color.  The
		second pick causes the entire painting area to be cleared
		to the color shown.  Note that this is effectively the
		"erase" mechanism, so be careful using it.

	square/circle box
		is used to change the shape of the brush from square to
		circular.  It is a toggle, and the label in the box 
		indicates the current shape of the brush.

	brush size box
		is used to adjust the brush size.  The displayed figure
		shows the current brush size and shape.  Adjustment of 
		the brush size is done by picking in this box.  A rectangular
		brush will make a rectangle with one corner at the cursor.
		(This is well defined, since the rectangle is always 
		centered in the brush size box).  The circular brush will
		make a circle with perimeter touching the cursor point.

	quit box
		exits the program.  Requires confirmation.  If you hit it
		accidentally, just do something else for the next pick and
		processing will proceed normally.
	
BUGS
	Only way to get any reasonable amount of interaction is to
	eat the entire machine.
	Color box is not friendly because it disappears off the screen
	for the second step of the action.  It is often hard to tell
	if you got the pick or not.

	It is possible to get the circular brush too big, which messes up
	the menu and a small portion of the painting area.
File: graphics,  Node: Shapedit,  Up: (graphics)User Programs
Date: Sat Jan 22 01:12 1983,	Prev: paint, Next: svfb

Sorry, no information available on shapedit.
File: graphics,  Node: SVfb,  Up: (graphics)User Programs
Date: Sat Jan 22 01:12 1983,	Prev: shapedit, Next: tcolors


SVFB(UTAH-GR)	    UNIX Programmer's Manual		    SVFB(UTAH-GR)

NAME
	svfb - save a region of the fb to a file

SYNOPSIS
	svfb [-b] [-SBO] [-m] [-c red green blue] [xmin xmax ymin ymax] [file]

DESCRIPTION
	Save the region [xmin,xmax] x [ymin,ymax] into the file.
	The file may be copied to the frame buffer and the region will
	end up based at the origin, or the program getfb may be run
	to position it at an arbitrary location.
 	
	The program attempts to compress flat-colored areas as
	much as possible.  This means that it is reasonable to
	save the entire screen, since it will not take up much more
	file space than saving only the interesting portion of the
	image.	

	Options are:

	xmin ... ymax are optional bounds of the region to be saved.  If
		these are not given, and the -b flag is not given, the whole
		screen will be saved.

	-b	the user interactively positions a box around the area
		to be saved using the zoom cursor.  Mostly
		self-explanatory.  The magenta corner of the box must be the
		upper right corner, and the white corner must be the lower left
		corner.

	-m	causes the color map to be saved as well as the image.

	-O	"Overlay mode".  Only non-background pixels are saved /
		restored.  Background is the color under the lower left corner
		of the save box, or it may be specified with the -c option.

	-B	Save the background by causing the screen to be cleared to the
		background color when the file is restored, then restore the
		image in overlay mode.

	The -B and -O options may be reversed retroactively by the
	getfb program.

	-c red green blue
		Specify the background color for -B or -O mode saves.

	-S 	causes the image to be saved as a straight box, with no special
		background processing.  Only the portion of the screen which is
		saved will be affected when the image is restored.

	file	Optional output file.  If not specified, stdout is used.

BUGS
File: graphics,  Node: Tcolors,  Up: (graphics)User Programs
Date: Sat Jan 22 01:13 1983,	Prev: svfb, Next: zoom

TCOLORS(UTAH-GR)        UNIX Programmer's Manual  	    TCOLORS(UTAH-GR)

NAME
	tcolors - interactive program to play with transparent colors

SYNOPSIS
	tcolors

DESCRIPTION
	The tcolors program allows interactive adjustment of both color and
	transparency values, with a special transparency display to show how
	the various colors interact as transparent sheets.  The program
	was developed because selection of rgb and transparency values which
	work well together is at least on order of magnitude more difficult
	than pulling rgb values the look good together out of thin air!

	The center of the screen looks like the colors program and behaves 
	similarly. (See *note colors::).

	The left side of the screen is the transparency display. It contains
	a background area with four overlapping transparent sheets.  This is
	the main area of interest for examining the effects of transparency.

	The five boxes on the lower part of the screen correspond to the
	four transparent sheets, with the leftmost one corresponding to
	the farthest-away sheet.  The far right box corresponds to the 
	background.  All five boxes indicate the current "pure" color
	of the corresponding sheet or background.  That is, the color of
	these boxes is not affected by transparency adjustments.  

	The boxes are used to adjust the transparency values of the sheets
	in the transparency display.  Tablet picks inside one of the boxes
	will change the transparency value, resulting in an update of
	the transparency display.  The current transparency value in
	each box is displayed by a vertical gray bar in the box.  When
	the bar is all the way to the right, the sheet will be opaque;
	when all the way to the left, it will be totally transparent.
	The initial value is for all of the sheets is to be opaque.  The
	background is always opaque, and hence does not have a transparency
	adjustment.

	The gray-outlined box on the right side of the screen is the
	cue box, as in the colors program.

	There is a menu in the upper right corner of the screen with
	buttons as follows:

	quit	exit the program
	
	select box
		the next selected box becomes the "current" box, and 
		its color becomes the "current" color.  Adjustments
		in the color bars will affect the "current" box, and 
		the corresponding sheet in the transparency display, as
		well as the cue box.

	set box
		the next selected box is set to the "current" color 
		(as shown in the cue box) and the transparency display
		is updated accordingly.

	print box
		prints the rgb and transparency values of the next 
		selected box.


BUGS
	Not really a bug, but since the transparency values start at
	fully opaque, it's hard to see the indicator bars in the 
	boxes.  You have to know that they're there, and what it is
	that they do.

File: graphics,  Node: Tcolors,  Up: (graphics)User Programs
Date: Thu Feb 24 16:00 1983,	Prev: svfb, Next: tslide

TCOLORS(UTAH-GR)        UNIX Programmer's Manual  	    TCOLORS(UTAH-GR)

NAME
	tcolors - interactive program to play with transparent colors

SYNOPSIS
	tcolors

DESCRIPTION
	The tcolors program allows interactive adjustment of both color and
	transparency values, with a special transparency display to show how
	the various colors interact as transparent sheets.  The program
	was developed because selection of rgb and transparency values which
	work well together is at least on order of magnitude more difficult
	than pulling rgb values the look good together out of thin air!

	The center of the screen looks like the colors program and behaves 
	similarly. (See *note colors::).

	The left side of the screen is the transparency display. It contains
	a background area with four overlapping transparent sheets.  This is
	the main area of interest for examining the effects of transparency.

	The five boxes on the lower part of the screen correspond to the
	four transparent sheets, with the leftmost one corresponding to
	the farthest-away sheet.  The far right box corresponds to the 
	background.  All five boxes indicate the current "pure" color
	of the corresponding sheet or background.  That is, the color of
	these boxes is not affected by transparency adjustments.  

	The boxes are used to adjust the transparency values of the sheets
	in the transparency display.  Tablet picks inside one of the boxes
	will change the transparency value, resulting in an update of
	the transparency display.  The current transparency value in
	each box is displayed by a vertical gray bar in the box.  When
	the bar is all the way to the right, the sheet will be opaque;
	when all the way to the left, it will be totally transparent.
	The initial value is for all of the sheets is to be opaque.  The
	background is always opaque, and hence does not have a transparency
	adjustment.

	The gray-outlined box on the right side of the screen is the
	cue box, as in the colors program.

	There is a menu in the upper right corner of the screen with
	buttons as follows:

	quit	exit the program
	
	select box
		the next selected box becomes the "current" box, and 
		its color becomes the "current" color.  Adjustments
		in the color bars will affect the "current" box, and 
		the corresponding sheet in the transparency display, as
		well as the cue box.

	set box
		the next selected box is set to the "current" color 
		(as shown in the cue box) and the transparency display
		is updated accordingly.

	print box
		prints the rgb and transparency values of the next 
		selected box.


BUGS
	Not really a bug, but since the transparency values start at
	fully opaque, it's hard to see the indicator bars in the 
	boxes.  You have to know that they're there, and what it is
	that they do.



File: graphics,  Node: Zoom-pgm,  Up: (graphics)User Programs
Date: Thu Feb 24 16:01 1983,	Prev: tslide


ZOOM(UTAH-GR)	    UNIX Programmer's Manual		    ZOOM(UTAH-GR)

NAME
	zoom - interactive zoom and pan on the frame buffer

SYNOPSIS
	zoom [-c] [-p] [-C] [power]

DESCRIPTION
	The image on the frame buffer is continuously zoomed and panned
	using frame buffer hardware.  Interactive control is via the
	tablet.
 
	Options are:
	
	-c	[color] A cross-hair cursor is displayed and the RGB
		value of the pixel under the cursor is continuously
		updated and displayed in the overlay planes.

	-p	[position] A cross-hair cursor is displayed and the
		xy-coordinate value of the pixel under the cursor is
		continuously updated and displayed in the overlay planes.

	-C	[cursor] Just the cross-hair cursor is displayed.  Without
		any of these first three flags, there is no cursor.

	power	Power of the zoom.  May be 1, 2, 4, or 8.  Default if 
		nothing is specified is 4.

BUGS


File: graphics,  Node: Domap,  Up: (graphics)User Programs
Date: Sat Jan 22 13:22 1983,	Prev: colors, Next: falign


DOMAP(UTAH-GR)	    UNIX Programmer's Manual		    DOMAP(UTAH-GR)

NAME
	domap - reads a color map and sets up the map

SYNOPSIS
	domap file

DESCRIPTION
	Domap loads the color map with the values specified
	in the file.  For programs that load standard maps see
	the *note logmap:: and *note ldmap:: programs.

BUGS

File: graphics,  Node: Ldmap,  Up: (graphics)User Programs
Date: Thu Feb 24 15:58 1983,	Prev: gslide, Next: logmap


LDMAP(UTAH-GR)	    UNIX Programmer's Manual		    LDMAP(UTAH-GR)

NAME
	ldmap - loads arbitrary color maps into the frame buffer

SYNOPSIS
	ldmap

DESCRIPTION
	This program does not disturb the contents of frame buffer, but
	allows different color maps to be loaded.  The program queries
	the user to determine actions, rather than reading flags.

	The following responses are meaningful:

	l	linear map.  A one-to-one identity map (no map in essence).

	p	perceptual map.   The default map loaded by Fbinit. 
		Hopefully this is a close aproximation to the current gamma
		correction maps.

	g	gamma map.  Looks for a standard map file in some obscure
		directory, the file is called lut_std.  This is all obvious
		in the function rd_std.c, and can be changed easily.  This
		is useful when Fbinit map is not correct.

	f	file.  Allows loading map from arbitrary disk file(s) that
		you create.

	Options under the file response are:

	m 	multiple.  Will query for three separate filenames, one for
		each of Red Green and Blue.  Format is ascii text file, where
		each value represents the color map contents.  File will
		be loaded into map in exact order as it is.

	s 	single.  Expects a single file containing the catenation of
		three map files in the order Red_map,Green_map,Blue_map. Can
		be created by shell command "cat rmap gmap bmap >map", where
		rmap,gmap, and bmap are standard map files as above.

BUGS

File: graphics,  Node: LOgmap,  Up: (graphics)User Programs
Date: Sat Jan 22 13:22 1983,	Prev: ldmap, Next: paint


LOGMAP(UTAH-GR)	    UNIX Programmer's Manual		    LOGMAP(UTAH-GR)

NAME
	logmap - load color map with logarithmic values

SYNOPSIS
	logmap

DESCRIPTION
	Logmap is actually not a program, but a shell script.  
	All it does is invoke domap (see *note domap::) on
	a standard file to produce a commonly used color map.

BUGS

File: graphics,  Node: User Programs,  Up: (graphics)Top
Date: Thu Feb 24 15:53 1983,		Next: Frame Buffer

* menu:
* Blockit::		Block the input.
* Colors::		Interactive selection of RGB color values.
* Domap::		Set up frame buffer color map.
* Falign::		Put up alignment bars on frame buffer.
* FBCaption::		Add captions to frame buffer images.
* CLear:Fbclr:		Clear frame buffer.
* FBTrn::		Translate frame buffer instructions for humans.
* Wedge:Fbwedge:	Display wedge of intensities.
* FOntcaption::         Add filtered captions to frame buffer images.
* Getfb::		Restore frame buffer image from disk file.
* GRabit::		Frame grabber.
* GSlide::		Graphics for slide presentations.
* Ldmap::		Load color map on frame buffer.
* LOgmap::		Load logarithmic scale color map on frame buffer.
* Paint::		Interactive painting on frame buffer.
* Shapedit::		PSL (lisp) system with geometry loaded.
* SVfb::		Save frame buffer image into disk file.
* Tcolors::		Interactive selection of transparency colors & values.
* TSlide::		Text editting for slide presentations.
* Zoom:Zoom-pgm:	Interactive zooming and panning of frame buffer image.
File: graphics,  Node: Fbwedge,  Up: (graphics)User Programs
Date: Thu Feb 24 15:54 1983,	Prev: fbtrn, Next: fontcaption


FBWEDGE(UTAH-GR)          UNIX Programmer's Manual	    FBWEDGE(UTAH-GR)

NAME
	fbwedge - puts a density wedge on the frame buffer

SYNOPSIS
	fbwedge [textline]

DESCRIPTION
	This program is generally used for photo labs and studying
	the color response of the monitor.  The optional text 
	string will appear on the screen.  If it contains any spaces
	it should be enclosed in quotes.

BUGS

File: graphics,  Node: FOntcaption,  Up: (graphics)User Programs
Date: Thu Feb 24 15:56 1983,	     Prev: fbwedge, Next: getfb

FONTCAPTION(UTAH-GR)    UNIX Programmer's Manual	 FONTCAPTION(UTAH-GR)

NAME
	fontcaption - put filtered text captions on the frame buffer

SYNOPSIS
	fontcaption fontfile [-s string] [-x xpos] [-y ypos] 
	            [-b r g b] [-c r g b]

DESCRIPTION
	The fontcaption program is quite similar to fbcaption, except
        that the text is written directly into the frame buffer, and 
	the quality of the text is much improved through a filtering
	process.  Different fonts are available.  This program is
	intended for quick one-line additions to images.  For creating
	entire screens full of text there are two possibilities.  One
	is to use this program in connection with a set of aliases 
	and variables currently contained in 
	    /usr/src/local/graphics/font.cmds
	The better alternative is to use the tslide program described
	elsewhere.  The tslide program has an interactive mode which
	is much friendlier.

	Options are:

	fontfile    	Name of font to be used.  This is a required
			argument and must be the name of a file
			containing a properly defined character font.
			The system fonts all reside on /usr/lib/vfont.

	[-s string ] 	The character string to be displayed.  If not
			specified, the program writes the word "test".
 	
	[-x xpos ]   	Left side of first character will begin at
			the specified x value.
 
	[-y ypos ]   	Bottom of character is at specified y value.

 	[-b r g b ] 	Set background color (for filtering against).

 	[-c r g b ]  	Set color of characters.

	If the x position is not specified, the string is centered.
	If the y position is not specified, the string is put at the top
	of the screen.

BUGS
	The caption may not begin with a digit or a '-'.  This is an
	unfortunate scanargs restriction.

File: graphics,  Node: Getfb,  Up: (graphics)User Programs
Date: Thu Feb 24 15:56 1983,	Prev: fontcaption, Next: grabit


GETFB(UTAH-GR)	    UNIX Programmer's Manual		    GETFB(UTAH-GR)

NAME
	getfb - restores a file save with svfb

SYNOPSIS
	getfb [-BO] [-p x y] file

DESCRIPTION
	If the file was not created by svfb, getfb asks if it is ok to
	continue.  A 'y' or 'Y' answer will cause the file to be copied
	to the frame buffer anyway.

	Options are:

	-B	If the file was saved with -B or -O, restore the background
		color before restoring the image data.

	-O	If the file was saved with -B or -O, restore the image data in
		overlay mode.  Only areas of the original image which were not
		the background color are restored.  The rest of the image
		already in the frame buffer is undisturbed.

	-p x y	Reposition the image.  The original lower left corner is
		positioned at [x, y] before restoring the image.  A warning:
		A saved image should not be repositioned so that any saved data
		wraps around the X borders.  If the file was not saved with -B
		or -O, this includes background areas.

	file	Name of file to restore.

BUGS

File: graphics,  Node: GSlide,  Up: (graphics)User Programs
Date: Thu Feb 24 15:57 1983,	Prev: grabit, Next: ldmap


			G S L I D E

>>> Introduction

The gslide program is an interactive program for costructing simple
graphical objects for slide presentations.  The program has no capability
for text.  The expected mode of operation for this program is as follows:

    Use the tslide (text slide generation) program to generate
    filtered text positioned on the screen as you like it.  

    Leave the image on the screen and run the gslide program to add
    the graphics you desire.  The gslide program operates completely
    in the overlay planes, so your image will be "underneath" while
    you add the graphics.

    When done, select the quit button (and confirm).  The program
    will prompt on your terminal for the name of an output file.
    The graphical objects you have created will be written to this
    file in (binary) Alpha_1 style format.  (It may be possible
    to photograph the slide at this point - if the matrix camera
    pays attention to overlays).

    Run the Alpha_1 rendering program to add the graphics to the
    image.  This may be done in two ways.  For non-filtered graphics,
    just render normally in OVERLAY mode with your text image on
    the screen.  For filtered graphics, run render with the 1K mode
    turned on.  This will produce a super-sampled image, which can
    then be filtered down (using the fltr1k command) and displayed
    on the screen.  Then redisplay your text on top of the graphics.

    Note that you really need to be a member of the Alpha_1 group
    in order to do the last several steps.

The next few sections describe briefly the action of the menu buttons
in the gslide program.  (Of course, the best way to figure out what it
does is to play with it.)

>>> Basic Objects

Four basic kinds of objects may be created: line segments, boxes,
open quadratic B-spline curves, and (possibly unclosed) polygons.
Creation of all of these objects features "rubberband" lines which
are updated continuously to show what the object would look like
if the next point chosen were the current cursor position.

Line segments position one endpoint at the first pick.  A second
pick completes the line.

Boxes have a similar interaction to the lines, except that the picks
determine two diagonal corners of the box.

Polygons are series of line segments.  Entering points is terminated
by selecting a menu button.  (The rubber band line will follow the
cursor into the menu area, but will disappear as soon as the menu
button is selected.)  If you want a closed polygon, you have to
reselect the first vertex.

Curves on the screen look EXACTLY like the polygons.  The difference
is that when they are output, the curve polygon is turned into the
control polygon for an open quadratic B-spline.  A good way to think
about what the final output will look like is just to think that the
spline will "round off" all the sharp corners in the polygon.  The
quadratic splines will come in tangent at the middle of each line
segment except the first and last.  Note that closing one of these
polygons may not do what you expect: you will still get a sharp corner
unless the first two and last two points are collinear.  (Obviously
the first and last must be the same point).  It does absolutely no
good to define curves instead of polygons if you aren't planning to
run render on the output of the program.

>>> Arrowheads

Arrowheads may be added to any line segment of any object you have
created, including curves (though it only makes sense to add them
to the end of a curve).  Creating an arrowhead involves two picks
of existing vertices to determine the direction of the arrow.  The
arrowhead will be located at the second pick pointing FROM the first
pick TO the second pick.  After the first pick a red x marks that
the pick was seen.  If the second pick doesn't hit an existing vertex,
no arrowhead is created and the red x is removed.

It is possible to adjust the shape and size of the arrowheads created.
The arrow menu button contains a line in the lower left corner which
shows the shape of (half) an arrowhead in the current shape.  Once arrow
mode is turned on, repicking the arrow menu button will cause the flared
part of the arrow to end at the current cursor position.  All arrows
created after this point will have the newly defined shape.

>>> Moving Objects

There are two types of movement of already created objects.  The
first is vertex movement.  Any vertex of any object may be repositioned
by selecting the move button, and then selecting the vertex.  The point
will be dragged along with the cursor until the next pick is made.  One
important thing to remember is that moving vertices does NOT preserve
the shape of boxes and arrows.  If you want to change the size of a box
or arrow, it is probably best to delete it (see below) and start over.

The second type of movement is for repositioning entire objects.  Once
the move ob button is selected, any vertex of the object may be picked
and the object will then follow the cursor (maintaining it's overall
shape) until the next pick is made.

>>> Deletion

The delete button allows entire objects to be deleted.  Picking any vertex
in the object to be deleted marks the object for deletion by displaying
it in red.  The next pick should be a vertex in the same object (usually
the same one of course) to confirm the deletion.  After confirmation, the
object will disappear.  Note that individual vertices cannot be deleted,
only entire objects.

>>> Gridding

In order to facilitate lining up of graphical objects, an invisible grid
is provided.  All picked values will be rounded to the nearest grid point.
The size of the grid is adjustable using the grid menu button.  After
selecting this button, you will be prompted at the terminal for the new
grid size.  An integer number is expected: 1 turns gridding off completely,
values up to about 10 are fairly easy to work with.  Changing the grid
size in the middle of the session may result in some minor problems in
handling positioning of objects.  In particular, in move vertex mode it may
not be possible to put a vertex back down exactly where you got it (this
is evident mostly in boxes).  Also, it may not be possible to line up a
new object (an arrowhead, for example) with an object that was defined with
a different grid size.  Both of these can be overcome by turning the grid
size off momentarily.

>>> Clear

It is occasionally useful to be able to clear out all the objects created
and start all over (as if restarting the program).  This is possible
using the clear button.  It required confirmation.

>>> Quitting

When you exit the program using the quit button (which also requires
confirmation), you will be prompted at the terminal for the name of
a file to write the created objects to.  Responding with just a carriage
return will bypass output and just quit the program.  This is appropriate
if you don't wish to save the objects, if you are shooting film directly
from the screen, or if you don't have access to the Alpha_1 rendering
programs and can't use the output anyway.

If you do name a file, and for some reason it cannot be opened for writing,
the quit will be aborted and you will remain in the program in a normal
state, so that the session is not lost.

Assuming the file is opened successfully, the objects will be written
in (binary) Alpha_1 object stream format for input to the rendering
program.  After output, the program erases the menu and cursor and exits.


File: graphics,  Node: GRabit,  Up: (graphics)User Programs
Date: Thu Feb 24 15:57 1983,	Prev: getfb, Next: gslide


GRABIT(UTAH-GR)	    UNIX Programmer's Manual		    GRABIT(UTAH-GR)

NAME
	grabit - use the frame grabber

SYNOPSIS
	grabit [-wbgr] [-osc] [nframes] [shift]

DESCRIPTION

	Options are:

	-wbgr	channels affected can be white(r, g, and b channels), 
		or just one of r, g, and b.  Default is all channels.

	-cso	mode can be continuous, single, or off

	nframes	0 - 255

	shift	0 - 11

BUGS

File: graphics,  Node: TSlide,  Up: (graphics)User Programs
Date: Thu Feb 24 16:00 1983,	Prev: tcolors, Next: zoom-pgm



			 T S L I D E

The tslide program is used for developing text slides for presentations.
The program displays filtered text on the frame buffer, and slides may
be shot directly from the frame buffer using the matrix camera.

Tslide accepts lines from standard input.  The format is vaguely
"scribe-ish" with command strings prefixed by an "@" character.  The
commands and their effect are described below.  All of the commands must
begin in the first column of the line.  If you wish to have a line of text
begin with the "@" character, use "@@" to get a single "@" in the output.
Blank lines in the input file are ignored.

The tslide program can be run in either "batch" mode or "interactive"
mode.  The "batch" mode is useful for restoring a previously defined
slide to the screen in filtering mode.  The "interactive" mode is useful
for creating a slide which may need previewing (for example, to check
that the lines fit on the screen using the chosen font).  Certain 
of the commands described below will only be interesting when using
the program interactively.

@comment
    A comment command line is ignored, just as a blank line is ignored.

@center
    All the following lines of text will be centered on the screen.  This
    may be disabled temporarily by the @position command (see below). Only
    one of @center, @left, and @right may be in effect at one time.

@left [integer value]
    All the following lines of text are left justified at the specified x
    position.  If no argument is given, the left margin defaults to some
    reasonable value.

@right [integer value]
    Just like left justify above, only justifies at right edge of screen.

@capson
    Turn on upper-casing of text strings.  All text displayed will be 
    converted to uppercase before display.

@capsoff
    Turn off upper-casing.  Text goes onto the screen as it appeared
    in the file.

@position xpos ypos
    Next text will begin at position (xpos, ypos).  This only applies
    to the next line of INPUT (i.e. it must be the last command before
    the text string it is intended to effect.  Centering, left and
    right justification are temporarily disabled.  Bad Side Effect:
    if left margin was on, it will resume at the x position given 
    for the position command.

@font string
    Change the current font to be the named font.  For now, this 
    must refer to a filename which contains an appropriately formatted
    font definition.  If the name begins with a '/' character, a full
    path name is assumed.  If not, the file is assumed to be on
    /usr/lib/vfont.  In either case, if the file cannot be opened, the
    font is not changed.

@blankline [float number]
    Generate blank space (i.e. move the current y position down the 
    screen).  Without an argument, one blank line is generated.  As
    some examples of arguments:
	0	no effect whatsoever
	1	same as no argument
	2	generate two blank lines
       -1	next line will end up at same y position as last line
       -2	next line will be above last line at normal spacing
       -3       next line will be above last line, with a blank line in
		between
    Fractional arguments are also legal.

@underlineon
    Turn on underlining.  Each line of text will be underlined until
    underlining is turned off.

@underlineoff
    Turn off underlining.

@linespacing float-value
    Set the linespacing.  The default is to leave a space half the
    max height of the current font between lines.  Setting the
    linespacing to 1 will leave exactly the max height of the current
    font between lines.   Linespacing of 0 will cause the lines to
    be practically on top of each other.  Negative and fractional 
    arguments are also legal. 

@linefeedon
    This is the default setting.  If on, each line of text rendered
    is automatically followed by a re-setting of the y value so that 
    the next line of text comes out in the right place.  See also
    @blankline and @linespacing.

@linefeedoff
    Turns off the automatic linefeed.  Note that this doesn't effect
    text already displayed.  If linefeed was on, the previous line 
    has already had the linefeed computed, even though you can't see
    it.  Likewise, when you turn off linefeed, you will either have
    to do it just before the last bit of text on the line, or else
    insert a blankline command to get the y positioning correct.  The
    position of the first text after an @linefeedoff command depends
    on the current justification mode, and isn't at all intuitive. It
    is probably best to do an @position if the current mode is not
    @left.  If left justifying, the first text will be left justified.
    All remaining text will follow immediately after the end of the
    previous input line, so you should be sure to include whatever 
    spaces are necessary.

@color red green blue
    Set the color of the text to be displayed.  The values should be
    integers in the range of 0-255.

@background red green blue
    Set the color of the background.  This color will be used to
    filter the characters against.  It is also used in the @clearscreen
    command below.  Arguments are as in the @color command.

@clearscreen
    Clears the screen to the current background color.  Also resets
    the current y position to be the usual default when the program
    starts up (somewhere "reasonable" near the top of the screen).

@pause
    This is useful for times when it may be convenient to specify
    several slides in the same input file.  The program is stopped,
    when it encounters this command, and can be resumed using the
    "c" command at the exec level.  Eventually we hope to add an
    @expose command which will expose a frame of film using the 
    matrix camera.  For now, this will have to be done by hand.  
    Nice side effect of using @pause is that you hang on to the
    frame buffer so no one can destroy your picture before you're
    done with it.

@preview
    Turn on previewing mode.  All text will be sub-sampled in the
    bit-mapped definitions.  Thin lines may end up lost, but this
    mode is a little faster if you just want to make sure things
    are in the right place.  For really fast previewing, use the
    flash mode (below).

@flash
    Turns on flash mode, which provides super-fast previewing by not
    really drawing the font characters.  It puts up a box outlining
    the limits of each character and a hardware character within the
    box.  This mode writes to the overlay planes and is thus independent
    of text already in the frame buffer.  The clearscreen and eraseline
    commands will only affect the overlay planes when flash mode is 
    enabled.

@filter
    Turns filtering mode back on (this is the default). There is a
    three state switch which is set with the preview, flash and 
    filter commands.

@eraseline
    For use when running the tslide program interactively.  The 
    current line is erased.  This command usually will need to be
    preceded by a blankline command with a negative argument to
    back up to the line you are interested in.

@cursoron
    Also for interactive use, the hardware blinking dot cursor is
    used to indicate where the next text will appear.  The cursor
    will appear at the correct y value.  The x position will be
    the center of the screen if centering is on, the right margin
    if right is on, and the left margin is left is on.  If you have
    just done a position command, it will show that position.

@cursoroff
    Turn off cursor display.

@tablet
    Also for interactive use, especially when trying to position text
    onto a graphical image.  The tablet command waits for a pen pick 
    from the tablet and prints the x and y coordinates of the pick
    in the form of a position command.  As a side effect, the tablet
    command acts as if a position command had actually been issued
    for the selected point.

@quit
    Also for interactive use, this command exits the program.  (When
    run non-interactively, the program quits as soon as it runs out
    of input.)

    
File: graphics,  Node: Display File,  Up: (graphics)Frame Buffer
Date: Fri Apr 29 17:31 1983,	      Prev: Zoom, Next: Grabber

The frame buffer software has the capability to build "display files".  A
display file is an array containing a list of frame buffer commands which
can be written to the frame buffer in one operation.  This capability can
tremendously speed up frame buffer updates, at the cost, of course, of
storage space.  A display file can grow quite rapidly.  For example, a
Fp3put will consume 10 words of array space and a Fr3put, about 14 words.
There is no way to put readback operations in a display file.  If a readback
operation is initiated during display file build, it will be immediately
executed, thus making it easy to build display files based on information
contained in the frame buffer.  (This is not strictly true, and the best
policy is not to do readback operations during display file generation.)
There are three routines which are used to build and display display files.

!<(
Fdstart(buffer, nbuf, full_sub)
fd_file buffer;
int nbuf;
int (*full_sub)();
		Initiates a display file.   All subsequent frame buffer
		calls will not affect the frame buffer, but instead will add
		frame buffer commands to the display file.

Args:		buffer: the "display file" will be built in this array.

		nbuf: the size of buffer in 16 bit words.  Nbuf - 8 of these
		will actually be used.

		full_sub: a subroutine to be called when the buffer fills up.

Notes:	      - buffer should be fairly large.

	      - the buffer format is
	    
!<	    /* TAG( fd_file )
	     * 
	     * Display file structure as used by Fdstart, Fddraw, etc.
	     */
	    
	    struct	fd_file	{
		    int	fd_len;		/* length used */
		    int	fd_abs_rel;	/* absolute/relative flag */
		    int	fd_x;		/* final x position */
		    int	fd_y;		/* final y position */
		    short	fd_list[];	/* actual display file */
	    };
	    
!>!<:
fd_len:		The number of (16-bit) words used for actual display
		list storage.

fd_abs_rel:	A flag which indicates whether any absolute mode
		instructions were generated.  It is zero if so, and non-zero
		if not.  It will be zero if absolute mode was entered at any
		time while generating the display file, even if no absolute
		mode commands were actually sent to the frame buffer.  This
		could cause base offset mode commands executed after drawing
		a display file to appear in the wrong place.

fd_x,fd_y:	The final (x,y) postion generated by the display file.  It
		is absolute if fd_abs_rel is zero and relative to the starting
		position if fd_abs_rel is non-zero.

fd_list:	The actual display list.  fd_len gives the number of words
		used.
!>

	      -	Full_sub is called in the form (*full_sub)(buffer),
		and is expected to empty or enlarge the buffer somehow.
		Only fd_len should be expected to be correct for a partial
		buffer.  If the buffer is enlarged, full_sub should call
		Fdrestart (see below) to tell the display file software
		about the new size.

	      -	If NULL is supplied as the full_sub, Fddraw will be called
		using buffer when buffer is full.  Thus, the display file
		software may be used to provide a layer of buffering between
		the user software and the frame buffer.  (At present, it is
		not recommended to do this in relative or base offset mode.)

	      -	There is no way to determine from the user program that the
		display file has overflowed except by checking the length in
		the first word.  (Of course if a full_sub is supplied, the
		fact that it has been called denotes that the buffer has
		overflowed.)
		

	      - It is recommended that no readback calls be made while
		building a display file.  They will not work properly and
		neither will the display file.

Fdrestart(buffer, nbuf, full_sub)
fd_file buffer;
int nbuf;
int (*full_sub)();
		This call is used to continue a display file which has been
		stopped by either a call to Fdstop or because it was filled
		up.  Buffer must have been previously supplied as an
		argument to Fdstart so that the header information is valid.
		Arguments are the same as for Fdstart.

Notes:	      - This subroutine may be called by the full_sub routine after
		realloc(3) has been called to enlarge the buffer.

Fdstop()
		Closes a display file, setting the values of words 1-3 of
		the display file buffer and restoring the software to its
		normal mode.  Subsequent frame buffer calls will be written
		to the frame buffer.

Fddraw(buffer)
fd_file * buffer;
		Draws the display file contained in buffer.

Args:		buffer: a display file built using Fdstart.
!>
File: graphics,  Node: Zoom-pgm,  Up: (graphics)User Programs
Date: Wed May  4 23:42 1983,	Prev: tslide


ZOOM(UTAH-GR)	    UNIX Programmer's Manual		    ZOOM(UTAH-GR)

NAME
	zoom - interactive zoom and pan on the frame buffer

SYNOPSIS
	zoom [-c] [-p] [-C] [power]

DESCRIPTION
	The image on the frame buffer is continuously zoomed and panned
	using frame buffer hardware.  Interactive control is via the
	tablet.  The tablet buttons have the following actions:
		Z (yellow) button: when depressed movement of the puck
			will drag the image on the screen.
		1 (white) button: when pressed divides the zoom factor
			by 2.  It wraps around from 1 to 8.
		3 (green) button: when pressed doubles the zoom factor.
		2 (blue) button:  when pressed, the program exits.
 
	Options are:
	
	-c	[color] A cross-hair cursor is displayed and the RGB
		value of the pixel under the cursor is continuously
		updated and displayed in the overlay planes.

	-p	[position] A cross-hair cursor is displayed and the
		xy-coordinate value of the pixel under the cursor is
		continuously updated and displayed in the overlay planes.

	-C	[cursor] Just the cross-hair cursor is displayed.  Without
		any of these first three flags, there is no cursor.

	power	Power of the zoom.  May be 1, 2, 4, or 8.  Default if 
		nothing is specified is 4.

BUGS

File: graphics,  Node: TSlide,  Up: (graphics)User Programs
Date: Mon May 16 09:27 1983,	Prev: tcolors, Next: zoom-pgm



			 T S L I D E

The tslide program is used for developing text slides for presentations.
The program displays filtered text on the frame buffer, and slides may
be shot directly from the frame buffer using the matrix camera.

Tslide accepts lines from standard input.  The format is vaguely
"scribe-ish" with command strings prefixed by an "@" character.  The
commands and their effect are described below.  All of the commands must
begin in the first column of the line.  If you wish to have a line of text
begin with the "@" character, use "@@" to get a single "@" in the output.
Blank lines in the input file are ignored.

The tslide program can be run in either "batch" mode or "interactive"
mode.  The "batch" mode is useful for restoring a previously defined
slide to the screen in filtering mode.  The "interactive" mode is useful
for creating a slide which may need previewing (for example, to check
that the lines fit on the screen using the chosen font).  Certain 
of the commands described below will only be interesting when using
the program interactively.

@comment
    A comment command line is ignored, just as a blank line is ignored.

@center
    All the following lines of text will be centered on the screen.  This
    may be disabled temporarily by the @position command (see below). Only
    one of @center, @left, and @right may be in effect at one time.

@left [integer value]
    All the following lines of text are left justified at the specified x
    position.  If no argument is given, the left margin defaults to some
    reasonable value.

@right [integer value]
    Just like left justify above, only justifies at right edge of screen.

@capson
    Turn on upper-casing of text strings.  All text displayed will be 
    converted to uppercase before display.

@capsoff
    Turn off upper-casing.  Text goes onto the screen as it appeared
    in the file.

@position xpos ypos
    Next text will begin at position (xpos, ypos).  This only applies
    to the next line of INPUT (i.e. it must be the last command before
    the text string it is intended to effect.  Centering, left and
    right justification are temporarily disabled.  Bad Side Effect:
    if left margin was on, it will resume at the x position given 
    for the position command.

@font string
    Change the current font to be the named font.  For now, this 
    must refer to a filename which contains an appropriately formatted
    font definition.  If the name begins with a '/' character, a full
    path name is assumed.  If not, the file is assumed to be on
    /usr/lib/vfont.  In either case, if the file cannot be opened, the
    font is not changed.

@blankline [float number]
    Generate blank space (i.e. move the current y position down the 
    screen).  Without an argument, one blank line is generated.  As
    some examples of arguments:
	0	no effect whatsoever
	1	same as no argument
	2	generate two blank lines
       -1	next line will end up at same y position as last line
       -2	next line will be above last line at normal spacing
       -3       next line will be above last line, with a blank line in
		between
    Fractional arguments are also legal.

@underlineon
    Turn on underlining.  Each line of text will be underlined until
    underlining is turned off.

@underlineoff
    Turn off underlining.

@linespacing float-value
    Set the linespacing.  The default is to leave a space half the
    max height of the current font between lines.  Setting the
    linespacing to 1 will leave exactly the max height of the current
    font between lines.   Linespacing of 0 will cause the lines to
    be practically on top of each other.  Negative and fractional 
    arguments are also legal. 

@linefeedon
    This is the default setting.  If on, each line of text rendered
    is automatically followed by a re-setting of the y value so that 
    the next line of text comes out in the right place.  See also
    @blankline and @linespacing.

@linefeedoff
    Turns off the automatic linefeed.  Note that this doesn't effect
    text already displayed.  If linefeed was on, the previous line 
    has already had the linefeed computed, even though you can't see
    it.  Likewise, when you turn off linefeed, you will either have
    to do it just before the last bit of text on the line, or else
    insert a blankline command to get the y positioning correct.  The
    position of the first text after an @linefeedoff command depends
    on the current justification mode, and isn't at all intuitive. It
    is probably best to do an @position if the current mode is not
    @left.  If left justifying, the first text will be left justified.
    All remaining text will follow immediately after the end of the
    previous input line, so you should be sure to include whatever 
    spaces are necessary.

@color red green blue
    Set the color of the text to be displayed.  The values should be
    integers in the range of 0-255.

@background red green blue
    Set the color of the background.  This color will be used to
    filter the characters against.  It is also used in the @clearscreen
    command below.  Arguments are as in the @color command.

@clearscreen
    Clears the screen to the current background color.  Also resets
    the current y position to be the usual default when the program
    starts up (somewhere "reasonable" near the top of the screen).

@pause
    This is useful for times when it may be convenient to specify
    several slides in the same input file.  The program is stopped,
    when it encounters this command, and can be resumed using the
    "c" command at the exec level.  The @pause command releases the frame
    buffer and tablet for other uses.

@expose [n]
    Causes the matrix camera to take a picture of the frame buffer image.
    If given a numeric argument, that many exposures will be made.  Default
    is 1.

@preview
    Turn on previewing mode.  All text will be sub-sampled in the
    bit-mapped definitions.  Thin lines may end up lost, but this
    mode is a little faster if you just want to make sure things
    are in the right place.  For really fast previewing, use the
    flash mode (below).

@flash
    Turns on flash mode, which provides super-fast previewing by not
    really drawing the font characters.  It puts up a box outlining
    the limits of each character and a hardware character within the
    box.  This mode writes to the overlay planes and is thus independent
    of text already in the frame buffer.  The clearscreen and eraseline
    commands will only affect the overlay planes when flash mode is 
    enabled.

@filter
    Turns filtering mode back on (this is the default). There is a
    four state switch which is set with the preview, flash and 
    filter commands.

@readback
    Turns on filter mode, but filtering will be done against the image
    already in the frame buffer, rather than against the preset background
    color.

@eraseline
    For use when running the tslide program interactively.  The 
    current line is erased.  This command usually will need to be
    preceded by a blankline command with a negative argument to
    back up to the line you are interested in.

@cursoron
    Also for interactive use, the hardware blinking dot cursor is
    used to indicate where the next text will appear.  The cursor
    will appear at the correct y value.  The x position will be
    the center of the screen if centering is on, the right margin
    if right is on, and the left margin is left is on.  If you have
    just done a position command, it will show that position.

@cursoroff
    Turn off cursor display.

@tablet
    Also for interactive use, especially when trying to position text
    onto a graphical image.  The tablet command waits for a pen pick 
    from the tablet and prints the x and y coordinates of the pick
    in the form of a position command.  As a side effect, the tablet
    command acts as if a position command had actually been issued
    for the selected point.

@quit
    Also for interactive use, this command exits the program.  (When
    run non-interactively, the program quits as soon as it runs out
    of input.)

    
File: graphics,  Node: TSlide,  Up: (graphics)User Programs
Date: Mon May 16 09:49 1983,	Prev: tcolors, Next: zoom-pgm



			 T S L I D E

The tslide program is used for developing text slides for presentations.
The program displays filtered text on the frame buffer, and slides may
be shot directly from the frame buffer using the matrix camera.

Tslide accepts lines from standard input.  The format is vaguely
"scribe-ish" with command strings prefixed by an "@" character.  The
commands and their effect are described below.  All of the commands must
begin in the first column of the line.  If you wish to have a line of text
begin with the "@" character, use "@@" to get a single "@" in the output.
Blank lines in the input file are ignored.

The tslide program can be run in either "batch" mode or "interactive"
mode.  The "batch" mode is useful for restoring a previously defined
slide to the screen in filtering mode.  The "interactive" mode is useful
for creating a slide which may need previewing (for example, to check
that the lines fit on the screen using the chosen font).  Certain 
of the commands described below will only be interesting when using
the program interactively.

@background red green blue
    Set the color of the background.  This color will be used to
    filter the characters against.  It is also used in the @clearscreen
    command below.  Arguments are as in the @color command.

@blankline [float number]
    Generate blank space (i.e. move the current y position down the 
    screen).  Without an argument, one blank line is generated.  As
    some examples of arguments:
	0	no effect whatsoever
	1	same as no argument
	2	generate two blank lines
       -1	next line will end up at same y position as last line
       -2	next line will be above last line at normal spacing
       -3       next line will be above last line, with a blank line in
		between
    Fractional arguments are also legal.  Moves in units of the current line
    spacing (see the @linespacing command).

@capsoff
    Turn off upper-casing.  Text goes onto the screen as it appeared
    in the file.

@capson
    Turn on upper-casing of text strings.  All text displayed will be 
    converted to uppercase before display.

@center
    All the following lines of text will be centered on the screen.  This
    may be disabled temporarily by the @position command (see below). Only
    one of @center, @left, and @right may be in effect at one time.

@clearall
    Unconditionally clears the screen and overlays.  The screen is cleared
    to the background color.

@clearscreen
    Clears the screen to the current background color.  Also resets
    the current y position to be the usual default when the program
    starts up (somewhere "reasonable" near the top of the screen).

@color red green blue
    Set the color of the text to be displayed.  The values should be
    integers in the range of 0-255.

@comment
    A comment command line is ignored, just as a blank line is ignored.

@cursoroff
    Turn off cursor display.

@cursoron
    Also for interactive use, the hardware blinking dot cursor is
    used to indicate where the next text will appear.  The cursor
    will appear at the correct y value.  The x position will be
    the center of the screen if centering is on, the right margin
    if right is on, and the left margin is left is on.  If you have
    just done a position command, it will show that position.

@eraseline
    For use when running the tslide program interactively.  The 
    current line is erased.  This command usually will need to be
    preceded by a blankline command with a negative argument to
    back up to the line you are interested in.

@expose [n]
    Causes the matrix camera to take a picture of the frame buffer image.
    If given a numeric argument, that many exposures will be made.  Default
    is 1.

@filter
    Turns filtering mode back on (this is the default). There is a
    four state switch which is set with the preview, flash and 
    filter commands.

@flash
    Turns on flash mode, which provides super-fast previewing by not
    really drawing the font characters.  It puts up a box outlining
    the limits of each character and a hardware character within the
    box.  This mode writes to the overlay planes and is thus independent
    of text already in the frame buffer.  The clearscreen and eraseline
    commands will only affect the overlay planes when flash mode is 
    enabled.

@font string
    Change the current font to be the named font.  For now, this 
    must refer to a filename which contains an appropriately formatted
    font definition.  If the name begins with a '/' character, a full
    path name is assumed.  If not, the file is assumed to be on
    /usr/lib/vfont.  In either case, if the file cannot be opened, the
    font is not changed.

@left [integer value]
    All the following lines of text are left justified at the specified x
    position.  If no argument is given, the left margin defaults to some
    reasonable value.

@linefeedoff
    Turns off the automatic linefeed.  Note that this doesn't effect
    text already displayed.  If linefeed was on, the previous line 
    has already had the linefeed computed, even though you can't see
    it.  Likewise, when you turn off linefeed, you will either have
    to do it just before the last bit of text on the line, or else
    insert a blankline command to get the y positioning correct.  The
    position of the first text after an @linefeedoff command depends
    on the current justification mode, and isn't at all intuitive. It
    is probably best to do an @position if the current mode is not
    @left.  If left justifying, the first text will be left justified.
    All remaining text will follow immediately after the end of the
    previous input line, so you should be sure to include whatever 
    spaces are necessary.

@linefeedon
    This is the default setting.  If on, each line of text rendered
    is automatically followed by a re-setting of the y value so that 
    the next line of text comes out in the right place.  See also
    @blankline and @linespacing.

@linespacing float-value
    Set the linespacing.  The default is to leave a space half the
    max height of the current font between lines.  Setting the
    linespacing to 1 will leave exactly the max height of the current
    font between lines.   Linespacing of 0 will cause the lines to
    be practically on top of each other.  Negative and fractional 
    arguments are also legal. 

@pause
    This is useful for times when it may be convenient to specify
    several slides in the same input file.  The program is stopped,
    when it encounters this command, and can be resumed using the
    "c" command at the exec level.  The @pause command releases the frame
    buffer and tablet for other uses.

@position xpos ypos
    Next text will begin at position (xpos, ypos).  This only applies
    to the next line of INPUT (i.e. it must be the last command before
    the text string it is intended to effect.  Centering, left and
    right justification are temporarily disabled.  Bad Side Effect:
    if left margin was on, it will resume at the x position given 
    for the position command.

@preview
    Turn on previewing mode.  All text will be sub-sampled in the
    bit-mapped definitions.  Thin lines may end up lost, but this
    mode is a little faster if you just want to make sure things
    are in the right place.  For really fast previewing, use the
    flash mode.

@quit
    Also for interactive use, this command exits the program.  (When
    run non-interactively, the program quits as soon as it runs out
    of input.)

@readback
    Turns on filter mode, but filtering will be done against the image
    already in the frame buffer, rather than against the preset background
    color.

@right [integer value]
    Just like left justify above, only justifies at right edge of screen.

@tablet
    Also for interactive use, especially when trying to position text
    onto a graphical image.  The tablet command waits for a pen pick 
    from the tablet and prints the x and y coordinates of the pick
    in the form of a position command.  As a side effect, the tablet
    command acts as if a position command had actually been issued
    for the selected point. [Almost - if the cursor is on, the displayed
    position will be wrong.]

@underlineoff
    Turn off underlining.

@underlineon
    Turn on underlining.  Each line of text will be underlined until
    underlining is turned off.

File: graphics,  Node: GSlide,  Up: (graphics)User Programs
Date: Mon May 16 10:36 1983,	Prev: grabit, Next: ldmap


			G S L I D E

>>> Introduction

The gslide program is an interactive program for costructing simple
graphical objects for slide presentations.  The program has no capability
for text.  One possible mode of operation for this program is as follows:

    Use the tslide (text slide generation) program to generate
    filtered text positioned on the screen as you like it.  

    Leave the image on the screen and run the gslide program to add
    the graphics you desire.  The gslide program operates completely
    in the overlay planes, so your image will be "underneath" while
    you add the graphics.

    When done, select the quit button (and confirm).  The program
    will prompt on your terminal for the name of an output file.
    The graphical objects you have created will be written to this
    file in (binary) Alpha_1 style format.

    Run the Alpha_1 rendering program to add the graphics to the
    image.  This may be done in two ways.  For non-filtered graphics,
    just render normally in OVERLAY mode with your text image on
    the screen.  For filtered graphics, run render with the 1K mode
    turned on.  This will produce a super-sampled image, which can
    then be filtered down (using the fltr1k command) and displayed
    on the screen.  Then redisplay your text on top of the graphics.
    [Note - currently the matrix at the beginning of the file must be
    edited before producing a filtered image.  Deconv the file and change
    the W coordinate in the matrix from 1.0 to 0.5.]

    Note that you really need to be a member of the Alpha_1 group
    in order to do the last several steps.

The next few sections describe briefly the action of the menu buttons
in the gslide program.  (Of course, the best way to figure out what it
does is to play with it.)

>>> Invoking Gslide

Gslide may read a previously created data file when it starts up.  To do
this, specify the filename as the (only) argument to gslide.  The data
file will be read in and displayed on the screen.

>>> Basic Objects

Four basic kinds of objects may be created: line segments, boxes,
open quadratic B-spline curves, and polylines or polygons.
Creation of all of these objects features "rubberband" lines which
are updated continuously to show what the object would look like
if the next point chosen were the current cursor position.

Line segments position one endpoint at the first pick.  A second
pick completes the line.

Boxes have a similar interaction to the lines, except that the picks
determine two diagonal corners of the box.

Polygons and polylines are series of line segments.  Entering points is
terminated by selecting a menu button.  (The rubber band line will follow
the cursor into the menu area, but will disappear as soon as the menu button
is selected.)  Polygons are created when the CLS box is selected, polylines
when the OPN box is selected.  Polygons automatically close when entry is
terminated, i.e. it is not necessary to reselect the last point.  When
rendered, polygons will be filled, while polylines will not.

Curves on the screen look EXACTLY like the polylines.  The difference
is that when they are output, the curve polygon is turned into the
control polygon for an open quadratic B-spline.  A good way to think
about what the final output will look like is just to think that the
spline will "round off" all the sharp corners in the polygon.  The
quadratic splines will come in tangent at the middle of each line
segment except the first and last.  Note that closing one of these
polygons may not do what you expect: you will still get a sharp corner
unless the first two and last two points are collinear.  (Obviously
the first and last must be the same point).  It does absolutely no
good to define curves instead of polylines if you aren't planning to
run render on the output of the program.

>>> Arrowheads

Arrowheads may be added to any line segment of any object you have
created, including curves (though it only makes sense to add them to the
end of a curve).  Creating an arrowhead involves two picks of existing
vertices to determine the direction of the arrow.  The arrowhead will be
located at the second pick pointing FROM the first pick TO the second
pick.  After the first pick a red x marks that the pick was seen.  If
the second pick doesn't hit an existing vertex, no arrowhead is created
and the red x is removed.  Note that the two points picked do not need
to be in the same object.

It is possible to adjust the shape and size of the arrowheads created.
The arrow menu button contains a line in the lower left corner which
shows the shape of (half) an arrowhead in the current shape.  Once arrow
mode is turned on, the arrow menu button may be reselected to change the
shape of the arrowhead.  The whole arrowhead will be displayed and its
shape may be adjusted as long as the button is held down.  All arrows
created after this point will have the newly defined shape.

>>> Moving Objects

There are two types of movement of already created objects.  The
first is vertex movement.  Any vertex of any object may be repositioned
by selecting the move button, and then selecting the vertex.  The point
will be dragged along with the cursor until the next pick is made.  One
important thing to remember is that moving vertices does NOT preserve
the shape of arrows.  Boxes will remain rectangular, so that they may be
resized.

The second type of movement is for repositioning entire objects.  Once
the move ob button is selected, any vertex of the object may be picked
and the object will then follow the cursor (maintaining it's overall
shape) until the next pick is made.  If a number of objects have been
grouped (see below) then the entire group will move.

>>> Copying Objects

If copy is selected, then picking an object creates a copy of it which
can be dragged to a new location on the screen and deposited there.  The
dragging action is exactly as in move object (above).

>>> Deletion

The delete button allows objects or groups to be deleted.  Picking any
vertex in the object to be deleted marks the object for deletion by
displaying it in red.  The next pick should be a vertex in the same
object (usually the same one of course) to confirm the deletion.  After
confirmation, the object will disappear.  Note that individual vertices
cannot be deleted, only objects.

>>> Adding Vertices

The ADD button may be used to add vertices to polylines, polygons or
curves.  Two picks must be made to determine where the new vertex will
be added.  The first establishes one end of a segment, the second pick
should be the other end.  The new point will be inserted between the two
endpoints, and can be dragged to its appropriate position.  If a point
is to be added at the end of a polyline or curve, the first pick should
be the endpoint, and the second pick should select the same point.

>>> Showing Vertices

Since it is sometimes not obvious where the vertices of a control
polygon lie, if the SHOW button is picked, an "x" will be drawn at each
vertex of curve control polygons, polylines and polygons.  The SHOW
button will turn red.  When the button is picked again, the "x"s will be
erased and the button will return to its normal white color.  This
button may be selected independently of any other buttons.

>>> Modes

Selecting the MODES button switches to a second menu.  Its entries are
described below.  To return to the original menu, select any object
creation button (ARROW, BOX, etc.).

>>> Gridding

In order to facilitate lining up of graphical objects, an invisible grid
is provided.  All picked values will be rounded to the nearest grid
point.  The size of the grid is adjustable using the grid menu button.
This button has three selection areas.  If the word "GRID" or the number
is picked, you will be prompted at the terminal for the new grid size.
An integer number is expected: 1 turns gridding off completely, values
up to about 10 are fairly easy to work with.  If the "+" is selected,
the grid size is incremented while the button is held down.  The "-"
decrements the grid size.  Changing the grid size in the middle of the
session may result in some minor problems in handling positioning of
objects.  In particular, in move vertex mode it may not be possible to
put a vertex back down exactly where you got it (this is evident mostly
in boxes).  Also, it may not be possible to line up a new object (an
arrowhead, for example) with an object that was defined with a different
grid size.  Both of these can be overcome by turning the grid size off
momentarily.

>>> Clear

It is occasionally useful to be able to clear out all the objects created
and start all over (as if restarting the program).  This is possible
using the clear button.  It requires confirmation.

>>> Color

Objects defined with the gslide program may be assigned a color.  This
is only useful if they are to be rendered with the Alpha_1 system.
The color menu box has three buttons.  The "COLOR" button, when
selected, allows the user to determine the color of a picked object.
When an object is picked, its color will be printed on the terminal, and
all objects which are the same color will be highlighted in red.  The
"SET" button allows one to change the color of an object.  When an
object is picked, it will be highlighted, its current color will be
printed on the terminal, and a new color will be prompted for.  Hitting
a return will keep the same color, otherwise three integers in the 0-255
range should be entered as the red, green and blue components of the
desired color.  The "DFT" button sets the default color to be used for
further object creation.  It prompts for a color on the terminal after
printing the current default color.  An object picked while the DFT
button is highlighted will be highlighted, and, if picked again, will
have its color changed to the new default color.

>>> Z Values

The Z menu box has two buttons which may be used to change the Z value
at single vertices, or for entire objects.  When a vertex or object is
picked, its current Z value will be printed and a new Z prompted for.
Hitting return keeps the current Z value.  If the Z/OB button is
selected, the Z value for the picked vertex will be printed, but the Z
values for all vertices in the object will be changed.

>>> Grouping

It is possible to group a number of objects together so that they are
treated by the program as a single object.  The GROUP menu box has four
buttons, GROUP, BX, RM and UN.  If GROUP is selected, then any objects
selected (including other groups) will be combined into a single group.
This process may be terminated by picking any other menu button.  

The GROUP/BX button allows objects to be grouped by drawing a box around
the objects to be grouped.  All objects (including other groups) with at
least one vertex inside the box will be placed in the new group.  The
box is placed just as if one were actually creating a box.  All the
objects in the new group are highlighted.  This is just for information,
it is impossible to back out, the group has already been created.
Pressing the button again erases the temporary box and unhighlights the
group.  

The GROUP/RM button allows individual objects to be removed from a
group.  Each object picked will be highlighted only if it is a group
member.  Picking another vertex of the same object will confirm the
removal.  Picking somewhere else will abort the remove command, and the
object will not be removed from the group.

The GROUP/UN button will totally disband a group into individual
objects.  The picked group will be highlighted, and if another vertex in
the group is selected, the group will be no more.  If a pick is made
somewhere else, the group will remain together.

>>> Quitting

When you exit the program using the quit button (which also requires
confirmation), you will be prompted at the terminal for the name of
a file to write the created objects to.  Responding with just a carriage
return will bypass output and just quit the program.  This is appropriate
if you don't wish to save the objects, if you are shooting film directly
from the screen, or if you don't have access to the Alpha_1 rendering
programs and can't use the output anyway.

If you do name a file, and for some reason it cannot be opened for writing,
the quit will be aborted and you will remain in the program in a normal
state, so that the session is not lost.

Assuming the file is opened successfully, the objects will be written
in (binary) Alpha_1 object stream format for input to the rendering
program.  After output, the program erases the menu and cursor and exits.


File: graphics,  Node: TSlide,  Up: (graphics)User Programs
Date: Mon May 23 12:39 1983,	Prev: tcolors, Next: zoom-pgm



			 T S L I D E

The tslide program is used for developing text slides for presentations.
The program displays filtered text on the frame buffer, and slides may
be shot directly from the frame buffer using the matrix camera.

Tslide accepts lines from standard input.  The format is vaguely
"scribe-ish" with command strings prefixed by an "@" character.  The
commands and their effect are described below.  All of the commands must
begin in the first column of the line.  If you wish to have a line of text
begin with the "@" character, use "@@" to get a single "@" in the output.
Blank lines in the input file are ignored.

The tslide program can be run in either "batch" mode or "interactive"
mode.  The "batch" mode is useful for restoring a previously defined
slide to the screen in filtering mode.  The "interactive" mode is useful
for creating a slide which may need previewing (for example, to check
that the lines fit on the screen using the chosen font).  Certain 
of the commands described below will only be interesting when using
the program interactively.

@! command
    Execute a shell command.  Releases resources so the command can use
    them.

@background red green blue
    Set the color of the background.  This color will be used to
    filter the characters against.  It is also used in the @clearscreen
    command below.  Arguments are as in the @color command.

@blankline [float number]
    Generate blank space (i.e. move the current y position down the 
    screen).  Without an argument, one blank line is generated.  As
    some examples of arguments:
	0	no effect whatsoever
	1	same as no argument
	2	generate two blank lines
       -1	next line will end up at same y position as last line
       -2	next line will be above last line at normal spacing
       -3       next line will be above last line, with a blank line in
		between
    Fractional arguments are also legal.  Moves in units of the current line
    spacing (see the @linespacing command).

@bold [number]
    Causes characters to be artificially emboldened by smearing them some
    number of pixels to the left.  This is particularly useful with the S
    fonts.  @bold 0 or @bold with no argument resets to do no emboldening.

@capsoff
    Turn off upper-casing.  Text goes onto the screen as it appeared
    in the file.

@capson
    Turn on upper-casing of text strings.  All text displayed will be 
    converted to uppercase before display.

@center [position]
    All the following lines of text will be centered on the screen.  This
    may be disabled temporarily by the @position command (see below). Only
    one of @center, @left, and @right may be in effect at one time.  If an
    argument is given, text will be centered about that X position.  If no
    argument is given, but a positioning command (@position, @tablet,
    @tomark) is in effect, then the X position set by the positioning
    command will be used.

@clearall
    Unconditionally clears the screen and overlays.  The screen is cleared
    to the background color, linefeed is turned on, and the position is
    reset to the top line.

@clearscreen
    Clears the screen to the current background color.  Also resets the
    current y position to be the usual default when the program starts up
    (somewhere "reasonable" near the top of the screen) and turns on
    linefeed.

@color red green blue
    Set the color of the text to be displayed.  The values should be
    integers in the range of 0-255.

@comment
    A comment command line is ignored, just as a blank line is ignored.

@cursoroff
    Turn off cursor display.

@cursoron
    Also for interactive use, the hardware blinking dot cursor is
    used to indicate where the next text will appear.  The cursor
    will appear at the correct y value.  The x position will be
    the center of the screen if centering is on, the right margin
    if right is on, and the left margin is left is on.  If you have
    just done a positioning command, it will show that position.

@eraseline
    For use when running the tslide program interactively.  The 
    current line is erased.  This command usually will need to be
    preceded by a blankline command with a negative argument to
    back up to the line you are interested in.

@expose [n]
    Causes the matrix camera to take a picture of the frame buffer image.
    If given a numeric argument, that many exposures will be made.  Default
    is 1.

@filter
    Turns filtering mode back on (this is the default). There is a
    four state switch which is set with the preview, flash and 
    filter commands.

@flash
    Turns on flash mode, which provides super-fast previewing by not
    really drawing the font characters.  It puts up a box outlining
    the limits of each character and a hardware character within the
    box.  This mode writes to the overlay planes and is thus independent
    of text already in the frame buffer.  The clearscreen and eraseline
    commands will only affect the overlay planes when flash mode is 
    enabled.

@font string string
    Change the current font(s) to be the named font(s).  The first font is
    used in normal text, the second in super and subscripts.  If only the
    first one is given, the sub/superscript font is not changed.  For now,
    this must refer to a filename which contains an appropriately formatted
    font definition.  If the name begins with a '/' character, a full path
    name is assumed.  If not, the file is assumed to be on /usr/lib/vfont.
    In either case, if the file cannot be opened, the font is not changed.
    It defaults to "B.12 B.10".

@label string(s)
    Defines a label.  Labels can have several effects, but are intended to
    be used to indicate the beginning of each slide.  If tslide is invoked
    with the -l labellist option then each time a label is encountered, it
    will be compared with the list.  If it is not on the list, execution of
    the input will be turned off until a label which IS on the list is
    encountered.  Using -L will cause each label to be announced on stdout.
    If -L was specified, but no label list was supplied, then everything
    will be executed, but the labels will still be announced.  If -p was
    specified, tslide will pause at each label.  If a standard is set (see
    @standard, below), then the program state will be reset when a label is
    encountered.

@left [position]
    All the following lines of text are left justified at the specified x
    position.  If no argument is given, then it will take the current
    position if a positioning command has just been executed, or a default
    value if not.

@linefeedoff
    Turns off the automatic linefeed.  Note that this doesn't effect text
    already displayed.  If linefeed was on, the previous line has already
    had the linefeed computed, even though you can't see it.  Likewise, when
    you turn off linefeed, you will either have to do it just before the
    last bit of text on the line, or else insert a blankline command to get
    the y positioning correct.  The position of the first text after an
    @linefeedoff command is at the left margin, except after a positioning
    command, when it will be at the position set. All remaining text will
    follow immediately after the end of the previous input line, so you
    should be sure to include whatever spaces are necessary.  Blankline
    commands executed with linefeedoff will only change the y position, not
    the x position.

@linefeedon
    This is the default setting.  If on, each line of text rendered
    is automatically followed by a re-setting of the y value so that 
    the next line of text comes out in the right place.  Executing this
    command will cause a linefeed to occur immediately.

@linespacing float-value
    Set the linespacing.  The default is to leave a space half the
    max height of the current font between lines.  Setting the
    linespacing to 1 will leave exactly the max height of the current
    font between lines.   Linespacing of 0 will cause the lines to
    be practically on top of each other.  Negative and fractional 
    arguments are also legal. 

@mark [number] [X/Y]
    A mark is a remembered position on the screen.  There are currently 10
    marks, numbered 0 through 9.  If no number is given, mark 0 will be
    used.  If 'X' or 'Y' is specified, then 

@pause
    This is useful for times when it may be convenient to specify
    several slides in the same input file.  The program is stopped,
    when it encounters this command, and can be resumed using the
    "c" command at the exec level.  The @pause command releases the frame
    buffer and tablet for other uses.

@position xpos ypos
    Next text will begin at position (xpos, ypos).  This only applies
    to the next line of INPUT (i.e. it must be the last command before
    the text string it is intended to effect.  Centering, left and
    right justification are temporarily disabled.  Bad Side Effect:
    if left margin was on, it will resume at the x position given 
    for the position command.

@preview
    Turn on previewing mode.  All text will be sub-sampled in the
    bit-mapped definitions.  Thin lines may end up lost, but this
    mode is a little faster if you just want to make sure things
    are in the right place.  For really fast previewing, use the
    flash mode.

@quit
    Also for interactive use, this command exits the program.  (When
    run non-interactively, the program quits as soon as it runs out
    of input.)

@readback
    Turns on filter mode, but filtering will be done against the image
    already in the frame buffer, rather than against the preset background
    color.

@right [integer value]
    Just like left justify above, only justifies at right edge of screen.

@tablet
    Also for interactive use, especially when trying to position text
    onto a graphical image.  The tablet command waits for a pen pick 
    from the tablet and prints the x and y coordinates of the pick
    in the form of a position command.  As a side effect, the tablet
    command acts as if a position command had actually been issued
    for the selected point. [Almost - if the cursor is on, the displayed
    position will be wrong.]

@underlineoff
    Turn off underlining.

@underlineon
    Turn on underlining.  Each line of text will be underlined until
    underlining is turned off.

File: graphics,  Node: TSlide,  Up: (graphics)User Programs
Date: Mon May 23 13:06 1983,	Prev: tcolors, Next: zoom-pgm



			 T S L I D E

The tslide program is used for developing text slides for presentations.
The program displays filtered text on the frame buffer, and slides may
be shot directly from the frame buffer using the matrix camera.

Tslide accepts lines from standard input.  The format is vaguely
"scribe-ish" with command strings prefixed by an "@" character.  The
commands and their effect are described below.  All of the commands must
begin in the first column of the line.  If you wish to have a line of text
begin with the "@" character, use "@@" to get a single "@" in the output.
Blank lines in the input file are ignored.

The tslide program can be run in either "batch" mode or "interactive"
mode.  The "batch" mode is useful for restoring a previously defined
slide to the screen in filtering mode.  The "interactive" mode is useful
for creating a slide which may need previewing (for example, to check
that the lines fit on the screen using the chosen font).  Certain 
of the commands described below will only be interesting when using
the program interactively.

The command usage is
	tslide [-{Ll} [labellist]] [-p] [-f prefix] [-x] [file]
The options are:

	-l (or -L) flag takes a comma separated list of labels.  These labels
    will be searched for as described in the label command.  

	-p causes tslide to pause at each label.  

	-f is used to put the tslide output into files instead of tying up the
    frame buffer.  Each time an expose command is executed, a file names
    "prefix.n" will be created, where n is the exposure number.  The count
    on the expose command will be ignored.  

	-x flag prevents expose commmands from being executed.  

	Finally, the input file name may be given on the command line.

Positions may be specified in several different ways.  Absolute coordinates
    may be specified as integers, or relative coordinates as integers
    preceded by a + or -.  Absence of a position argument is interpreted as
    "+0".  An integer preceded by a # sign will cause the position to be
    taken from the x or y coordinate of the corresponding mark.

@! command
    Execute a shell command.  Releases resources so the command can use
    them.

@background red green blue
    Set the color of the background.  This color will be used to
    filter the characters against.  It is also used in the @clearscreen
    command below.  Arguments are as in the @color command.

@blankline [float number]
    Generate blank space (i.e. move the current y position down the 
    screen).  Without an argument, one blank line is generated.  As
    some examples of arguments:
	0	no effect whatsoever
	1	same as no argument
	2	generate two blank lines
       -1	next line will end up at same y position as last line
       -2	next line will be above last line at normal spacing
       -3       next line will be above last line, with a blank line in
		between
    Fractional arguments are also legal.  Moves in units of the current line
    spacing (see the @linespacing command).

@bold [number]
    Causes characters to be artificially emboldened by smearing them some
    number of pixels to the left.  This is particularly useful with the S
    fonts.  @bold 0 or @bold with no argument resets to do no emboldening.

@capsoff
    Turn off upper-casing.  Text goes onto the screen as it appeared
    in the file.

@capson
    Turn on upper-casing of text strings.  All text displayed will be 
    converted to uppercase before display.

@center [position]
    All the following lines of text will be centered on the screen.  This
    may be disabled temporarily by the @position command (see below). Only
    one of @center, @left, and @right may be in effect at one time.  If an
    argument is given, text will be centered about that X position.  If no
    argument is given, but a positioning command (@position, @tablet,
    @tomark) is in effect, then the X position set by the positioning
    command will be used.

@clearall
    Unconditionally clears the screen and overlays.  The screen is cleared
    to the background color, linefeed is turned on, and the position is
    reset to the top line.

@clearscreen
    Clears the screen to the current background color.  Also resets the
    current y position to be the usual default when the program starts up
    (somewhere "reasonable" near the top of the screen) and turns on
    linefeed.

@color red green blue
    Set the color of the text to be displayed.  The values should be
    integers in the range of 0-255.

@comment
    A comment command line is ignored, just as a blank line is ignored.

@cursoroff
    Turn off cursor display.

@cursoron
    Also for interactive use, the hardware blinking dot cursor is
    used to indicate where the next text will appear.  The cursor
    will appear at the correct y value.  The x position will be
    the center of the screen if centering is on, the right margin
    if right is on, and the left margin is left is on.  If you have
    just done a positioning command, it will show that position.

@eraseline
    For use when running the tslide program interactively.  The 
    current line is erased.  This command usually will need to be
    preceded by a blankline command with a negative argument to
    back up to the line you are interested in.

@expose [n]
    Causes the matrix camera to take a picture of the frame buffer image.
    If given a numeric argument, that many exposures will be made.  Default
    is 1.

@filter
    Turns filtering mode back on (this is the default). There is a
    four state switch which is set with the preview, flash and 
    filter commands.

@flash
    Turns on flash mode, which provides super-fast previewing by not
    really drawing the font characters.  It puts up a box outlining
    the limits of each character and a hardware character within the
    box.  This mode writes to the overlay planes and is thus independent
    of text already in the frame buffer.  The clearscreen and eraseline
    commands will only affect the overlay planes when flash mode is 
    enabled.

@font string string
    Change the current font(s) to be the named font(s).  The first font is
    used in normal text, the second in super and subscripts.  If only the
    first one is given, the sub/superscript font is not changed.  For now,
    this must refer to a filename which contains an appropriately formatted
    font definition.  If the name begins with a '/' character, a full path
    name is assumed.  If not, the file is assumed to be on /usr/lib/vfont.
    In either case, if the file cannot be opened, the font is not changed.
    It defaults to "B.12 B.10".

@label string(s)
    Defines a label.  Labels can have several effects, but are intended to
    be used to indicate the beginning of each slide.  If tslide is invoked
    with the -l labellist option then each time a label is encountered, it
    will be compared with the list.  If it is not on the list, execution of
    the input will be turned off until a label which IS on the list is
    encountered.  Using -L will cause each label to be announced on stdout.
    If -L was specified, but no label list was supplied, then everything
    will be executed, but the labels will still be announced.  If -p was
    specified, tslide will pause at each label.  If a standard is set (see
    @standard, below), then the program state will be reset when a label is
    encountered.

@left [position]
    All the following lines of text are left justified at the specified x
    position.  If no argument is given, then it will take the current
    position if a positioning command has just been executed, or a default
    value if not.

@linefeedoff
    Turns off the automatic linefeed.  Note that this doesn't effect text
    already displayed.  If linefeed was on, the previous line has already
    had the linefeed computed, even though you can't see it.  Likewise, when
    you turn off linefeed, you will either have to do it just before the
    last bit of text on the line, or else insert a blankline command to get
    the y positioning correct.  The position of the first text after an
    @linefeedoff command is at the left margin, except after a positioning
    command, when it will be at the position set. All remaining text will
    follow immediately after the end of the previous input line, so you
    should be sure to include whatever spaces are necessary.  Blankline
    commands executed with linefeedoff will only change the y position, not
    the x position.

@linefeedon
    This is the default setting.  If on, each line of text rendered
    is automatically followed by a re-setting of the y value so that 
    the next line of text comes out in the right place.  Executing this
    command will cause a linefeed to occur immediately.

@linespacing float-value
    Set the linespacing.  The default is to leave a space half the
    max height of the current font between lines.  Setting the
    linespacing to 1 will leave exactly the max height of the current
    font between lines.   Linespacing of 0 will cause the lines to
    be practically on top of each other.  Negative and fractional 
    arguments are also legal. 

@mark [number] [X/Y]
    A mark is a remembered position on the screen.  There are currently 10
    marks, numbered 0 through 9.  If no number is given, mark 0 will be
    used.  If 'X' or 'Y' is specified, then the tomark command will only
    restore the X or Y coordinate by default.  X marks are useful for lining
    up columns, etc.

@noshowon
    Noshow mode inhibits the display of text on the frame buffer.  It is
    useful for figuring out where marks should be without putting the text
    into the image.
@noshowoff
    Allows text display again.

@pause
    This is useful for times when it may be convenient to specify
    several slides in the same input file.  The program is stopped,
    when it encounters this command, and can be resumed using the
    "c" command at the exec level.  The @pause command releases the frame
    buffer and tablet for other uses.  See also the -p option and the label
    command.

@position xpos ypos
    Next text will begin at position (xpos, ypos).  This only applies
    to the next line of INPUT (i.e. it must be the last command before
    the text string it is intended to effect.  Centering, left and
    right justification are temporarily disabled.

@preview
    Turn on previewing mode.  All text will be sub-sampled in the
    bit-mapped definitions.  Thin lines may end up lost, but this
    mode is a little faster if you just want to make sure things
    are in the right place.  For really fast previewing, use the
    flash mode.

@quit
    Also for interactive use, this command exits the program.  (When
    run non-interactively, the program quits as soon as it runs out
    of input.)

@readback
    Turns on filter mode, but filtering will be done against the image
    already in the frame buffer, rather than against the preset background
    color.

@right [position]
    Just like left justify above, only justifies at right edge of screen.

@special number ...
    Displays the character whose ascii code is number.  Can be given several
    numbers and will display the corresponding characters one after another.

@standard
    Remembers the current program state for restoration at each following
    label command.  Items stored are:
	font names, sub/superscript mode, background and text colors, left
	and right margins, centering position, current justification mode
	(left, right, center or linefeedoff), capson/off flag,
	underlineon/off flag, line spacing and display mode (flash, filter,
	preview, readback).

@subscript
@unsubscript
@superscript
@unsuperscript
    These commands move in and out of sub or superscript text.  Subscript
    changes to the subscript font and moves down a half line.  Superscript
    moves up half a line and changes to the superscript font.  Unsubscript
    and unsuperscript undo these actions.  You cannot put subscripts or
    superscripts on subscripts or superscripts.

@tablet
    For interactive use, especially when trying to position text
    onto a graphical image.  The tablet command waits for a pen pick 
    from the tablet and prints the x and y coordinates of the pick
    in the form of a position command.  As a side effect, the tablet
    command acts as if a position command had actually been issued
    for the selected point.

@tomark [number] [X/Y/B]
    Returns to the position of the given mark.  If X or Y is given, then
    only that coordinate will be changed.  If B is given, then both X and Y
    will be changed.  If no second argument is present, then the X/Y setting
    given when the mark was defined will be used.  If no number is given,
    mark 0 is used.

@underlineoff
    Turn off underlining.

@underlineon
    Turn on underlining.  Each line of text will be underlined until
    underlining is turned off.

