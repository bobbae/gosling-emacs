



                                                  UNIX EMACS



                                              James Gosling @ CMU
                                                   May, 1982


                                       Copyright (c) 1982 James Gosling
2


                             Table of Contents

1. Introduction                                                             4

2. The Screen                                                               5

3. Input Conventions                                                        6

4. Invoking Emacs                                                           7

5. Basic Commands                                                           8

6. Unbound Commands                                                         9

7. Getting Help                                                            10

8. Buffers and Windows                                                     11

9. Terminal types                                                          12

10. Compiling programs                                                     13

11. Dealing with collections of files                                      15

12. Abbrev mode                                                            16

13. Extensibility                                                          17

13.1. Macros                                                               17
13.2. MLisp -- Mock Lisp                                                   17
   13.2.1. The syntax of MLisp expressions                                 17
   13.2.2. The evaluation of MLisp expressions                             18
   13.2.3. Scope issues                                                    19
   13.2.4. MLisp functions                                                 20
   13.2.5. Debugging                                                       21
13.3. A Sample MLisp Program                                               21
13.4. More on Invoking Emacs                                               23

14. Searching                                                              25

14.1. Simple searches                                                      25
14.2. Regular Expression searches                                          25

15. Keymaps                                                                28

16. Region Restrictions                                                    31
                                                                               3


 17. Mode Lines                                                               32

 18. Multiple Processes under Emacs                                           34

 18.1. Blocking                                                               36
 18.2. Buffer Truncation                                                      37
 18.3. Problems                                                               37

 19. The Emacs database facility                                              38

 20. Packages                                                                 40

 20.1. buff -- one-line buffer list                                           40
 20.2. c-mode -- simple assist for C programs                                 40
 20.3. dired -- directory editor                                              40
 20.4. goto -- go to position in buffer                                       41
 20.5. incr-search -- ITS style incremental search                            41
 20.6. info -- documentation reader                                           43
 20.7. occur -- find occurances of a string                                   43
 20.8. process -- high level process manipulation                             43
 20.9. pwd -- print and change the working directory                          44
 20.10. rmail -- a mail management system                                     44
      20.10.1. Sending Mail                                                   45
      20.10.2. Reading Mail                                                   46
 20.11. scribe -- weak assistance for dealing with Scribe documents           48
 20.12. scribe-bib -- Scribe bibliography creation mode                       48
 20.13. spell -- a simple spelling corrector                                  49
 20.14. tags -- a function tagger and finder                                  49
 20.15. text-mode -- assist for simple text entry                             50
 20.16. time -- a mode line clock                                             50
 20.17. writeregion -- write region to file                                   50

 21. Command Description                                                      51

 22. Options                                                                  93

 Reference Card

 Index                                                                       101
4


1. Introduction

                               ``What  is Emacs?  It is a tree falling in
                                 the forest with no one to hear it.    It
                                 is   a   beautiful  flower  that  smells
                                 awful.''

This manual attempts  to  describe  the  Unix  implementation  of  Emacs,  an
extensible  display  editor.   It is an editor in that it is primarily used for
typing  in  and  modifying  documents,  programs,  or  anything  else  that  is
represented  as  text.    It  uses  a display to interact with the user, always
keeping an accurate representation of what is happening visible on  the  screen
that  changes  in step with the changes made to the document.  The feature that
distinguishes Emacs from most other editors is its extensibility,  that  is,  a
user of Emacs can dynamically change Emacs to suit his own tastes and needs.

Calling  this  editor Emacs is rather presumptuous and even dangerous.  There
are two major editors called Emacs. The first was written at MIT for their  ITS
systems  as  an  extension to TECO.  This editor is the spiritual father of all
the Emacs-like editors; it's principal author was Richard Stallman.  The  other
was  also  written  at MIT, but it was written in MacLisp for Multics by Bernie
Greenberg.  This editor picks up where ITS Emacs leaves off  in  terms  of  its
extension  facilities.   Unix Emacs was called Emacs in the hope that the cries
of outrage would be enough to goad the author and others to bring it up to  the
standards of what has come before.

This  manual  is  organized  in a rather haphazard manner.  The first several
sections were written hastily in an attempt to provide a  general  introduction
to  the  commands in Emacs and to try to show the method in the madness that is
the Emacs command structure.  Section 21 (page  51)  contains  a  complete  but
concise  description  of all the commands and is in alphabetical order based on
the name of the command.  Preceding sections generally do not give  a  complete
description of each command, rather they give either the name of the command or
the  key  to  which  the command is conventionally bound.  Section 22 (page 99)
lists for each key the command to  which  it  is  conventionally  bound.    The
options  which  may  be  set  with the set command are described in section 22,
(page 93).
                                                                               5


 2. The Screen
   Emacs  divides  a  screen into several areas called windows, at the bottom of
 the screen there is a one line area that is used  for  messages  and  questions
 from  Emacs.    Most  people will only be using one window, at least until they
 become more familiar with Emacs.  A window is displayed as a set of  lines,  at
 the  bottom of each window is its mode line (For more information on mode lines
 see section 17, page 32).  The lines above the mode line contain  an  image  of
 the  text  you  are  editing  in  the region around dot (or point).  Dot is the
 reference around which editing takes place.  Dot is a pointer which points at a
 position between two characters.  On the screen, the cursor will be  positioned
 on  the  character  that immediatly follows dot.  When characters are inserted,
 they are inserted at the position where dot points; commands exist that  delete
 characters  both  to  the left and to the right of dot.  The text on the screen
 always reflects they way that the text looks now.
6


3. Input Conventions
Throughout  this manual, characters which are used as commands are printed in
bold face: X.  They will sometimes have a control prefix which is printed as an
uparrow character: ^X is control-X and is typed by  holding  down  the  control
(often labeled ctrl on the top of the key) and simultaneously striking X.  Some
will  have  an  escape  (sometimes called meta) prefix which is usually printed
thus: ESC-X and typed by striking the escape key (often labeled  esc)  then  X.
And  some  will have a ^X prefix which is printed ^XX which is typed by holding
down the control key, striking X, releasing the control  key  then  striking  X
again.

For  example,  ESC-^J  is typed by striking ESC then holding down the control
key and striking J.
                                                                               7


 4. Invoking Emacs
   Emacs is invoked as a Unix command by typing 

     emacs files

 to  the Shell (the Unix command interpreter).  Emacs will start up, editing the
 named files.  You will probably only want to name  one  file.    If  you  don't
 specify  any  names,  Emacs  will use the same names that it was given the last
 time that it was invoked.  Gory details on the invocation of Emacs can be found
 in section 13.4, page 23.
8


5. Basic Commands
Normally  each  character  you type is interpreted individually by Emacs as a
command.  The instant you  type  a  character  the  command  it  represents  is
performed immediatly.

All of the normal printing characters when struck just insert themselves into
the buffer at dot.

To  move  dot  there  are  several simple commands.  ^F moves dot forward one
character, ^B moves it backward one character.  ^N moves dot to the same column
on the next line, ^P moves it to the same column on the previous line.

String searches may be used to move dot by using the ^S command to search  in
the forward direction and ^R to search in the reverse direction.

Deletions  may  be  performed using ^H (backspace) to delete the character to
the left of dot and ^D to delete the character to the right of dot.

The following table summarizes all of the motion and deletion commands.

                                      Direction
                                 Move          Delete
Units of Motion               Left   Right   Left   Right
Characters                     ^B     ^F      ^H      ^D
Words                        ESC-B   ESC-F   ESC-H  ESC-D
Intra line                     ^A     ^E       ^K
Inter line                     ^P     ^N
                                                                               9


 6. Unbound Commands
   Even  though  the number of characters available to use for Emacs commands is
 large, there are still more commands than characters.   You  probably  wouldn't
 want  to bind them all to keys even if you could.  Each command has a long name
 and by that long name may be bound to a key.  For example, ^F is normally bound
 to the command named forward-character which moves dot forward one character.

   There are many commands that are not normally bound to keys.  These  must  be
 executed  with  the  ESC-X  command  or  by  binding  them  to  a  key (via the
 bind-to-key command).  Heaven help the twit who rebinds ESC-X.

   The ESC-X command will print ": " on the last line of the display and  expect
 you  to  type in the name of a command.  Space and ESC characters may be struck
 to invoke Tenex style command completion (ie. you type in the first part of the
 command, hit the space bar, and Emacs will fill in the rest for you -- it  will
 complain  if  it  can't  figure out what you're trying to say).  If the command
 requires arguments, they will also be prompted for on the bottom line.
10


7. Getting Help
Emacs  has  many  commands  that  let you ask Emacs for help about how to use
Emacs.  The simplest one is ESC-? (apropos) which asks you for  a  keyword  and
then  displays a list of those commands whose full name contains the keyword as
a substring.  For example, to find out which commands are available for dealing
with windows, type ESC-?, Emacs will ask "Keyword:" and you reply "window".   A
list like the following appears:

  beginning-of-window          ESC-,
  delete-other-windows         ^X1
  delete-window                ^XD
  end-of-window                ESC-.
  enlarge-window               ^XZ
  line-to-top-of-window        ESC-!
  next-window                  ^XN
  page-next-window             ESC-^V
  previous-window              ^XP
  shrink-window                ^X^Z
  split-current-window         ^X2

To  get detailed information about some command, the describe-command command
can be used.  It asks for the  name  of  a  command,  then  displays  the  long
documentation  for  it  from  the  manual.    For  example,  if you wanted more
information     about     the     shrink-window     command,     just      type
"ESC-Xdescribe-command shrink-window" and Emacs will reply:

   shrink-window
               Makes the current window one line shorter, and the window
             (or the one above if there is no window below) one  line  ta
             Can't be used if there is only one window on the screen.

If  you  want  to  find  out  what  command  is  bound  to  a particular key,
describe-key will do it for you.  Describe-bindings can  be  used  to  make  a
"wall  chart"  description  of the key bindings in the currently running Emacs,
taking into account all of the bindings you have made.
                                                                              11


 8. Buffers and Windows
   There are two fundamental objects in Emacs, buffers and windows.  A buffer is
 a  chunk  of text that can be edited, it is often the body of a file.  A window
 is a region on the screen through which a buffer may be viewed.  A window looks
 at one buffer, but a buffer may be on view in several windows.    It  is  often
 handy to have two windows looking at the same buffer so that you can be looking
 at  two separate parts of the same file, for example, a set of declarations and
 a piece of code that uses those declarations.  Similarly, it is often handy  to
 have two different buffers on view in two windows.

   The  commands  which  deal with windows and buffers are:  beginning-of-window
 (ESC-,), delete-other-windows (^X1), delete-region-to-buffer (ESC-^W),  delete-
 window  (^XD),  end-of-window  (ESC-.),  enlarge-window  (^XZ), line-to-top-of-
 window  (ESC-!),  list-buffers  (^X^B),  next-window  (^XN),   page-next-window
 (ESC-^V),  previous-window  (^XP),  shrink-window  (^X^Z), split-current-window
 (^X2), switch-to-buffer (^XB), use-old-buffer (^X^O) and yank-buffer  (ESC-^Y).
 See the command description section for more details on each of these.
12


9. Terminal types
Grim  reality  being  what it is, Emacs has to deal with a wide assortment of
displays from many manufacturers.  Each manufacturer has  their  own  perverted
idea  of  how  programs should communicate with the display, so it is important
for Emacs to correctly be told what type of terminal  is  being  used.    Under
Unix,  this  is done by setting the environment variable `TERM'.  Normally, the
operating system should set this to correspond to the type of terminal that you
are using and you won't have to concern yourself with it.    However,  problems
may arise and there are a few things that you should know.

`TERM'  is  a string variable whose value is the name of the type of terminal
that you are using.  If you are using the standard Unix shell then it should be
set using the commands:  

  TERM=...
  export TERM

If you're using the C shell (csh) then it should be set using the command:  

  setenv TERM ...

where  `...'  is  the  appropriate  terminal  type.     Consult   your   system
administrator for a current list of valid terminal types.  A good place to look
is the file ``/etc/termcap'', it contains a list of all the terminals supported
by Emacs.  A few of the more common values are:

concept-lnz   For Concepts with the special firmware for Emacs.
concept       Concept 100, 104 and 108's from HDS.
h19           For Heathkit or Zenith model 19 terminals.
vt100         For VT100's from DEC, or any of the thousands of look-alikes.
aaa           For the Ann Arbor Ambassador.
                                                                              13


 10. Compiling programs
   One  of the most powerful features of Unix Emacs is the facility provided for
 compiling programs and coping with error  messages  from  the  compilers.    It
 essential that you understand the standard Unix program make (even if you don't
 use  Emacs).    This  program  takes a database (a makefile) that describes the
 relationships among files and how to regenerate (recompile) them.  If you  have
 a  program  that  is made up of many little pieces that have to be individually
 compiled and carefully crafted together into a single executable file, make can
 make your life orders of magnitude easier; it will automatically recompile only
 those pieces that need to be recompiled and put them together.  Emacs has a set
 of commands that gracefully interact with this facility.

   The ^X^E (execute) command writes all modified buffers and executes the  make
 program.    The  output  of  make will be placed into a buffer called Error log
 which will be visible in some window  on  the  screen.  As  soon  as  make  has
 finished  Emacs  parses  all  of  its output to find all the error messages and
 figure out the files  and  lines  referred  to.  All  of  this  information  is
 squirreled away for later use by the ^X^N command.

   The ^X^N (next) command takes the next error message from the set prepared by
 ^X^E and does three things with it:

    - Makes  the message itself visible at the top of a window.  The buffer
      will be named Error log.

    - Does a visit (see the ^X^V command) on the file in  which  the  error
      occurred.

    - Sets  dot  to  the  beginning  of the line where the compiler saw the
      error. This setting of dot takes into account  changes  to  the  file
      that  may  have been made since the compilation was attempted.  Emacs
      perfectly compensates for any changes that may  have  been  made  and
      always  positions  the text on the correct line (well, correct as far
      as the compiler was concerned; the compiler itself may  have  been  a
      trifle confused about where the error occurred)

 If you've seen all the error messages ^X^N will say so and do nothing else.

   So, the general scenario for dealing with programs is:

    - Build a make database to describe how your program is to be compiled.

    - Compile your program from within Emacs by typing ^X^E.

    - If  there  were  errors, step through them by typing ^X^N, correcting
      the error, and typing ^X^N to get the next.

    - When you run out of error messages, type ^X^E to try the  compilation
      again.

    - When  you  finally  manage  to  get your beast to compile without any
      errors, type ^C to say goodbye to Emacs.
14


 - You'll probably want to use sdb, the symbolic debugger, to debug your
   program.
                                                                              15


 11. Dealing with collections of files
   The  ^X^E  command  doesn't always execute the make program: if it is given a
 non-zero argument it will prompt for a Unix command  line  to  be  executed  in
 place  of  make.  All of the other parts of ^X^E are unchanged, namely it still
 writes all modified buffers before executing the command and parses the  output
 of the command execution for line numbers and file names.

   This  can be used in some very powerful ways.  For example, consider the grep
 program.  Typing "^U^X^Egrep -n MyProc *.cESC" will scan all C programs in  the
 current  directory  and look for all occurrences of the string "MyProc".  After
 grep has finished you can use Emacs (via  the  ^X^N  command)  to  examine  and
 possibly  change every instance of the string from a whole collection of files.
 This makes the task of changing  all  calls  to  a  particular  procedure  much
 easier.    Note: this only works with the version of grep in /usr/jag/bin which
 has been modified to print line numbers in a format that Emacs can understand.

   There are many more uses.  The lint program, for example.  Scribe users might
 find "cat MyReport.otl" to be useful.

   A file name/line number pair is just a string embedded someplace in the  text
 of  the  error log that has the form "FileName, line LineNumber".  The FileName
 may or may not be surrounded by quotes (").   The  critical  component  is  the
 string  ",  line  " that comes between the file name and the line number.  Roll
 your own file scanning programs, it can make your life much easier.
16


12. Abbrev mode
Abbrev  mode  allows  the user to type abbreviations into a document and have
Emacs automatically expand them.  If you have an abbrev called "rhp"  that  has
been  defined  to  expand  to the string "rhinocerous party" and have turned on
abbrev mode then typing the first non-alphanumeric character after having typed
"rhp" causes the string "rhp" to be  replaced  by  "rhinocerous  party".    The
capitalization  of the typed in abbreviation controls the capitalization of the
expansion:  "Rhp" would expand as "Rhinocerous party" and "RHP" would expand as
"Rhinocerous Party".

Abbreviations are defined in abbrev tables.  There is a global  abbrev  table
which  is  used regardless of which buffer you are in, and a local abbrev table
which is selected on a buffer by buffer basis, generally depending on the major
mode of the buffer.

Define-global-abbrev takes two arguments: the name of an abbreviation and the
phrase that it is to expand to.  The abbreviation will be defined in the global
abbrev table.  Define-local-abbrev is like define-global-abbrev except that  it
defines the abbreviation in the current local abbrev table.

The  use-abbrev-table  command is used to select (by name) which abbrev table
is to be used locally in this buffer.  The same abbrev table  may  be  used  in
several  buffers.    The  mode  packages  (like electric-c and text) all set up
abbrev tables whose name matches the name of the mode.

The switch abbrev-mode must be turned on before Emacs will attempt to  expand
abbreviations.    When abbrev-mode is turned on, the string "abbrev" appears in
the  mode  section  of  the  mode  line  for  the  buffer.     Use-abbrev-table
automatically  turns  on  abbrev-mode  if either the global or new local abbrev
tables are non-empty.

All abbreviations currently defined can be written out to a  file  using  the
write-abbrev-file command.  Such a file can be edited (if you wish) and later
read back in to define the same abbreviations again.  Read-abbrev-file reads in
such a file and screams if it cannot be found, quietly-read-abbrev-file doesn't
complain (it is  primarily  for  use  in  startups  so  that  you  can  load  a
current-directory  dependant  abbrev file without worrying about the case where
the file doesn't exist).

People writing MLisp programs can have procedures invoked when an  abbrev  is
triggered.    Use  the  commands define-hooked-global-abbrev and define-hooked-
local-abbrev to do this.  These behave exactly  as  the  unhooked  versions  do
except  that  they  also  associate  a named command with the abbrev.  When the
abbrev triggers, rather than replacing  the  abbreviation  with  the  expansion
phrase  the  hook  procedure  is invoked. The character that trigged the abbrev
will not have been inserted, but will be inserted  immediatly  after  the  hook
procedure  returns  [unless the procedure returns 0].  The abbreviation will be
the word immediatly to the left  of  dot,  and  the  function  abbrev-expansion
returns the phrase that the abbrev would have expanded to.
                                                                              17


 13. Extensibility
   Unix  Emacs  has  two  extension features: macros and a built in Lisp system.
 Macros are used when you have something quick and simple to do,  Lisp  is  used
 when  you  want  to  build  something  fairly  complicated  like a new language
 dependant mode.

 13.1. Macros
   A macro is just a piece of text that Emacs remembers in a special way.   When
 a macro is executed the characters that make up the macro are treated as though
 they  had  been  typed  at  the  keyboard.  If you have some common sequence of
 keystrokes you can define a macro that contains them and  instead  of  retyping
 them just call the macro.  There are two ways of defining macros:

   The  easiest  is  called  a  keyboard  macro.  A keyboard macro is defined by
  typing the start-remembering command (^X() then typing the commands which  you
 want  to  have  saved  (which will be executed as you type them so that you can
 make sure that they are right) then typing the stop-remembering command  (^X)).
 To  execute  the  keyboard  macro  just type the execute-keyboard-macro command
 (^Xe).  You can only have one keyboard macro at a time.  If you  define  a  new
 keyboard macro the old keyboard macro vanishes into the mist.

   Named  macros  are  slightly  more  complicated.   They have names, just like
 commands and MLisp functions and can be called by name (or  bound  to  a  key).
 They  are  defined  by  using  the  define-string-macro  command (which must be
 executed by typing ESC-Xdefine-string-macro since it isn't usually bound  to  a
 key)  which asks for the name of the macro and it's body.  The body is typed in
 as a string in the prompt area at the bottom  the  the  screen  and  hence  all
 special  characters  in  it  must be quoted by prefixing them with ^Q.  A named
 macro may be executed by typing ESC-Xname-of-macro or by binding it  to  a  key
 with bind-to-key.

   The  current  keyboard macro can be converted into a named macro by using the
  define-keyboard-macro command which takes a name a defines  a  macro  by  that
 name  whose  body  is  the  current keyboard macro.  The current keyboard macro
 ceases to exist.

 13.2. MLisp -- Mock Lisp
   Unix Emacs contains an interpreter for  a  language  that  in  many  respects
 resembles  Lisp.    The  primary (some would say only) resemblance between Mock
 Lisp and any real Lisp is the general syntax of a program, which many  feel  is
 Lisp's  weakest  point.    The differences include such things as the lack of a
 cons function and a rather peculiar method of passing parameters.



 13.2.1. The syntax of MLisp expressions
   There are four basic syntactic entities out of which  MLisp  expressions  are
 built.  The  two  simplest  are  integer constants (which are optionally signed
 strings of digits) and string constants  (which  are  sequences  of  characters
 bounded  by  double  quote  [``"''] characters -- double quotes are included by
 doubling them: """" is a one character string. The third are  names  which  are
 used  to  refer  to  things: variables or procedures.  These three are all tied
18


together  by the use of procedure calls.  A procedure call is written as a left
parenthesis, ``('', a name which refers to the procedure, a list of  whitespace
separated   expressions   which   serve  as  arguments,  and  a  closing  right
parenthesis, ``)''.  An expression is simply  one  of  these  four  things:  an
integer  constant,  a  string  constant,  a name, or a call which may itself be
recursivly composed of other expressions.

String constants may contain the usual C excape sequences, "\n" is a newline,
"\t" is a tab, "\r" is a carriage return, "\b" is  a  backspace,  "\e"  is  the
escape  (033)  character, "\nnn" is the character whose octal representation is
nnn, and "^\c" is the control version of the character c.

For example, the following are legal MLisp expressions:

1             The integer constant 1.

"hi"          A two character string constant

"\^X\^F"      A two character string constant

"""what?"""   A seven character string constant

(+ 2 2)       An invocation of the "+" function with integer arguments 2  and
              2.    "+"  is  the  usual  addition  function.  This expression
              evaluates to the integer 4.

(setq bert (* 4 12))
              An invocation of the function setq with the  variable  bert  as
              its  first  argument  and  and  expression  that  evaluates the
              product of 4 and 12 as its second argument.  The evaluation  of
              this expression assigns the integer 48 to the variable bert.

(visit-file "mbox")
              An invocation of the function visit-file with the string "mbox"
              as  its  first  argument.   Normally the visit-file function is
              tied to the key ^X^B.  When it is invoked interactively, either
              by typing ^X^B  or  ESC-Xvisit-file,  it  will  prompt  in  the
              minibuf  for  the  name of the file.  When called from MLisp it
              takes the file name from  the  parameter  list.    All  of  the
              keyboard-callable function behave this way.

Names  may  contain  virtually any character, except whitespace or parens and
they cannot begin with a digit, ``"'' or ``-''.



13.2.2. The evaluation of MLisp expressions
Variables  must  be  declared  (bound)  before  they  can  be  used.      The
declare-global  command  can be used to declare a global variable; a local is
declared by listing it at the beginning of a progn or  a  function  body  (ie.
immediatly  after the function name or the word progn and before the executable
statements).  For example:
                                                                              19


     (defun
         (foo i
             (setq i 5)
         )
     )

 defines  a  rather  pointless function called foo which declares a single local
 variable i and assigns it the value 5.  Unlike real Lisp systems, the  list  of
 declared variables is not surrounded by parenthesis.

   Expressions  evaluate to values that are either integers, strings or markers.
 Integers and strings are converted automaticly from one to the  other  type  as
 needed:  if  a  function requires an integer parameter you can pass it a string
 and the characters that make it up will be  parsed  as  an  integer;  similarly
 passing  an  integer  where  a  string is required will cause the integer to be
 converted.    Variables  may  have  either  type  and  their  type  is  decided
 dynamically when the assignment is made.

   Marker  values  indicate  a  position  in a buffer.  They are not a character
 number.  As insertions  and  deletions  are  performed  in  a  buffer,  markers
 automatically  follow  along,  maintaining  their position.  Only the functions
 mark and dot return markers; the user may define ones that do  and  may  assign
 markers  to  variables.    If  a  marker  is used in a context that requires an
 integer value then the ordinal of the position within the buffer is used; if  a
 marker  is  used in a context that requires a string value then the name of the
 marked buffer is used.  For example, if there has been  assigned  some  marker,
 then  (pop-to-buffer  there)  will  pop  to the marked buffer.  (goto-character
 there) will set dot to the marked position.

   A procedure written in MLisp is simply an expression that is bound to a name.
 Invoking the name causes the associated expression to be evaluated.  Invocation
 may be triggered either by the evaluation of some expression  which  calls  the
 procedure,  by the user typing it's name to the ESC-X command, or by striking a
 key to which the procedure name has been bound.

   All of the commands listed in section 21 (page 51) may  be  called  as  MLisp
 procedures.  Any parameters that they normally prompt the user for are taken as
 string  expressions  from the argument list in the same order as they are asked
  for interactivly.    For  example,  the  switch-to-buffer  command,  which  is
 normally  tied  to  the  ^XB key, normally prompts for a buffer name and may be
 called from MLisp like this:  (switch-to-buffer string-expression).



 13.2.3. Scope issues
   There are  several  sorts  of  names  that  may  appear  in  MLisp  programs.
 Procedure,  buffer  and  abbrev  table names are all global and occupy distinct
 name space. For variables there are three cases:

    1. Global variables: these variables have a  single  instance  and  are
       created either by using declare-global, set-default or setq-default.
           Their  lifetime is the entire editing session from the time they
20


    are created.

 2. Local  variables:  these  have an instance for each declaration in a
    procedure body or local  block  (progn).    Their  lifetime  is  the
    lifetime  of the block which declares them.  Local declarations nest
    and hide inner local or global declarations.

 3. Buffer-specific variables: these have  a  default  instance  and  an
    instance  for each buffer in which they have been explicitly given a
    value.  They are created by using declare-buffer-specific.   When  a
    variable which has been declared to be buffer specific is assigned a
    value,  if  an  instance  for the current buffer hasn't been created
    then it will be.  The value is assigned to the  instance  associated
    with  the  current  buffer.    If  a  buffer  specific  variable  is
    referenced and an instance doesn't exist for this  buffer  then  the
    default  value  is  used.  This default value may be set with either
    setq-default or set-default.  If a global  instance  exists  when  a
    variable  is  declared buffer-specific then the global value becomes
    the default.



13.2.4. MLisp functions
An MLisp function is defined by executing the defun function.  For example:

  (defun
      (silly
          (insert-string "Silly!")
      )
  )

defines a function called silly which, when invoked, just  inserts  the  string
"Silly!" into the current buffer.

MLisp  has  a  rather strange (relative to other languages) parameter passing
mechanism.  The arg function, invoked as (arg  i  prompt)  evaluates  the  i'th
argument  of  the  invoking  function  if  the  invoking  function  was  called
interactivly or, if the invoking function was not called interactivly, arg uses
the prompt to ask you for the value.  Consider the following function:

  (defun
      (in-parens
          (insert-string "(")
          (insert-string (arg 1 "String to insert? "))
          (insert-string ")")
      )
  )

If you type ESC-Xin-parens to invoke in-parens interactivly then Emacs will ask
in the minibuffer "String to insert? " and then insert the  string  typed  into
the  current buffer surrounded by parenthesis.  If in-parens is invoked from an
MLisp function by (in-parens "foo") then the invocation of arg inside in-parens
                                                                              21


 will  evaluate  the expression "foo" and the end result will be that the string
 "(foo)" will be inserted into the buffer.

   The function interactive may be used to determine whether or not the invoking
 function was called interactivly.  Nargs will return the  number  of  arguments
 passed to the invoking function.

   This  parameter  passing  mechanism may be used to do some primitive language
 extension.  For example, if you wanted a statement that executed a statement  n
 times, you could use the following:

     (defun
         (dotimes n
             (setq n (arg 1))
             (while (> n 0)
                 (setq n (- n 1))
                 (arg 2)
             )
         )
     )

 Given  this,  the  expression (dotimes 10 (insert-string "<>")) will insert the
 string "<>" 10 times.  [Note:  The  prompt  argument  may  be  omitted  if  the
 function can never be called interactivly] .



 13.2.5. Debugging
   Unfortunatly,  debugging  MLisp  functions  is something of a black art.  The
 biggest problem right now is that if an MLisp function goes  into  an  infinite
 loop there is no way to stop it.

   There  is  no  breakpoint facility.  All that you can do is get a stack trace
 whenever an error occurs by setting the stack-trace-on-error  variable.    With
 this  set,  any  time  that  an error occurs a dump of the MLisp execution call
 stack and some other information is dumped to the "Stack trace" buffer.

 13.3. A Sample MLisp Program
   The following piece of  MLisp  code  is  the  Scribe  mode  package.    Other
 implementations  of  Emacs, on ITS and on Multics have modes that influence the
 behaviour of Emacs on  a  file.    This  behaviour  is  usually  some  sort  of
 language-specific  assistance.    In Unix Emacs a mode is no more that a set of
 functions, variables and key-bindings.  This mode package  is  designed  to  be
 useful when editing Scribe source files.
22


(defun
                    The apply-look function makes the current word "look"
                  different  by  changing the font that it is printed in.
                  It positions dot at the beginning of the  word  so  you
                  can  see  where  the  change  will  be made and reads a
                  character from the tty.  Then it inserts "@c[" (where c
                  is the character typed) at the front of  the  word  and
                  "]" at the back.  Apply-look gets tied to the key ESC-l
                  so  typing ESC-l i when the cursor is positioned on the
                  word "begin" will change the word to "@i[begin]".
  (apply-look go-forward
      (save-excursion c
          (if (! (eolp)) (forward-character))
          (setq go-forward -1)
          (backward-word)
          (setq c (get-tty-character))
          (if (> c ' ')
              (progn (insert-character '@')
                  (insert-character c)
                  (insert-character '[')
                  (forward-word)
                  (setq go-forward (dot))
                  (insert-character ']')
              )
          )
      )
      (if (= go-forward (dot)) (forward-character))
  )
)
                                                                              23



 (defun
                       This  function  is called to set a buffer into Scribe
                     mode
     (scribe-mode
         (remove-all-local-bindings)
                       If the string "LastEditDate=""" exists in  the  first
                     2000  characters  of  the  document  then the following
                     string constant is changed to the current  date.    The
                     intent  of  this  is  that  you  should  stick  at  the
                     beginning    of    your    file    a     line     like:
                     ``@string(LastEditDate="Sat  Jul  11 17:59:01 1981")''.
                     This will automatically get changed each time you  edit
                     the  file  to  reflect that last date on which the file
                     was edited.
         (if (! buffer-is-modified)
             (save-excursion
                 (error-occurred
                     (goto-character 2000)
                     (search-reverse "LastEditDate=""")
                     (search-forward """")
                     (set-mark)
                     (search-forward """")
                     (backward-character)
                     (delete-to-killbuffer)
                     (insert-string (current-time))
                     (setq buffer-is-modified 0)
                 )
             )
         )
         (local-bind-to-key "justify-paragraph" "\ej")
         (local-bind-to-key "apply-look" "\el")
         (setq right-margin 77)
         (setq mode-string "Scribe")
         (setq case-fold-search 1)
         (use-syntax-table "text-mode")
         (modify-syntax-entry "w    -'")
         (use-abbrev-table "text-mode")
         (setq left-margin 1)
         (novalue)
     )
 )

 (novalue)

 13.4. More on Invoking Emacs
   When Emacs is invoked, it does several  things  that  are  not  of  too  much
 interest to the beginning user.

    1. Emacs looks for a file called ``.emacs pro'' in your home directory,
       if  it exists then it is loaded, with the load command.  This is the
       mechanism used for user profiles -- in your .emacs pro  file,  place
24


    the  commands  needed  to  customize Emacs to suit your taste.  If a
    user has not set up  an  .emacs pro  file  then  Emacs  will  use  a
    site-specific  default file for initialization.  At CMU this file is
    named /usr/local/lib/emacs/maclib/profile.ml

 2. Emacs  will  then  interprete  its  command  line  switches.      "-
    l<filename>"   loads  the  given  file  (only  one  may  be  named),
    "-e<funcname>" executes the named function (again, only one  may  be
    named).    -l  and  -e  are  executed  in that order, after the user
    profile is read, but before and file  visits  are  done.    This  is
    intended  to be used along with the csh alias mechanism to allow you
    to invoke Emacs packages from the  shell  (that  is,  assuming  that
    there  is  anyone  out  there  who still uses the shell for anything
    other than to run under Emacs!). For  example:  "alias  rmail  emacs
    -lrmail  -ermail-com"  will  cause the csh "rmail" command to invoke
    Emacs running rmail.  Exiting rmail will exit Emacs.

 3. If neither argv nor argc have yet been called (eg. by  your  startup
    or  by  the  command  line named package) then the list of arguments
    will be considered as file names and will be visited; if  there  are
    no  arguments  then  the  arguments passed to the last invocation of
    Emacs will be used.

 4. Finally,  Emacs  invokes  it's  keyboard  command  interpreter,  and
    eventually terminates.
                                                                              25


 14. Searching
                                                               1
   Emacs  is  capable  of  performing  two  kinds  of  searches .  There are two
 parallel sets of searching and replacement commands that  differ  only  in  the
 kind of search performed.

 14.1. Simple searches
   The   commands   search-forward,   search-reverse,  query-replace-string  and
 replace-string all do simple searches.  That is, the search  string  that  they
 use  is  matched  directly  against  successive  substrings of the buffer.  The
 characters of the search string have no special meaning.   These  search  forms
 are  the easiest to understand and are what most people will want to use.  They
 are what is conventionally bound to ^S, ^R, ESC-Q and ESC-R.

 14.2. Regular Expression searches
   The commands re-search-forward,  re-search-reverse,  re-query-replace-string,
 re-replace-string  and  looking-at  all  do  regular  expression searches.  The
 search string is interpreted as a regular expression and  matched  against  the
 buffer according to the following rules:

    1. Any  character  except  a  special character matches itself. Special
       characters are `\' `[' `.' and sometimes `^' `*' `$'.

    2. A `.' matches any character except newline.

    3. A `\' followed by  any  character  except  those  mentioned  in  the
       following rules matches that character.

    4. A `\w' Matches any word character, as defined by the syntax tables.

    5. A  `\W'  Matches  any  non-word  character, as defined by the syntax
       tables.

    6. A `\b'  Matches  at  a  boundary  between  a  word  and  a  non-word
       character, as defined by the syntax tables.

    7. A  `\B'  Matches  anywhere  but  at  a boundary between a word and a
       non-word character, as defined by the syntax tables.

    8. A `\`' Matches at the beginning of the buffer.

    9. A `\'' Matches at the end of the buffer.

   10. A `\<' Matches anywhere before dot.

   11. A `\>' Matches anywhere after dot.


                

   1
    Regular and Vanilla for those of you with no taste
26


12. A `\=' Matches at dot.

13. A  nonempty  string s bracketed ``[ s ]'' (or ``[^ s ]'' matches any
    character in (or not in) s.  In s, `\' has no special  meaning,  and
    `]' may only appear as the first letter. A substring a-b, with a and
    b  in ascending ASCII order, stands for the inclusive range of ASCII
    characters.

14. A `\' followed by a digit n matches a copy of the  string  that  the
    bracketed regular expression beginning with the n th `\(' matched.

15. A  regular expression of one of the preceeding forms followed by `*'
    matches a sequence of 0 or more matches of the regular expression.

16. A regular expression, x,  bracketed  ``\(  x  \)''  matches  what  x
    matches.

17. A  regular  expression  of  this  or one of the preceeding forms, x,
    followed by a regular expression of one of the preceeding  forms,  y
    matches  a  match  for x followed by a match for y, with the x match
    being as long as possible while still permitting a y match.

18. A regular expression of one of the preceeding forms preceded by  `^'
    (or  followed  by  `$'), is constrained to matches that begin at the
    left (or end at the right) end of a line.

19. A sequence of regular expressions of one  of  the  preceeding  forms
    seperated by `\|'s matches any one of the regular expressions.

20. A  regular  expression  of one of the preceeding forms picks out the
    longest amongst the leftmost matches if searching forward, rightmost
    if searching backward.

21. An empty regular expression stands for a copy of  the  last  regular
    expression encountered.

In   addition,   in   the  replacement  commands,  re-query-replace-string  and
re-replace-string, the characters  in  the  replacement  string  are  specially
interpreted:

 - Any character except a special character is inserted unchanged.

 - A  `\' followed by any character except a digit causes that character
   to be inserted unchanged.

 - A `\' followed by a digit n causes the  string  matched  by  the  nth
   bracketed expression to be inserted.

 - An  `&'  causes  the string matched by the entire search string to be
   inserted.

The following examples should clear a little of the mud:
                                                                              27


 Pika            Matches the simple string ``Pika''.

 Whiskey.*Jack   Matches   the  string  ``Whiskey'',  followed  by  the  longest
                 possible sequence of non-newline characters,  followed  by  the
                 string  ``Jack''.    Think of it as finding the first line that
                 contains the string ``Whiskey'' followed eventually on the same
                 line by the string ``Jack''

 [a-z][a-z]*     Matches a non-null sequence of lower case alphabetics.    Using
                 this   in   the   re-replace-string   command  along  with  the
                 replacement string ``(&)'' will place  parenthesis  around  all
                 sequences of lower case alphabetics.

 Guiness\|Bass   Matches either the string `Guiness' or the string `Bass'.

 \Bed\b          Matches `ed' found as the suffix of a word.

 \bsilly\W*twit\b
                 Matches  the  sequence of words `silly' and `twit' seperated by
                 arbitrary punctuation.
28


15. Keymaps
When a user is typing to Emacs the keystrokes are interpreted using a keymap.
A  keymap  is  just  a  table  with  one  entry for each character in the ASCII
character set.  Each entry either names a function or another keymap.  When the
user strikes a  key,  the  corresponding  keymap  entry  is  examined  and  the
indicated  action  is  performed.  If the key is bound to a function, then that
function will be invoked.  If the key is bound  to  another  keymap  then  that
keymap is used for interpreting the next keystroke.

There is always a global keymap and a local keymap, as keys are read from the
keyboard  the  two trees are traversed in parallel (you can think of keymaps as
FSMs, with keystrokes triggering transitions).  When either of  the  traversals
reaches  a  leaf,  that  function is invoked and interpretation is reset to the
roots of the trees.

The root keymaps are  selected  using  the  use-global-map  or  use-local-map
commands.  A new empty keymap is created using the define-keymap command.

The  contents  of  a  keymap  can  be  changed  by  using the bind-to-key and
local-bind-to-key commands.  These two commands take two arguments: the name of
the function to be bound and the keystroke sequence to which it is to be bound.
This keystroke sequence is interpreted relative to the current local or  global
keymaps.      For  example,  (bind-to-key  "define-keymap"  "\^Zd")  binds  the
define-keymap function to the keystroke sequence `^Z' followed by `d'.

A named keymap behaves just like a function, it can be  bound  to  a  key  or
executed  within  an  MLisp function.  When it is executed from within an MLisp
function, it causes the next keystroke to be interpreted relative to that map.

The following sample uses the keymap to partially  simulate  the  vi  editor.
Different  keymaps are used to simulate the different modes in vi: command mode
and insertion mode.

(defun
  (insert-before              ; Enter insertion mode
      (use-global-map "vi-insertion-mode"))

  (insert-after               ; Also enter insertion mode, but after
                              ; the current character
      (forward-character)
      (use-global-map "vi-insertion-mode"))

  (exit-insertion             ; Exit insertion mode and return to
                              ; command mode
      (use-global-map "vi-command-mode"))

  (replace-one
      (insert-character (get-tty-character))
      (delete-next-character))

  (next-skip
      (beginning-of-line)
                                                                              29


         (next-line)
         (skip-white-space))

     (prev-skip
         (beginning-of-line)
         (previous-line)
         (skip-white-space))

     (skip-white-space
         (while (& (! (eolp)) (| (= (following-char) ' ') (= (following-char
             (forward-character)))

     (vi                         ; Start behaving like vi
         (use-global-map "vi-command-mode"))
 )

 ; setup vi mode tables
 (define-keymap "vi-command-mode")
 (define-keymap "vi-insertion-mode")

 (use-global-map "vi-insertion-mode"); Setup the insertion mode map
 (bind-to-key "execute-extended-command" "\^X")
 (progn i
     (setq i ' ')
     (while (< i 0177)
         (bind-to-key "self-insert" i)
         (setq i (+ i 1))))
 (bind-to-key "self-insert" "\011")
 (bind-to-key "newline" "\015")
 (bind-to-key "self-insert" "\012")
 (bind-to-key "delete-previous-character" "\010")
 (bind-to-key "delete-previous-character" "\177")
 (bind-to-key "exit-insertion" "\033")

 (use-global-map "vi-command-mode"); Setup the command mode map
 (bind-to-key "execute-extended-command" "\^X")
 (bind-to-key "next-line" "\^n")
 (bind-to-key "previous-line" "\^p")
 (bind-to-key "forward-word" "w")
 (bind-to-key "backward-word" "b")
 (bind-to-key "search-forward" "/")
 (bind-to-key "search-reverse" "?")
 (bind-to-key "beginning-of-line" "0")
 (bind-to-key "end-of-line" "$")
 (bind-to-key "forward-character" " ")
 (bind-to-key "backward-character" "\^h")
 (bind-to-key "backward-character" "h")
 (bind-to-key "insert-after" "a")
 (bind-to-key "insert-before" "i")
 (bind-to-key "replace-one" "r")
 (bind-to-key "next-skip" "+")
 (bind-to-key "next-skip" "\^m")
30


(bind-to-key "prev-skip" "-")
(use-global-map "default-global-keymap")
                                                                              31


 16. Region Restrictions
   The  portion  of  the  buffer  which Emacs considers visible when it performs
 editing operations may be restricted to some subregion of the whole buffer.

   The narrow-region command  sets  the  restriction  to  encompass  the  region
 between  dot  and  mark.    Text outside this region will henceforth be totally
 invisible.  It won't appear on the screen and it won't be  manipulable  by  any
 editing  commands.   It will, however, be read and written by file manipulation
 commands like read-file and  write-current-file.    This  can  be  useful,  for
 instance,  when you want to perform a replacement within a few paragraphs: just
 narrow down to a region enclosing the paragraphs and execute replace-string.

   The widen-region command sets the restriction to encompass the entire buffer.
 It is usually used after a narrow-region to restore Emacs's  attention  to  the
 whole buffer.

   Save-restriction is only useful to people writing MLisp programs.  It is used
 to  save  the  region  restriction  for the current buffer (and only the region
 restriction) during the execution of some subexpression  that  presumably  uses
 region  restrictions.    The  value of (save-restriction expressions...) is the
 value of the last expression evaluated.
32


17. Mode Lines
A  mode line is the line of descriptive text that appears just below a window
on the screen.  It usually provides a description of the state  of  the  buffer
and  is  usually shown in reverse video.  The standard mode line shows the name
of the buffer, an `*' if the buffer has been modified, the  name  of  the  file
associated with the buffer, the mode of the buffer, the current position of dot
within  the  buffer  expressed  as  a  percentage  of  the  buffer size and and
indication of the nesting within recursive-edit's which is  shown  by  wrapping
the mode line in an appropriate number of `[' `]' pairs.

It  is  often  the  case that for some silly or practical reason one wants to
alter the layout of the mode line, to show more, less or different information.
Emacs has a fairly general facility for doing this.  Each buffer has associated
with it a format string that describes the layout of the  mode  line  for  that
buffer  whenever it appears in a window.  The format string is interpreted in a
manner much like the format argument to the C  printf  subroutine.    Unadorned
characters  appear  in  the  mode  line  unchanged.   The `%' character and the
following format designator character cause some special string  to  appear  in
the mode line in their place.  The format designators are:

b             Inserts the name of the buffer.
f             Inserts the name of the file associated with the buffer.
m             Inserts the value of the buffer-specific variable mode-string.
M             Inserts the value of the variable global-mode-string.
p             Inserts the position of "dot" as a percentage.
*             Inserts an `*' if the buffer has been modified.
[             Inserts (recursion-depth) `['s.
]             Inserts (recursion-depth) `]'s.

If  a  number  n  appears  between the `%' and the format designator then the
inserted string is constrained to be exactly n  characters  wide.    Either  by
padding or truncating on the right.

At CMU the default mode line is built using the following format:  

  " %[Buffer: %b%*  File: %f  %M (%m)  %p%]"

The following variables are involved in generating mode lines:

mode-line-format
              This  is  the buffer specific variable that provides the format
              of a buffers mode line.

default-mode-line-format
              This is the value to which mode-line-format is initialized when
              a buffer is created.

mode-string   This buffer-specific string variable can be inserted  into  the
              mode  line  by using `%m' in the format.  This is it's only use
              by  Emacs.    Usually,  mode  packages  (like  `lisp-mode'   or
              `c-mode') put some string into mode-string to indicate the mode
              of  the  buffer.    It  is  the  appearance  of  this  piece of
                                                                              33


                 descriptive information that gives the mode line its name.

 global-mode-string
                 This  is similar to mode-string except that it is global -- the
                 same string will be inserted into all mode lines by `%M'.    It
                 is  usually  used  for  information  of  global  interest.  For
                 example, the time package puts the current time of day and load
                 average there.
34


18. Multiple Processes under Emacs
Emacs  has  the  ability  to  handle  multiple interactive subprocesses.  The
following is a sketchy description of this capability.

In general, you will not want to use any of the functions  described  in  the
rest  of  this  section.    Instead,  you  should  be using one of the supplied
packages that invoke them, see 20.8  page  43.    For  example,  the  ``shell''
command  provides  you with a window into an interactive shell and the ``time''
package puts the current time and load average (continuously updated) into  the
mode line.

Multiple   interactive   processes   can   be   started  under  Emacs  (using
"start-process" or "start-filtered-process").  Processes are tied to  a  buffer
at  inception  and are thereafter known by this buffer name.  Input can be sent
to a process from the region or a string, and output from processes is normally
attached to the end of the process buffer.  There is also the ability  to  have
Emacs  call  an  arbitrary  MLISP  procedure to process the output each time it
arrives from a process (see "start-filtered-process").

Many of the procedures dealing with process management  use  the  concept  of
"current-process"  and  "active-process".    The current-process is usually the
most  recent  process  to  have  been  started.    Two  events  can  cause  the
current-process to change:

 1. When  the  present  current-process  dies,  the  most  recent of the
    remaining processes is popped up to take its place.

 2. The  current-process   can   be   explicitly   changed   using   the
    "change-current-process" command.

The  active-process  refers to the current-process, unless the current buffer
is a live process in which case it refers to the current buffer.

Below is list of the current mlisp procedures for using processes:


active-process [unbound]:  (active-process) -- Returns the name of  the  active
   process as defined in the section describing the process mechanism.


change-current-process   [unbound]:    (change-current-process  "process-name")
   -- Sets the current process to the one named.
                                                                              35


 continue-process  [unbound]:    (continue-process "process-name") -- Continue a
      process stopped by stop-process.


 current-process [unbound]:   (current-process)  --  Returns  the  name  of  the
      current   process  as  defined  in  the  section  describing  the  process
      mechanism.


 eot-process [unbound]:  (eot-process "process-name") --  Send  an  EOT  to  the
      process.


 int-process  [unbound]:    (int-process  "process-name")  --  Send an interrupt
      signal to the process.


 kill-process [unbound]:  (kill-process "process-name") -- Send a kill signal to
      the process.


 list-processes [unbound]:  (list-processes)  --  Analagous  to  "list-buffers".
      Processes  which have died only appear once in this list before completely
      disappearing.


 process-filter-name [unbound]:   Returns  the  name  of  the  filter  procedure
      attached to some buffer.


 process-id  [unbound]:   Returns the process id of the process attached to some
      buffer.


 process-output [unbound]:  (process-output)  --  Can  only  be  called  by  the
      on-output-procedure  to  procure the output generated by the process whose
      name is given by MPX-process. Returns the output as a string.


 process-status [unbound]:  (process-status "process-name")  --  Returns  -1  if
      "process-name"  isn't a process, 0 if the process is stopped, and 1 if the
      process is running.
36


quit-process [unbound]:  (quit-process "process-name") -- Send a quit signal to
   the process.


region-to-process  [unbound]:  (region-to-process "process-name") -- The region
   is wrapped up and sent to the process.


Variable silently-kill-processes:  If ON Emacs  will  kill  processes  when  it
   exits  without  asking  any  questions.    Normally, if you have processes
   running when Emacs exits, the question "You have processes on  the  prowl,
   should I hunt them down for you" is asked.  (default OFF)


start-filtered-process  [unbound]:   (start-filtered-process "command" "buffer-
   name" "on-output-procedure") --  Does  the  same  thing  as  start-process
   except   that   things   are  set  up  so  that  "on-output-procedure"  is
   automatically called whenever output has been received from this  process.
   This  procedure can access the name of the process producing the output by
   refering to the variable MPX-process, and can retrieve the  output  itself
   by calling the procedure process-output.

          The  filter  procedure  must  be  careful  to avoid generating
        side-effects (eg. search-forward).  Moreover, if it attempts  to
        go  to the terminal for information, output from other processes
        may be lost.


start-process [unbound]:  (start-process "command" "buffer-name") --  The  home
   shell  is  used to start a process executing the command.  This process is
   tied to the buffer "buffer-name" unless it  is  null  in  which  case  the
   "Command   execution"  buffer  is  used.    Output  from  the  process  is
   automatically attached to the end of the buffer.  Each time this is  done,
   the  mark  is  left  at  the  end  of  the output (which is the end of the
   buffer).


stop-process [unbound]:  (stop-process "process-name") -- Tell the  process  to
   stop by sending it a stop signal.  Use continue-process to carry on.


string-to-process   [unbound]:    (string-to-process  "process-name"  "string")
   -- The string is sent to the process.


18.1. Blocking
When too many characters are sent to a process in one gulp, the send will  be
blocked  until  the  process has removed sufficient characters from the buffer.
The send will then be  automatically  continued.    Normally  this  process  is
invisible to the Emacs user, but if the process has been stopped, the send will
not  be unblocked and further attempts to send to the process will result in an
overwrite error message.
                                                                              37


 18.2. Buffer Truncation
   Emacs  does  not allow process buffers to grow without bound.  When a process
 buffer exceeds the value of the variable  process-buffer-size,  500  characters
 are  erased  from  the  beginning  of  the  buffer.    The  default  value  for
 process-buffer-size is 10,000.

 18.3. Problems
   The most obvious problem with allowing multiple interactive processes is that
 it is too easy to start up useless jobs which drag everyone down.    Also  when
 checkpointing   is   done,  all  buffers  including  the  process  buffers  are
 checkpointed.  So if you have a one line buffer keeping time, it will take more
 system time to checkpoint it than it will to keep it updated once a minute.

   In addition to anti-social problems, there are some real bugs remaining:

    - Sometimes when  starting  a  process,  it  will  inexplicably  expire
      immediately.  This often happens to the first process you fire up.

    - Subprocesses  are  assumed  to  not want to try fancy things with the
      terminal.  Emacs doesn't know how to handle this and for now more  or
      less  ignores  stty  requests  from  processes.   This means that csh
      cannot be used from within Emacs.  Running  chat  and  ftp  can  also
      cause problems.  Someday, Emacs should try to handle stty's.

    - The  worst problem is that background processes started outside Emacs
      will cause Emacs to hang when they finally finish.   This  might  get
      fixed if I want to think about it.

    - If  Emacs  does crash or hang, you will find several orphan processes
      left hanging around.  It is best to do a ps and get rid of them.
38


19. The Emacs database facility
Unix  Emacs provides a set of commands for dealing with databases of a rather
primitive form.  These databases are intended to be used in help facilities  to
find  documentation for a given keyword, but they have many other uses: managed
mailboxes or nodes in an info tree.

A database is a set of (key, content) pairs which may be retrieved or  stored
based  on  the  key.   Both the key and the content may be arbitrary strings of
characters.  The content may  be  long,  but  there  are  restrictions  on  the
aggragate length of the keys.

A  database search list is a list of databases.  When a key is looked up in a
database search list the databases in the search list are examined in order for
one containing the key.  The  content  corresponding  to  the  first  key  that
matches  is returned.  When a key is to have its content changed only the first
database in the search list is used.

The commands available for dealing with databases are:


extend-database-search-list  [unbound]:    (extend-database-search-list  dbname
   filename)  adds  the  given  data  base  file to the data base search list
   (dbname).  If the database is already in the search list then it is  left,
   otherwise  the  new  database  is  added  at  the beginning of the list of
   databases.


fetch-database-entry [unbound]:  (fetch-database-entry dbname  key)  takes  the
   entry  in the data base corresponding to the given key and inserts it into
   the current buffer.


list-databases [unbound]:  (list-databases) lists all data base search lists.


put-database-entry  [unbound]:    (put-database-entry  dbname  key)  takes  the
   current buffer and stores it into the named database under the given key.


There  are  four  Unix  commands  provided  for dealing with Emacs data bases
(these are commands that you give to the shell, not Emacs):

 1. dbadd -- add entry to an Emacs data base 

        dbadd dbname key

 2. dbcreate -- create an Emacs data base 

        dbcreate dbname

 3. dblist -- list contents of an Emacs data base 
                                                                              39


           dblist dbname [ -l ] [ -p ] newdbname

    4. dbprint -- print an entry from an Emacs data base 

           dbprint dbname key

   Dbadd  adds  the text from the standard input to the named database using the
 given key.  Dbcreate creates the named database,  making  it  empty.    Dbprint
 prints the contents of the entry from the database with the given key.

   Dblist  with  no  arguments  simply  lists  the  keys of all the items in the
 database.  With the -l option it prints  some  internal  information  from  the
 database  of  no  interest to anyone but the implementor.  The -p option causes
 the key and content of every entry to be listed as a shell command  file  which
 when  executed will repeatedly invoke dbadd to rebuild the database.  This form
 of dblist is handy when you want a readable ascii file representation of a data
 base  for  shipping  around  or  editing.    Databases  should   be   recreated
 periodically to garbage collect them.
40


20. Packages
This  chapter  contains a description of a few of the packages that have been
written  for  Emacs  in   MLisp.      To   load   some   package,   just   type
``ESC-X  load  PackageName''.  The title of each following section contains the
name of the package before the `--'.

20.1. buff -- one-line buffer list
Loading  the  buff  package  replaces  the   binding   for   ^X-^B   (usually
list-buffers) with one-line-buffer-list.

one-line-buffer-list
              Gives a one-line buffer list in the mini-buffer.  If the buffer
              list  is  longer  than one line, it will print a line at a time
              and wait for a character to be typed before moving to the  next
              line.    Buffers  that  have  been changed since they were last
              saved are prefixed  with  an  asterisk  (*),  buffers  with  no
              associated  file  are  prefixed with a hash-mark (#), and empty
              buffers are prefixed with an at-sign (@).

20.2. c-mode -- simple assist for C programs

begin-C-comment(ESC-`) Initiates the typing in of a comment.  Moves the cursor
              over to  the  comment  column,  inserts  "/*  "  and  turns  on
              autofill.    If  ESC-`  is  typed  in the first column, the the
              comment  begins  there,  otherwise   it   begins   where   ever
               comment-column says it should.

end-C-comment (ESC-') Closes off the current comment.

indent-C-procedure
              (ESC-j)  Takes  the  current function (the one in which dot is)
              and fixes up its indentation by running it through the "indent"
              program.

20.3. dired -- directory editor
The dired package implements the dired command  which  provides  some  simple
convenient  directory  editing  facilities.  When you run dired it will ask for
the name of a directory, displays a listing of it in a  buffer,  and  processes
commands  to  examine  files  and possibly mark them for deletion.  When you're
through with dired it actually deletes  the  marked  files,  after  asking  for
confirmation.  The commands it recognizes are:

d             Marks  the current file for deletion.  A `D' will appear at the
              left margin.  It does not actually delete  the  file,  it  just
              marks it.  The deletion will be performed when dired is exited.
              It also makes the next file be the current one.

u             Removes  the  deletion mark from the current file.  This is the
              command to use if you change your mind about deleting  a  file.
              It also makes the next file be the current one.

RUBOUT        Removes  the deletion mark from the line preceeding the current
                                                                              41


                 one.  If you mark a file for deletion with `d' the current file
                 will  be  advanced  to  the  next line.  RUBOUT undoes both the
                 advancing and the marking for deletion.

 e, v            Examine a file put putting it in another  window  and  doing  a
                 recursive-edit on it.  To resume dired type ^C.

 r               Removes  the  current  file  from  the  directory  listing.  It
                 doesn't delete the file, it just  gets  rid  of  the  directory
                 listing  entry.    Use it to remove some of the clutter on your
                 screen.

 q, ^C           Exits dired.  For each file that has been marked  for  deletion
                 you will be asked for confirmation.  If you answer `y' the file
                 will be deleted, otherwise not.

 n, ^N           Moves to the next entry in the directory listing.

 p, ^P           Moves to the previous entry in the directory listing.

 ^V              Moves to the next page in the directory listing.

 ESC-v           Moves to the previous page in the directory listing.

 ESC-<           Moves to the beginning of the directory listing.

 ESC->           Moves to the end of the directory listing.

 20.4. goto -- go to position in buffer

 goto-line       Moves  the  cursor to beginning of the indicated line. The line
                 number is taken from the prefix argument if it is provided,  it
                 is prompted for otherwise.  Line numbering starts at 1.

 goto-percent    Moves  dot  to  the  indicated  percentage  of  the buffer. The
                 percentage is taken from the prefix argument if it is provided,
                 it is prompted for otherwise.  (goto-percent  n)  goes  to  the
                 character that is n% from the beginning of the buffer.

 20.5. incr-search -- ITS style incremental search
   ITS  Emacs  has  a  the  search  command  that  is  unusual  in  that  it  is
 "incremental"; it begins to search before you have finished typing  the  search
 string.  As  you  type  in the search string, Emacs shows you where it would be
 found.  When you have typed enough characters to identify the place  you  want,
 you  can  stop.  The incr-search package perfectly emulates this in Unix Emacs.
 Typically one binds incremental-search to ^S and reverse-incremental-search  to
 ^R.

   The command to search is ^S (incremental-search).  ^S reads in characters and
 positions  the  cursor  at the first occurrence of the characters that you have
 typed.  If you type ^S and then F, the cursor moves right after the first  "F".
 Type  an  "O",  and see the cursor move to after the first "FO".  After another
42


"O",  the cursor is after the first "FOO" after the place where you started the
search.  At the same time, the "FOO" has echoed at the bottom of the screen.

If you type a mistaken character, you can rub it out.  After the FOO,  typing
a  rubout  makes  the "O" disappear from the bottom of the screen, leaving only
"FO".  The cursor moves back to the "FO".  Rubbing out the "O"  and  "F"  moves
the cursor back to where you started the search.

When  you are satisfied with the place you have reached, you can type an ESC,
which stops searching, leaving the cursor where the search brought it.    Also,
any  command  not  specially  meaningful in searches stops the searching and is
then executed.  Thus, typing ^A would exit the search  and  then  move  to  the
beginning  of  the line.  ESC is necessary only if the next command you want to
type is a printing character, Rubout, ESC  or  another  search  command,  since
those are the characters that would not exit the search.

Sometimes  you  search for "FOO" and find it, but not the one you expected to
find.  There was a second FOO that you forgot about, before the  one  you  were
looking for.  Then type another ^S and the cursor will find the next FOO.  This
can  be  done any number of times.  If you overshoot, you can rub out the ^S's.
You can also repeat the search after exiting it, if the first  thing  you  type
after entering another search (when the argument is still empty) is a ^S.

If  your  string  is not found at all, the echo area says "Failing I-Search".
The cursor is after the place where Emacs found as much of your  string  as  it
could.    Thus, if you search for FOOT, and there is no FOOT, you might see the
cursor after the FOO in FOOL.  At this point there are several things  you  can
do.    If  your string was mistyped, you can rub some of it out and correct it.
If you like the place you have found, you can type  ESC  or  some  other  Emacs
command  to "accept what the search offered".  Or you can type ^G, which throws
away the characters that could not be found (the "T" in "FOOT"), leaving  those
that  were  found  (the "FOO" in "FOOT").  A second ^G at that point undoes the
search entirely.

The ^G "quit" command does special things during searches; just what, depends
on the status of the search.  If the search has found what you specified and is
waiting for input, ^G cancels the entire search.   The  cursor  moves  back  to
where  you  started  the  search.   If ^G is typed while the search is actually
searching for something or updating the display, or after search failed to find
some of your input (having searched all the way to the end of the  file),  then
only  the characters which have not been found are discarded.  Having discarded
them, the search is now successful and waiting for more input, so a  second  ^G
will cancel the entire search.  Make sure you wait for the first ^G to ding the
bell  before  typing  the  second  one; if typed too soon, the second ^G may be
confused with the first and effectively lost.

You can also type ^R at any time to start searching backwards.  If  a  search
fails  because  the  place  you started was too late in the file, you should do
this.  Repeated ^R's keep looking for more occurrences backwards.  A ^S  starts
going  forwards again.  ^R's can be rubbed out just like anything else.  If you
know that you want to search backwards, you can use ^R instead of ^S  to  start
the search, because ^R is also a command (reverse-incremental-search) to search
                                                                              43


 backward.

 20.6. info -- documentation reader
   Info  is a system which lets you browse through the documentation for various
 systems.  In particular,  all  the  Emacs  documentation  is  available  online
 through it.  Both the describe-command and describe-variable functions use it.

   Rather  than  document  Info extensivly here, I suggest that you run Info and
 use it to describe itself.

 20.7. occur -- find occurances of a string
   The occur package allows one to find the occurances of a string in a  buffer.
 It contains one function

 Occurances      When  invoked,  prompts  with "Search for all occurances of: ".
                 It then lists (in a new buffer) all lines  contain  the  string
                 you type following dot.  Possible options (listed at the bottom
                 of  the screen) allow you to page through the listing buffer or
                 abort the function.

   In addition, a global variable controls the action of the function:

 &Occurances-Extra-Lines
                 is a global variable that controls how many  extra  surrounding
                 lines are printed in addition to the line containing the string
                 found.    If  this  variable  is 0 then NO additional lines are
                 printed.  If this variable is greater than 0 then it will print
                 that many lines above and below the line on  which  the  string
                 was  found.  When printing more than one line per match in this
                 fashion, it will also print a seperator  of  '----------------'
                 so  you can tell where the different matches begin and end.  At
                 the end of the buffer it prints '<<<End of Occur>>>'.

 20.8. process -- high level process manipulation
   The process package  provides  high  level  access  to  the  process  control
 features  of  Unix  Emacs.    It allows you to interact with a shell through an
 Emacs window, just as though you were talking to the shell normally.

 shell           The shell command is used to either start or  reenter  a  shell
                 process.    When  the  shell  command  is  executed, if a shell
                 process doesn't exist then one is created (running the standard
                 ``sh'') tied to a buffer named ``shell'.    In  any  case,  the
                 shell  buffer  becomes the current one and dot is positioned at
                 the end of it.  In  that  buffer  output  from  the  shell  and
                 programs  run with it will appear.  Anything typed into it will
                 get sent to the subprocess when the return key is struck.  This
                 lets you interact with a shell using Emacs,  and  all  of  it's
                 editing  capability,  as  an  intermediary.    You  can  scroll
                 backwards over a session, pick up pieces  of  text  from  other
                 places and use them as input, edit while watching the execution
                 of some program, and much more...
44


lisp          The  lisp  command  is  exactly  the  same as the shell command
              except that it starts up ``cmulisp'' in  the  ``lisp''  buffer.
              You  can have both a shell and a lisp process going at the same
              time.  You can even have as many shells going as you want,  but
              this package doesn't support it.

grab-last-line(ESC-=)  This  command  takes the last string typed as input to
              the process and brings it back, as  though  you  had  typed  it
              again.  So  if  you  muff  a command, just type ESC-=, edit the
              line, and hit return again.

lisp-kill-output
              (^X^K) [this only applies to lisp processes] Erases the  output
              from  the last command.  If you don't want to see the output of
              the last command any more, just type ^X^K and it will go away.

pr-newline    (^M -- return) Takes the text of the current line and sends  it
              as  input to the process tied to the current buffer.  Actually,
              if dot is on the last line of the buffer, it takes  the  region
              from  mark  to  the  end  of  the  buffer and sends it as input
              (output from a process causes the mark  to  be  set  after  the
              inserted  text);  if dot is not on the last line, just the text
              of that line is shipped (presuming that your prompt is "$ ").

send-eot      (^D) If dot is at the end of the buffer, then ^D  behaves  just
              as  it  does  outside  of  Emacs  --  it  sends  an  EOT to the
              subprocess (end of file to some folks).  If dot  isn't  at  the
              end of the buffer, then it does the usual character deletion.

send-int-signal(\177  --  rubout)  Sends  an  INT  (Interrupt)  signal  to the
              subprocess, which should make it stop whatever it is doing.

send-quit-signal
              (^\) Sends a QUIT signal to  the  subprocess,  making  it  stop
              whatever it is doing and produce a core dump.

20.9. pwd -- print and change the working directory

pwd           Prints  the  current  working  directory in the mode line, just
              like the shell command ``pwd''.

cd            Changes the current working  directory,  just  like  the  shell
              command  ``cd''.    You  should beware that cd only changes the
              current directory for  Emacs,  if  it  has  already  spawned  a
              subprocess  (a  shell, for example) then a cd from within Emacs
              has no effect on the shell.

20.10. rmail -- a mail management system
Emacs may be used to send and receive electronic mail.    The  rmail  command
(Usually  invoked  as "ESC-Xrmail") is used for reading mail, smail is used for
sending mail.
                                                                              45


 20.10.1. Sending Mail
   When  sending  mail,  either by using the smail command or from within rmail,
 Emacs constructs a buffer that contains an outline of the message  to  be  sent
 and allows you to edit it. All that you have to do is fill in the blanks.  When
 you  exit  from  smail (by typing ^C usually -- when you're editing the message
 body you will be  in  a  recursive-edit)  the  message  will  be  sent  to  the
 destinations  and  blindcopied  to you.  Several commands are available to help
 you in composing the message:

 justify-paragraph
                 (ESC-j) Fixes up the  line  breaks  in  the  current  paragraph
                 according to the current left and right margins.

 exit-emacs      (^C)  Exits mail composition and attempts to send the mail.  If
                 all goes well the mail composition window will disappear and  a
                 confirmation  message  will appear at the bottom of the screen.
                 If there is some sort of delivery error you will be placed back
                 into the composition window and a message will  appear.    Bug:
                 when  delivery  is  attempted  and  there  are  errors  in  the
                 delivery,  the  message  will  have  been  delivered   to   the
                 acceptable  addresses  and  not  to  the  others.    This makes
                 retrying the message  difficult  since  you  have  to  manually
                 eliminate  the  addresses to which the message has already been
                 sent.

 mail-abort-send (^X^A)  Aborts  the  message.    If  you're  part-way   through
                 composing  a message and decide that you don't want to send it,
                 ^X^A will throw it away, after asking for confirmation.

 mail-noblind-exit
                 (^X^C) Exits smail and send  the  message,  just  as  ^C  will,
                 except that a blind copy of the message will not be kept.

 exit-emacs      (^X^F) Same as ^C.

 exit-emacs      (^X^S) Same as ^C.

 mail-append     (^Xa) Positions dot at the end of the body and sets margins and
                 abbrev tables appropriatly.

 mail-cc         (^Xc)  Positions  dot  to  the  "cc:"  field,  creating  it  if
                 necessary.

 mail-insert     (^Xi) Inserts the body of the message that  was  most  recently
                 looked  at  with  rmail  into  the  body  of  the message being
                 composed.  If, for instance, what you want to do is  forward  a
                 message  to  someone,  just  read  the message with rmail, then
                 compose a message to the person you want  to  forward  to,  and
                 type ^Xi.

 mail-subject    (^Xs) Positions dot to the "subject:" field of the message.
46


mail-to       (^Xt) Positions dot to the "to:" field of the message.



20.10.2. Reading Mail
The  rmail  command  provides  a facility for reading mail from within Emacs.
When it is running there are usually two windows on the  screen:  one  shows  a
summary  of  all  the  messages  in  your  mailbox  and  the other displays the
``current'' message.  The summary window may contain something like this:

  02621525335022 29 Oct 1981  research!dmr    [empty]
B 02621525335030 29 Oct 1981  =>Unix-Wizards  A plea for understanding
  02621525335040 31 Oct 1981  CSVAX.dmr       rc etymology
  02621525335072 3 Nov 1981   EHF             fyi
A  02621352421000 3 Nov 1981   JIM             copyrights
B 02621353040000 3 Nov 1981   =>JIM           Re: copyrights
  02621646433000 [empty]      [empty]         [empty]
B 02621647417000 4 Nov 1981   =>research!ikey Emacs
>N  02622024522003 5 November   flaco           cooking class

This is broken into five columns, as indicated by the underlining.

 - The first column contains  some  flags:  '>'  indicates  the  current
   message, 'B' indicates that the message is a blindcopy (ie. A copy of
   a  message  that you sent to someone else), 'A' indicates that you've
   answered the message, and 'N' indicates that the message is new.

 - The second column contains a long string of digits that  is  internal
   information for the mail system.

 - The third contains the date on which the mail was sent.

 - The  forth  contains  the  sender  of  the  message,  unless  it is a
   blindcopy, in which case it contains the  destination  (indicated  by
   the "=>").

 - The fifth column contains the subject of the message.

When in the summary window Rmail responds to the following commands:

rmail-shell   (!)  Puts you into a command shell so that you can execute Unix
              commands.  Resume mail reading by typing ^C.

execute-extended-command
              (:)  An  emergency  trap-door  for  executing  arbitrary  Emacs
              commands.  You should never need this.

rmail-first-message
              (<) Look at the first message in the message file.

rmail-last-message
              (>) Look at the last message in the message file.
                                                                              47


 rmail-help      (?) Print a very brief help message

 exit-emacs      (^C) Leave rmail.  Changes marked in the message file directory
                 (eg. deletions) will be made.

 rmail-search-reverse
                 (^R)  Prompts  for  a  search string and positions at the first
                 message, scanning in reverse, whose  directory  entry  contains
                 the string.

 rmail-search-forward
                 (^S)  Prompts  for  a  search string and positions at the first
                 message, scanning forward, whose directory entry  contains  the
                 string.

 rmail-append    (a) Append the current message to a file.

 rmail-previous-page
                 (b)  Moves  backward  in  the  window that contains the current
                 message.

 rmail-delete-message
                 (d) Flag the current message for deletion.  It  won't  actually
                 be deleted until you leave rmail.

 rmail-next-page (f)  Moves  forward  in  the  window  that contains the current
                 message.  To read a message that is longer than the window that
                 contains it, just  keep  typing  f  and  rmail  will  show  you
                 successive pages of it.

 rmail-goto-message
                 (g) Moves to the nth message.

 smail           (m) Lets you send some mail.

 rmail-next-message
                 (n) Moves to the next message.

 rmail-previous-message
                 (p) Moves to the previous message.

 exit-emacs      (q) the same as ^C

 rmail-reply     (r) Constructs a reply to the current message.

 rmail-skip      (s) Moves to the nth message relative to this one.

 rmail-undelete-message
                 (u)  If  the current message was marked for deletion, u removes
                 that mark.
48


20.11. scribe -- weak assistance for dealing with Scribe documents
Scribe  mode  binds justify-paragraph to ESC-j, defines appply-look and binds
it to ESC-l, turns on autofill, sets the right margin to  77  and  updates  the
LastEditDate to the current date.

If   the  string  ``LastEditDate="''  exists  somewhere  in  the  first  2000
characters of the document then then the region extending from it to  the  next
`"' is replaced by the current date and time.  You're intended to stick in your
document something like:  

  @String(LastEditDate="Sat Nov 28 11:17:29 1981")

Emacs  will  automatically maintain the date.  The date will only change in the
file you make some changes, the mere act of starting scribe-mode does not cause
the date change to be permanent.

Apply-look reads a single character and then surrounds the current word  with
``@c[''  and  ``]''.    So, if you've just typed ``begin'', typing ESC-l-i will
change it to ``@i[begin]'', which appears in the document as ``begin''.    This
use of the word ``look'' comes from the Bravo text editor.

20.12. scribe-bib -- Scribe bibliography creation mode
Scribe-bib  mode  provides a set of functions that create Scribe bibliography
database entries.  For  each  bibliography  type  scribe-bib  mode  provides  a
function  that  when  executed  prompts  the  user  for  appropriate fields and
constructs a new entry of the proper type. The name of each of these  functions
is  identical  to  the  name  of the corresponding bibliography type.  Once the
entry is created  it  can  be  edited  using  standard  Emacs  commands.    The
bibliography  creation functions are invoked by name using ESC-X and are listed
below:

@article       Create an @Article bibliography entry.

@book          Create an @Book bibliography entry.

@booklet       Create an @Booklet bibliography entry.

@inbook        Create an @InBook bibliography entry.

@incollection  Create an @InCollection bibliography entry.

@inproceedings Create an @InProceedings bibliography entry.

@manual        Create an @Manual bibliography entry.

@mastersthesis Create an @MastersThesis bibliography entry.

@misc          Create an @Misc bibliography entry.

@phdthesis     Create an @PhdThesis bibliography entry.

@proceedings   Create an @Proceedings bibliography entry.
                                                                              49


 @techreport      Create an @TechReport bibliography entry.

 @unpublished     Create an @Unpublished bibliography entry.

 20.13. spell -- a simple spelling corrector
   The spell package implements the single function spell.  It provides a simple
 facility  for doing spelling correction.  If you invoke spell it will scan your
 file looking for spelling errors, then it will go through a dialogue to let you
 fix them up.  For each misspelled word Emacs  will  show  you  the  word,  some
 context around it and ask you what to do.  If you type `e' or `^G' the spelling
 corrector will exit.  If you type ` ' it will ignore the word.  If you type `r'
 it  will  ask  for  the  text  to  use  in  replacing  the  word  and perform a
 query-replace.  Bug: This uses the Unix spell command which believes  that  its
 input  is  a  source  for  the  Unix standard text formatter troff/nroff; Spell
 misbehaves on Scribe .mss files.

 20.14. tags -- a function tagger and finder
   The tags package closely resembles the tags package found  in  Twenex  Emacs.
 The  database  used  by  the tag package (called a tagfile) correlates function
 definitions to the file in which the definitions appear.  The primary  function
 of  the tag package is to allow the user to specify the name of a function, and
 then have  Emacs  locate  the  definition  of  that  function.    The  commands
 implemented are:

 add-tag         Adds  the  current  line  (it should be the definition line for
                 some function) to the current tagfile.

 goto-tag         goto-tag takes a single string argument which is  usually  the
                 name of a function and visits the file containing that function
                 with  the  first line of the function at the top of the window.
                 The string may actually be a substring  of  the  function  name
                 (actually,  any  substring  of  the  first line of the function
                 definition).  If goto-tag is  given  a  numeric  argument  then
                 rather  than asking for a new string it will use the old string
                 and search for the  next  occurrence  of  that  string  in  the
                 tagfile.   This is used for stepping through a set of tags that
                 contain the same string.

                 This is the most commonly used command in the tag package so it
                 is often bound to a key: Twenex Emacs binds it  to  ESC-.,  but
                 the  Unix  tag package doesn't bind it to anything, it presumes
                 that the user will bind it (I use ^X^G).

 make-tag-table  Takes a list of file names (with wildcards allowed) and  builds
                 a  tagfile  for  all  the  functions  in  all of the files.  It
                 determines the language of the contents of the  file  from  the
                 extension.  This command may take a while on large directories,
                 be  prepared  to wait.  A common use is to type "make-tag-table
                 *.c".

 recompute-all-tags
                 Goes through your current tag file and for each file  mentioned
50


              refinds all of the tags.  This is used to rebuild an entire tag
              file  if  you've  made  very  extensive  changes  to  the files
              mentioned and the  tag  package  is  no  longer  able  to  find
              functions.    The  tagfile  contains  hints  to help the system
              locate the tagged function, as you make changes to the  various
              files  the  hints  become  out  of  date.  Periodically (no too
              often!) you should recompute the tagfile.

visit-functionTakes the function name at or before dot, does  a  goto-tag  on
              that  name,  then puts you into a recursive-edit to look at the
              function definition.  To get back to where you were, just  type
              ^C.    This  is  used  when  you're editing something, have dot
              positioned at some function invocation, then want  to  look  at
              the function.

visit-tag-tableNormally  the  name  of  the  tagfile is ".tags" in the current
              directory.    If  you  want  to   use   some   other   tagfile,
              visit-tag-table lets you do that.

20.15. text-mode -- assist for simple text entry
Implements  the  text-mode  command which ties ESC-j to justify-paragraph and
sets up autofill with a left margin of 1 and a right margin of 77.

20.16. time -- a mode line clock
This package only implements one user-visible function, time, which puts  the
current  time of day and load average (continuously updating!) in the mode line
of each  window.    It  uses  global-mode-string  and  the  subprocess  control
facility.  Major!

20.17. undo -- undo previous commands
The  new-undo  command,  which  is  usually  bound to ^X^U allows the user to
interactively undo the effects of previous commands.  Typing  ^X^U  undoes  the
effects  of  the  last  command  typed.  It will then ask ``Hit <space> to undo
more'', each <space> that you then hit will undo  one  more  command.    Typing
anything  but  space will terminate undoing.  If it is terminated with anything
other than <return> the termination character will be executed just  as  though
it  were  a  normal  command.    new-undo is an undoable command, just like the
others, so if you find that you've undone too much just type ^X^U again to undo
the undo's.

20.18. writeregion -- write region to file
This package only implements one function, write-region-to-file, which  takes
the region between dot and mark and writes it to the named file.
                                                                              51


 21. Command Description
   This  chapter describes (in alphabetical order) all of the commands which are
 defined in the basic Unix Emacs system.   Other  commands  may  be  defined  by
 loading packages.  Each description names the command and indicates the default
 binding.


 !                                                                     [unbound]
   (! e ) MLisp function that returns not e .
       1                                   1

 !=                                                                    [unbound]
   (!= e  e ) MLisp function that returns true iff e  != e .
        1  2                                        1     2

 %                                                                     [unbound]
   (% e  e ) MLisp function that returns e  % e  (the C mod operator).
       1  2                               1    2

 &                                                                     [unbound]
   (& e  e ) MLisp function that returns e  & e .
       1  2                               1    2

 *                                                                     [unbound]
   (* e  e ) MLisp function that returns e  * e .
       1  2                               1    2

 +                                                                     [unbound]
   (+ e  e ) MLisp function that returns e  + e .
       1  2                               1    2

 -                                                                     [unbound]
   (- e  e ) MLisp function that returns e  - e .
       1  2                               1    2

 /                                                                     [unbound]
   (/ e  e ) MLisp function that returns e  / e .
       1  2                               1    2

 <                                                                     [unbound]
   (< e  e ) MLisp function that returns true iff e  < e .
       1  2                                        1    2

 <<                                                                    [unbound]
   (<< e  e ) MLisp function that returns e  << e  (the C shift left operator).
        1  2                               1     2
52


<=                                                                  [unbound]
(<= e  e ) MLisp function that returns true iff e  <= e .
     1  2                                        1     2

=                                                                   [unbound]
(= e  e ) MLisp function that returns true iff e  = e .
    1  2                                        1    2

>                                                                   [unbound]
(> e  e ) MLisp function that returns true iff e  > e .
    1  2                                        1    2

>=                                                                  [unbound]
(>= e  e ) MLisp function that returns true iff e  >= e .
     1  2                                        1     2

>>                                                                  [unbound]
(>> e  e ) MLisp function that returns e  >> e  (the C shift right operator).
     1  2                               1     2

^                                                                   [unbound]
(^ e  e ) MLisp function that returns e  ^ e  (the C XOR operator).
    1  2                               1    2

active-process                                                      [unbound]
(active-process)  -- Returns the name of the active process as defined in the
section describing the process mechanism.


append-region-to-buffer                                             [unbound]
Appends the region between dot and mark to the named  buffer.    Neither  the
original  text in the destination buffer nor the text in the region between dot
and mark will be disturbed.


append-to-file                                                      [unbound]
Takes the contents of the current buffer and appends it to  the  named  file.
If the files doesn't exist, it will be created.


apropos                                                                 ESC-?
Prompts  for  a  keyword and then prints a list of those commands whose short
description contains that keyword.  For example, if you forget  which  commands
deal with windows, just type "ESC-?windowESC".
                                                                              53


 arg                                                                   [unbound]
   (arg  i  [prompt]) evaluates to the i'th argument of the invoking function or
 prompts for it if called interactively  [the  prompt  is  optional,  if  it  is
 omitted, the function cannot be called interactivly]. For example, 

     (arg 1 "Enter a number: ")

 Evaluates  to  the  value of the first argument of the current function, if the
 current function was called from MLisp.  If it was called interactively then it
 is prompted for. As another example, given:  

     (defun (foo (+ (arg 1 "Number to increment? ") 1)))

 then (foo 10) returns 11, but typing "ESC-Xfoo" causes emacs to ask "Number  to
 increment?  ".   Language purists will no doubt cringe at this rather primitive
 parameter mechanism, but what-the-hell...  it's amazingly powerful.


 argc                                                                  [unbound]
   Is an MLisp function that returns the number of arguments that were passed to
 Emacs when it was invoked from the Unix shell.  If  either  argc  or  argv  are
 called  early enough then Emacs's startup action of visiting the files named on
 the command line is suppressed.


 argument-prefix                                                              ^U
   When followed by a string of digits ^U causes that string  of  digits  to  be
 interpreted as a numeric argument which is generally a repetition count for the
 following  command.   For example, ^U10^N moves down 10 lines (the 10'th next).
 A string of n ^U's followed by a command provides an argument to  that  command
      n
 of  4 .    For  example,  ^U^N moves down four lines, and ^U^U^N moves down 16.
 Argument-prefix should never be called from an MLisp function.


 argv                                                                  [unbound]
   (argv i) returns the ith argument that  was  passed  to  Emacs  when  it  was
 invoked  from  the  Unix  Shell.   If Emacs were invoked as "emacs blatto" then
 (argv 1) would return the string "blatto".  If either argc or argv  are  called
 early  enough  then  Emacs's  startup action of visiting the files named on the
 command line is suppressed.


 auto-execute                                                          [unbound]
   Prompt for and remember a command name and a file name pattern.  When a  file
 is read in via visit-file or read-file whose name matches the given pattern the
 given  command  will  be executed.  The command is generally one which sets the
 mode for the buffer.  Patterns must be of  the  form  "*string"  or  "string*":
 "*string"  matches any filename whose suffix is "string"; "string*" matches any
 filename prefixed by "string".  For example, auto-execute c-mode *.c  will  put
 Emacs into C mode for all files with the extension ".c".
54


autoload                                                            [unbound]
(autoload  command file) defines the associated command to be autoloaded from
the named file.  When an attempt to execute the  command  is  encountered,  the
file  is  loaded and then the execution is attempted again.  the loading of the
file must have redefined the command.  Autoloading is useful when you have some
command written in MLisp but you don't want to have the code loaded  in  unless
it  is  actually needed.  For example, if you have a function named box-it in a
file named box-it.ml, then the command  (autoload  "box-it"  "box-it.ml")  will
define  the  box-it command, but won't load its definition from box-it.ml.  The
loading will happen when you try to execute the box-it command.


backward-balanced-paren-line                                        [unbound]
Moves dot backward until either

 - The beginning of the buffer is reached.

 - An unmatched  open  parenthesis,  '(',  is  encountered.    That  is,
   unmatched between there and the starting position of dot.

 - The  beginning  of a line is encountered at "parenthesis level zero".
   That is, without an unmatched ')'  existing  between  there  and  the
   starting position of dot.

The  definitions  of  parenthesis  and  strings  from  the syntax table for the
current buffer are used.


backward-character                                                         ^B
Move dot backwards one character. Ends-of-lines and tabs each  count  as  one
character.  You can't move back to before the beginning of the buffer.


backward-paragraph                                                      ESC-[
Moves  to  the  beginning of the current or previous paragraph.  Blank lines,
and Scribe and nroff command lines separate paragraphs and  are  not  parts  of
paragraphs.


backward-paren                                                      [unbound]
Moves dot backward until an unmatched open parenthesis, '(', or the beginning
of  the  buffer  is  found.    This  can  be  used to aid in skipping over Lisp
S-expressions.  The definitions of parenthesis  and  strings  from  the  syntax
table for the current buffer are used.
                                                                              55


 backward-sentence                                                         ESC-A
   Move  dot  backward to the beginning of the preceeding sentence; if dot is in
 the middle of a sentence, move  to  the  beginning  of  the  current  sentence.
 Sentences are seperated by a `.', `?' or `!' followed by whitespace.


 backward-word                                                             ESC-B
   If in the middle of a word, go to the beginning of that word, otherwise go to
 the beginning of the preceding word.  A word is a sequence of alphanumerics.


 baud-rate                                                             [unbound]
   An  MLisp  function  that  returns  what Emacs thinks is the baud rate of the
 communication line to the terminal.  The baud rate is (usually)  10  times  the
 number  of characters transmitted ber second.  (Baud-rate) can be used for such
 things as conditionally setting the display-file-percentage  variable  in  your
 Emacs profile:  (setq display-file-percentage (> (baud-rate) 600)) 


 beginning-of-file                                                         ESC-<
   Move dot to just before the first character of the current buffer.


 beginning-of-line                                                            ^A
   Move  dot  to  the  beginning of the line in the current buffer that contains
 dot; that is, to just after the preceeding end-of-line or the beginning of  the
 buffer.


 beginning-of-window                                                       ESC-,
   Move  dot to just in front of the first character of the first line displayed
 in the current window.


 bind-to-key                                                           [unbound]
   Bind a named macro or procedure to a given key.  All future hits on  the  key
 will cause the named macro or procedure to be called.  The key may be a control
 key,  and  it  may be prefixed by ^X or ESC.  For example, if you want ESC-= to
 behave the way ESC-Xprint does, then typing ESC-Xbind-to-key print  ESC-=  will
 do it.


 bobp                                                                  [unbound]
   (bobp) is an MLisp predicate which is true iff dot is at the beginning of the
 buffer.
56


bolp                                                                [unbound]
(bolp)  is  an MLisp predicate which is true iff dot is at the beginning of a
line.


buffer-size                                                         [unbound]
(buffer-size) is an MLisp function that returns the number of  characters  in
the current buffer.


c-mode                                                              [unbound]
Incompletely implemented.


c=                                                                  [unbound]
(c= e  e ) MLisp function that returns true iff e  is equal to e  taking into
     1  2                                        1              2
account   the   character  translations  indicated  by  case-fold-search.    If
word-mode-search is in effect, then upper case letters are "c=" to their  lower
case equivalents.


case-region-capitalize                                              [unbound]
Capitalize  all  the words in the region between dot and mark by making their
first characters upper case and all the rest lower case.


case-region-invert                                                  [unbound]
Invert the case of all alphabetic characters in the region  between  dot  and
mark.


case-region-lower                                                   [unbound]
Change  all alphabetic characters in the region between dot and mark to lower
case.


case-region-upper                                                   [unbound]
Change all alphabetic characters in the region between dot and mark to  upper
case.


case-word-capitalize                                                [unbound]
Capitalize  the  current word (the one above or to the left of dot) by making
its first character upper case and all the rest lower case.
                                                                              57


 case-word-invert                                                      [unbound]
   Invert  the  case  of  all alphabetic characters in the current word (the one
 above or to the left of dot).


 case-word-lower                                                       [unbound]
   Change all alphabetic characters in the current word (the one above or to the
 left of dot) to lower case.


 case-word-upper                                                       [unbound]
   Change all alphabetic characters in the current word (the one above or to the
 left of dot) to upper case.


 change-current-process                                                [unbound]
   (change-current-process "process-name") -- Sets the current  process  to  the
 one named.


 change-directory                                                      [unbound]
   Changes the current directory (for Emacs) to the named directory.  All future
 file  write  and  reads (^X^S, ^X^V, etc.) will be interpreted relative to that
 directory.


 char-to-string                                                        [unbound]
   Takes a numeric argument and returns a one character string that results from
 considering the number as an ascii character.


 checkpoint                                                            [unbound]
   Causes all modified buffers with  an  out  of  date  checkpoint  file  to  be
 checkpointed.      This   function   is  normally  called  automatically  every
 checkpoint-frequency keystrokes.


 Command prefix, also known as META                                          ESC
   The next character typed will be interpreted as a command based on  the  fact
 that  it  was  preceded by ESC.  The name meta for the ESC character comes from
 funny keyboards at Stanford and MIT that have a Meta-shift key which is used to
 extend the ASCII character set.  Lacking a Meta key, we make do with  prefixing
 with  an ESC character.  You may see (and hear) commands like ESC-V referred to
 as Meta-V.  Sometimes the ESC key is confusingly written as $, so  ESC-V  would
 be  written  as  $V.  ESC is also occasionally referred to as Altmode, from the
 labeling of a key on those old favorites, model 33 teletypes.
58


command-prefix                                                             ^X
The  next  character typed will be interpreted as a command based on the fact
that it was preceded by ^X.


compile-it                                                               ^X^E
Make is a standard Unix program which takes a description of how to compile a
set of programs and compiles them.  The output of make (and  the  compilers  it
calls)  is  placed  in  a buffer which is displayed in a window.  If any errors
were encountered, Emacs  makes  a  note  of  them  for  later  use  with  ^X^N.
Presumably,  a  data  base has been set up for make that causes the files which
have been edited to be compiled.  ^X^E then updates the files  that  have  been
changed  and make does the necessary recompilations, and Emacs notes any errors
and lets you peruse them with ^X^N.

If ^X^E is given a non-zero argument, then rather than  just  executing  make
Emacs  will  prompt  for  a Unix command line to be executed.  Modified buffers
will still be written out, and the output will still go to the Error log buffer
and be parsed as error messages for use with ^X^N.   One  of  the  most  useful
applications  of this feature involves the grep program.  "^U^X^Egrep -n MyProc
*.cESC" will scan through all C source files looking for  the  string  "MyProc"
(which  could  be  the  name  of  a  procedure).  You can then use ^X^N to step
through all places in all the files where the string  was  found.    Note:  The
version of grep in my bin directory, /usr/jag/bin/grep, must be used: it prints
line  numbers  in  a format that is understood by Emacs.  (ie.  "FileName, line
LineNumber)


concat                                                              [unbound]
Takes a set of string arguments and returns their concatenation.


continue-process                                                    [unbound]
(continue-process  "process-name")  --  Continue   a   process   stopped   by
stop-process.


copy-region-to-buffer                                               [unbound]
Copies  the  region  between dot and mark to the named buffer.  The buffer is
emptied before the text is copied into it; the region between dot and  mark  is
left undisturbed.


current-buffer-name                                                 [unbound]
MLisp function that returns the current buffer name as a string.
                                                                              59


 current-column                                                        [unbound]
   (current-column) is an MLisp function that returns the printing column number
 of the character immediately following dot.


 current-file-name                                                     [unbound]
   MLisp  function that returns the file name associated with the current buffer
 as a string.  If there is no associated file name, the null string is returned.


 current-indent                                                        [unbound]
   (current-indent) is an MLisp function the returns the amount of whitespace at
 the beginning of the line which dot is in (the printing column  number  of  the
 first non-whitespace character).


 current-process                                                       [unbound]
   (current-process)  --  Returns  the name of the current process as defined in
 the section describing the process mechanism.


 current-time                                                          [unbound]
   MLisp function that returns the current time of day as a string in the format
 described in CTIME(3), with the exception that the trailing newline  will  have
 been stripped off.  (substr (current-time) -4 4) is the current year.


 declare-buffer-specific                                               [unbound]
   Takes  a  list of variables and declares them to have buffer-specific values.
 A buffer-specific variable has a distinct instance for each buffer in existance
 and a default value which is used  when  new  buffers  are  created.    When  a
 buffer-specific  variable is assigned a value only the instance associated with
 the currently selected buffer is affected.  To set  the  default  value  for  a
 buffer-specific  variable,  use  setq-default or set-default.  Note that if you
 have a global variable which is eventually declared  buffer-specific  then  the
 global value becomes the default.


 declare-global                                                        [unbound]
   Takes  a  list  of  variables and for each that is not already bound a global
 binding is created.  Global bindings outlive all function calls.


 define-buffer-macro                                                   [unbound]
   Take the contents of the current buffer and define it as a macro  whose  name
 is associated with the buffer.  This is how one redefines a macro that has been
 edited using edit-macro.
60


define-global-abbrev                                                [unbound]
Define  (or  redefine)  an abbrev with the given name for the given phrase in
the global abbreviation table.


define-hooked-global-abbrev                                         [unbound]
The  commands  define-hooked-global-abbrev   and   define-hooked-local-abbrev
behave   exactly   as   the  unhooked  versions  do  (define-global-abbrev  and
define-local-abbrev) except that they also associate a named command  with  the
abbrev.   When the abbrev triggers, rather than replacing the abbreviation with
the expansion phrase the hook procedure is invoked. The character that  trigged
the  abbrev  will not have been inserted, but will be inserted immediatly after
the hook procedure returns [unless the procedure returns 0].  The  abbreviation
will   be   the   word  immediatly  to  the  left  of  dot,  and  the  function
abbrev-expansion returns the phrase that the abbrev would have expanded to.


define-hooked-local-abbrev                                          [unbound]
See the description of define-hooked-global-abbrev.


define-keyboard-macro                                               [unbound]
Give a name to the current keyboard macro.  A keyboard macro  is  defined  by
using the ^X( and ^X) command; define-keyboard-macro takes the current keyboard
macro,  squirrels  it  away  in  a  safe place, gives it a name, and erases the
keyboard macro.  define-string-macro is another way to define a macro.


define-keymap                                                       [unbound]
(define-keymap "mapname") defines a new, empty, keymap with the  given  name.
See the section on keymaps, 15 page 28, for more information.


define-local-abbrev                                                 [unbound]
Define  (or  redefine)  an abbrev with the given name for the given phrase in
the local abbreviation table.  A local abbrev table must have already been  set
up with use-abbrev-table.


define-string-macro                                                 [unbound]
Define a macro given a name and a body as a string entered in the minibuffer.
Note:  to  get a control character into the body of the macro it must be quoted
with ^Q.  define-keyboard-macro is another way to define a macro.
                                                                              61


 defun                                                                 [unbound]
   (defun  (name  expressions...  )... ) is an MLisp function that defines a new
 MLisp  function  with  the  given  name  and  a  body  composed  of  the  given
 expressions.    The  value of the function is the value of the last expression.
 For example:

     (defun
         (indent-line                ; this function just sticks a tab at
             (save-excursion         ; the beginning of the current line
                 (beginning-of-line) ; without moving dot.
                 (insert-string "    ")
             )
         )
     )


 delete-buffer                                                         [unbound]
   Deletes the named buffer.


 delete-macro                                                          [unbound]
   Delete the named macro.


 delete-next-character                                                        ^D
   Delete the character immediatly following dot;  that  is,  the  character  on
 which the terminals cursor sits.  Lines may be merged by deleting newlines.


 delete-next-word                                                          ESC-D
   Delete  characters  forward from dot until the next end of a word.  If dot is
 currently not in a word, all punctuation up to the beginning  of  the  word  is
 deleted as well as the word.


 delete-other-windows                                                        ^X1
   Go  back  to  one-window mode.  Generally useful when Emacs has spontaneously
 generated a window (as for ESC-? or ^X^B) and you want to get rid of it.


 delete-previous-character                                                    ^H
   Delete the character immediatly preceding dot; that is, the character to  the
 left of the terminals cursor.  If you've just typed a character, ^H (backspace)
 will delete it.  Lines may be merged by deleting newlines.
62


delete-previous-character                                              RUBOUT
Delete  the character immediatly preceding dot; that is, the character to the
left of the terminals cursor.  If you've just typed a  character,  RUBOUT  will
delete it.  Lines may be merged by deleting newlines.


delete-previous-word                                                    ESC-H
If  not  in  the  middle of a word, delete characters backwards (to the left)
until a word is found.  Then delete the word to the left of dot.  A word  is  a
sequence of alphanumerics.


delete-region-to-buffer                                                ESC-^W
Wipe  (kill,  delete)  all  characters between dot and the mark.  The deleted
text is moved to a buffer whose name is prompted for, which is emptied first.


delete-to-killbuffer                                                       ^W
Wipe (kill, delete) all characters between dot and the  mark.    The  deleted
text is moved to the kill buffer, which is emptied first.


delete-white-space                                                  [unbound]
Deletes all whitespace characters (spaces and tabs) on either side of dot.


delete-window                                                             ^XD
Removes  the  current  window  from  the  screen and gives it's space to it's
neighbour below (or above) and makes the current window and buffer those of the
neighbour.


describe-bindings                                                   [unbound]
Places in the Help window a list  of  all  the  keys  and  the  name  of  the
procedure  that  they  are bound to.  This listing is suitable for printing and
making you own quick-reference card for your own customized version of Emacs.


describe-command                                                    [unbound]
Uses the Info system to describe some named command.  You will be prompted in
the minibuf for the name of a command and then Info will be invoked to show you
the manual entry describing it.  You can then use Info  to  browse  around,  or
simply type ^C to resume editing.
                                                                              63


 describe-key                                                          [unbound]
   Describe  the  given  key.    ESC-Xdescribe-key  ESC-X  will  print  a  short
 descrition of the ESC-X key.  It tells you the name of the command to which the
 key is bound.  To find out more about the command, use describe-command.


 describe-variable                                                     [unbound]
   Uses the Info system to describe some named variable.  You will  be  prompted
 in the minibuf for the name of a variable and then Info will be invoked to show
 you the manual entry describing it.  You can then use Info to browse around, or
 simply type ^C to resume editing.


 describe-word-in-buffer                                                    ^X^D
   Takes  the  word nearest the cursor and looks it up in a data base and prints
 the information found.  This data base contains short one-line descriptions  of
 all  of  the  Unix  standard procedures and Franz Lisp standard functions.  The
 idea is that if you've just typed in the name of some procedure and can't quite
 remember which arguments go where, just type ^X^D and Emacs will  try  to  tell
 you.


 digit                                                                 [unbound]
   Heavy  wizardry:    you  don't  want  to  know.    "digit"  should eventually
 disappear.


 dot                                                                   [unbound]
   (dot) is an MLisp function that returns the number of characters to the  left
 of  dot plus 1 (ie. if dot is at the beginning of the buffer, (dot) returns 1).
 The value of the function is an object of type "marker" -- if it is assigned to
 a variable then as  changes  are  made  to  the  buffer  the  variable's  value
 continues to indicate the same position in the buffer.


 dump-syntax-table                                                     [unbound]
   Dumps  a  readable  listing  of  a  syntax table into a buffer and makes that
 buffer visible.


 edit-macro                                                            [unbound]
   Take the body of the named macro and place it in a buffer called Macro  edit.
 The  name  of  the  macro  is  associated  with  the  buffer and appears in the
 information bar at the bottom of the window.  The buffer  may  be  edited  just
 like any other buffer (this is, in fact, the intent).  After the macro body has
 been edited it may be redefined using define-buffer-macro.
64


emacs-version                                                       [unbound]
Returns a string that describes the current Emacs version.


end-of-file                                                             ESC->
Move dot to just after the last character of the buffer.


end-of-line                                                                ^E
Move dot to the end of the line in the current buffer that contains dot; that
is, to just after the following end-of-line or the end of the buffer.


end-of-window                                                           ESC-.
Move dot to just after the last character visible in the window.


enlarge-window                                                            ^XZ
Makes  the  current  window one line taller, and the window below (or the one
above if there is no window below) one line shorter.  Can't be used if there is
only one window on the screen.


eobp                                                                [unbound]
(eobp) is an MLisp predicate that is true iff  dot  is  at  the  end  of  the
buffer.


eolp                                                                [unbound]
(eolp) is an MLisp predicate that is true iff dot is at the end of a line.


eot-process                                                         [unbound]
(eot-process "process-name") -- Send an EOT to the process.


erase-buffer                                                        [unbound]
Deletes  all  text  from the current buffer.  Doesn't ask to make sure if you
really want to do it.


erase-region                                                        [unbound]
Erases the region between dot and mark.    It  is  like  delete-to-killbuffer
except that it doesn't move the text to the kill buffer.
                                                                              65


 error-message                                                         [unbound]
   (error-message  "string-expressions")  Sends  the  string-expressions  to the
 screen as an error message where it will appear at the bottom  of  the  screen.
 Emacs will return to keyboard level, unless caught by error-occured.


 error-occured                                                         [unbound]
   (error-occured  expressions...)  executes  the  given expressions and ignores
 their values.  If  all  executed  successfully,  error-occured  returns  false.
 Otherwise  it  returns true and all expressions after the one which encountered
 the error will not be executed.


 exchange-dot-and-mark                                                      ^X^X
   Sets dot to the currently marked position and marks the old position of  dot.
 Useful  for  bouncing back and forth between two points in a file; particularly
 useful when the two points delimit a  region  of  text  that  is  going  to  be
 operated on by some command like ^W (erase region).


 execute-extended-command                                                  ESC-X
   Emacs  will  prompt  in the minibuffer (the line at the bottom of the screen)
 for a command from the extended set.  These deal  with  rarely  used  features.
 Commands are parsed using a Twenex style command interpreter:  you can type ESC
 or space to invoke command completion, or '?' for help with what you're allowed
 to  type  at  that  point.  This doesn't work if it's asking for a key or macro
 name.


 execute-keyboard-macro                                                      ^XE
   Takes the keystrokes remembered with ^X( and ^X) and treats  them  as  though
 they  had been typed again.  This is a cheap and easy macro facility.  For more
 power,  see  the  define-string-macro,  define-keyboard-macro  and  bind-to-key
 commands.


 execute-mlisp-buffer                                                  [unbound]
   Parse  the  current  buffer  as  as a single MLisp expression and execute it.
 This is what is generally used  for  testing  out  new  functions:  stick  your
 functions in a buffer wrapped in a defun and use execute-mlisp-buffer to define
 them.


 execute-mlisp-line                                                      ESC-ESC
   Prompt for a string, parse it as an MLisp expression and execute it.
66


execute-monitor-command                                                   ^X!
Prompt  for  a Unix command then execute it, placing its output into a buffer
called Command execution and making that buffer  visible  in  a  window.    The
command  will not be able to read from its standard input (it will be connected
to /dev/null).  For now, there is no way to execute an interactive subprocess.


exit-emacs                                                                 ^C
Exit Emacs.  Will ask if you're sure if there are any buffers that have  been
modified but not written out.


exit-emacs                                                               ^X^C
Exit  Emacs.  Will ask if you're sure if there are any buffers that have been
modified but not written out.


exit-emacs                                                             ESC-^C
Exit Emacs.  Will ask if you're sure if there are any buffers that have  been
modified but not written out.


expand-file-name                                                    [unbound]
Takes  a  string  representing  a  file  name and expands it into an absolute
pathname.    For  example,  if  the  current  directory  is  "/usr/frodo"  then
(expand-file-name "../bilbo") will return "/usr/bilbo".


expand-mlisp-variable                                               [unbound]
Prompts  for  the  name  of a declared variable then inserts the name as text
into the current buffer.  This is very handly for typing  in  MLisp  functions.
It's also fairly useful to bind it to a key for easy access.


expand-mlisp-word                                                   [unbound]
Prompt  for  the  name  of  a  command  then insert the name as text into the
current buffer.  This is very handly for typing in MLisp functions.  It's  also
fairly useful to bind it to a key for easy access.


extend-database-search-list                                         [unbound]
(extend-database-search-list  dbname  filename) adds the given data base file
to the data base search list (dbname).  If  the  database  is  already  in  the
search  list  then  it  is  left,  otherwise  the  new database is added at the
beginning of the list of databases.
                                                                              67


 fetch-database-entry                                                  [unbound]
   (fetch-database-entry   dbname   key)  takes  the  entry  in  the  data  base
 corresponding to the given key and inserts it into the current buffer.


 file-exists                                                           [unbound]
   (file-exists fn) returns 1 if the file named by fn exists and is writable,  0
 if it does not exist, and -1 if it exists and is readable but not writable.


 filter-region                                                         [unbound]
   Take the region between dot and mark and pass it as the standard input to the
 given  command  line.   Its standard output replaces the region between dot and
 mark.  Use this to run a region through a Unix style-filter.


 following-char                                                        [unbound]
   (following-char) is an MLisp function that returns the  character  immediatly
 following  dot.  The null character (0) is returned if dot is at the end of the
 buffer.  Remember that dot is not  `at'  some  character,  it  is  between  two
 characters.


 forward-balanced-paren-line                                           [unbound]
   Moves dot forward until either

    - The end of the buffer is reached.

    - An  unmatched  close  parenthesis,  ')',  is  encountered.   That is,
      unmatched between there and the starting position of dot.

    - The beginning of a line is encountered at "parenthesis  level  zero".
      That  is,  without  an  unmatched  '(' existing between there and the
      starting position of dot.

 The definitions of parenthesis and  strings  from  the  syntax  table  for  the
 current buffer are used.


 forward-character                                                            ^F
   Move  dot  forwards  one  character. Ends-of-lines and tabs each count as one
 character.  You can't move forward to after the end of the buffer.
68


forward-paragraph                                                       ESC-]
Moves  to  the  end  of the current or following paragraph.  Blank lines, and
Scribe and nroff command  lines  separate  paragraphs  and  are  not  parts  of
paragraphs.


forward-paren                                                       [unbound]
Moves  dot  forward  until an unmatched close parenthesis, ')', or the end of
the buffer is  found.    This  can  be  used  to  aid  in  skipping  over  Lisp
S-expressions.    The  definitions  of  parenthesis and strings from the syntax
table for the current buffer are used.


forward-sentence                                                        ESC-E
Move dot forward to the beginning  of  the  next  sentence.    Sentences  are
seperated by a `.', `?' or `!' followed by whitespace.


forward-word                                                            ESC-F
Move  dot  forward to the end of a word.  If not currently in the middle of a
word, skip all intervening punctuation.  Then skip over the word,  leaving  dot
positioned  after  the  last  character  of  the word.  A word is a sequence of
alphanumerics.


get-tty-buffer                                                      [unbound]
Given a prompt string it reads the name of a buffer from the  tty  using  the
minibuf and providing command completion.


get-tty-character                                                   [unbound]
Reads a single character from the terminal and returns it as an integer.  The
cursor  is  not moved to the message area, it is left in the text window.  This
is useful when writing things like query-replace and incremental search.


get-tty-command                                                     [unbound]
(get-tty-command prompt) prompts for the name of a declared  function  (using
command  completion & providing help) and returns the name of the function as a
string.      For   example,   the   expand-mlisp-word   function   is    simply
(insert-string (get-tty-command ": expand-mlisp-word ")).


get-tty-string                                                      [unbound]
Reads  a  string  from  the  terminal using its single string parameter for a
prompt.  Generally used inside MLisp programs to ask questions.
                                                                              69


 get-tty-variable                                                      [unbound]
   (get-tty-variable  prompt) prompts for the name of a declared variable (using
 command completion & providing help) and returns the name of the variable as  a
 string.      For   example,   the   expand-mlisp-variable  function  is  simply
 (insert-string (get-tty-variable ": expand-mlisp-variable ")).


 getenv                                                                [unbound]
   (getenv "varname")  returns  the  named  shell  environment  variable.    for
 example, (getenv "HOME") will return a string which names your home directory.


 global-binding-of                                                     [unbound]
   Returns  the  name of the procedure to which a keystroke sequence is bound in
 the global keymap. "nothing" is returned if  the  sequence  is  unbound.    The
 procedure local-binding-of performs a similar function for the local keymap.


 goto-character                                                        [unbound]
   Goes  to  the given character-position.  (goto-character 5) goes to character
 position 5.


 if                                                                    [unbound]
   (if test thenclause elseclause)  is  an  MLisp  function  that  executes  and
 returns  the  value  of  thenclause  iff  test  is  true; otherwise it executes
 elseclause if it is present.  For example:

     (if (eolp)
         (to-col 33)
     )

 will tab over to column 33 if dot is currently at the end of a line.


 illegal-operation                                                     [unbound]
   Illegal-operation is  bound  to  those  keys  that  do  not  have  a  defined
 interpretation.    Executing  illegal-operation is an error.  Most notably, ^G,
 ESC-^G, ^X^G are bound to illegal-opetation by default, so that typing ^G  will
 always get you out of whatever strange state you are in.


 indent-C-procedure                                                        ESC-J
   Take  the  current  C  procedure  and reformat it using the indent program, a
 fairly sophisticated pretty printer.  Indent-C-procedure is God's gift to those
 who  don't   like   to   fiddle   about   getting   their   formatting   right.
 Indent-C-procedure  is  usually  bound  to  ESC-J.  When switching from mode to
 mode, ESC-J will be bound to procedures appropriate to that mode.  For example,
 in text mode ESC-J is bound to justify-paragraph.
70


insert-character                                                    [unbound]
Inserts  its  numeric  argument  into  the  buffer  as  a  single  character.
(insert-character '0') inserts the character '0' into the buffer.


insert-file                                                              ^X^I
Prompt for the name of a file and insert its contents at dot in  the  current
buffer.


insert-filter                                                       [unbound]
Insert  a  filter-procedure between a process and Emacs. This function should
subsume the start-filtered-process function, but we should retain that one  for
compatibility I suppose...


insert-string                                                       [unbound]
(insert-string  stringexpressions)  is  an  MLisp  function  that inserts the
strings that result from evaluating the  given  stringexpressions  and  inserts
them into the current buffer just before dot.


int-process                                                         [unbound]
(int-process "process-name") -- Send an interrupt signal to the process.


interactive                                                         [unbound]
An  MLisp  function which is true iff the invoking MLisp function was invoked
interactively (ie. bound to a key or by ESC-X).


is-bound                                                            [unbound]
an MLisp predicate that is true iff all of its variable  name  arguments  are
bound.  


justify-paragraph                                                   [unbound]
Take  the  current paragraph (bounded by blank lines or Scribe control lines)
and pipe it through the  "fmt"  command  which  does  paragraph  justification.
justify-paragraph is usually bound to ESC-J when in text mode.


kill-process                                                        [unbound]
(kill-process "process-name") -- Send a kill signal to the process.
                                                                              71


 kill-to-end-of-line                                                          ^K
   Deletes  characters  forward from dot to the immediatly following end-of-line
 (or end of buffer if there isn't an end of line).  If dot is positioned at  the
 end  of  a line then the end-of-line character is deleted.  Text deleted by the
 ^K command is placed into the Kill buffer (which really is a  buffer  that  you
 can  look  at).    A ^K command normally erases the contents of the kill buffer
 first; subsequent ^K's in an unbroken sequence append to the kill buffer.


 last-key-struck                                                       [unbound]
   The last command character struck.  If you have a function bound to many keys
 the function may use last-key-struck to tell which key was used to  invoke  it.
 (insert-character (last-key-struck)) does the obvious thing.


 length                                                                [unbound]
   Returns the length of its string parameter.  (length "time") => 4.


 line-to-top-of-window                                                     ESC-!
   What  more  can  I  say?    This one is handy if you've just searched for the
 declaration of a procedure, and want to see the whole body (or as much of it as
 possible).


 list-buffers                                                               ^X^B
   Produces a listing of all existing buffers giving their names,  the  name  of
 the  associated  file (if there is one), the number of characters in the buffer
 and an indication of whether or not the buffer has been modified since  it  was
 read or written from the associated file.


 list-databases                                                        [unbound]
   (list-databases) lists all data base search lists.


 list-processes                                                        [unbound]
   (list-processes)  --  Analagous to "list-buffers".  Processes which have died
 only appear once in this list before completely disappearing.


 load                                                                  [unbound]
   Read the named file as a  series  of  MLisp  expressions  and  execute  them.
 Typically  a  loaded  file  consists  primarily  of defun's and buffer-specific
 variable assignments and key bindings.  Load is  usually  used  to  load  macro
 libraries  and is used to load ".emacs pro" from your home directory when Emacs
 starts up.

   For example, loading this file:
72


  (setq right-margin 75)
  (defun (my-linefeed
              (end-of-line)
              (newline-and-indent)
         )
  )
  (bind-to-key "my-linefeed" 10)

sets the right-margin to 75 and defines a function called my-linefeed and binds
it to the linefeed key (which is the ascii character 10 (decimal))

The  file name given to load is interpreted relative to the EPATH environment
variable, which is interpreted in the same manner as the shell's PATH variable.
That is, it provides a list of colon-separated names that are taken to  be  the
names  of directories that are searched for the named files.  The default value
of EPATH searches your current directory and then a central system directory.

Temporary hack: in previous versions of Emacs loaded files were treated as  a
sequence   of   keystrokes.     This  behaviour  has  been  decreed  bogus  and
unreasonable, hence it has been changed.   However,  to  avoid  loud  cries  of
anguish  the  load  command  still  exhibits  the  old  behaviour  if the first
character of the loaded file is an ESC.


local-bind-to-key                                                   [unbound]
Prompt for the name of a command and a key and bind that command to the given
key but unlike bind-to-key the binding only has effect in the  current  buffer.
This  is  generally  used for mode specific bindings that will generally differ
from buffer to buffer.


local-binding-of                                                    [unbound]
Returns the name of the procedure to which a keystroke sequence is  bound  in
the  local  keymap.  "nothing"  is  returned  if  the sequence is unbound.  The
procedure global-binding-of performs a similar function for the global keymap.


looking-at                                                          [unbound]
(looking-at "SearchString") is true iff the given regular  expression  search
string  matches the text immediatly following dot.  This is for use in packages
that want to do a limited sort of parsing.  For  example,  if  dot  is  at  the
beginning  of  a  line  then (looking-at "[ \t]*else]) will be true if the line
starts with an "else".  See section 14, page 25 for more information on regular
expressions.
                                                                              73


 mark                                                                  [unbound]
   An  MLisp  function  that  returns  the position of the marker in the current
 buffer.  An error is signaled if the marker  isn't  set.    The  value  of  the
 function  is an object of type "marker" -- if it is assigned to a variable then
 as changes are made to the buffer the variable's value  continues  to  indicate
 the same position in the buffer.


 message                                                               [unbound]
   (message stringexpressions) is an MLisp function that places the strings that
 result  from  the  evaluation  of  the given stringexpressions into the message
 region on the display (the line at the bottom).


 modify-syntax-entry                                                   [unbound]
   Modify-syntax-entry is used to modify a set of entries in  the  syntax  table
 associated  with the current buffer.  Syntax tables are associated with buffers
 by using the use-syntax-table command.  Syntax tables are used by commands like
 forward-paren to do a limited form of parsing for language dependent  routines.
 They  define  such  things  as which characters are parts of words, which quote
 strings and  which  delimit  comments  (currently,  nothing  uses  the  comment
 specification).      To   see   the   contents  of  a  syntax  table,  use  the
 dump-syntax-table command.

   The parameter to modify-syntax-entry is a string whose first five  characters
 specify the interpretation of the sixth and following characters.

   The first character specifies the type.  It may be one of the following:

 'w'             A  word character, as used by such commands as forward-word and
                  case-word-capitalize.

 space           A character with no special interpretation.

 '('             A left parenthesis.  Typical candidates for this type  are  the
                 characters '(', '[' and '{'.  Characters of this type also have
                 a  matching  right  parenthesis specified (')', ']' and '}' for
                 example) which appears as the second character of the parameter
                 to modify-syntax-entry.

 ')'             A right parenthesis.  Typical candidates for this type are  the
                 characters ')', ']' and '}'.  Characters of this type also have
                 a  matching  left  parenthesis  specified ('(', '[' and '{' for
                 example) which appears as the second character of the parameter
                 to modify-syntax-entry.

 '"'             A quote character.  The C string delimiters " and ' are usually
                 given this class, as is the Lisp |.

 '\'             A prefix character, like \ in C or / in MacLisp.

 The second character of the  parameter  is  the  matching  parenthesis  if  the
74


character  is of the left or right parenthesis type. If you specify that '(' is
a right parenthesis matched by ')', then you should also specify that ')' is  a
left parenthesis matched by '('.

The  third  character,  if equal to '{', says that the character described by
this syntax entry can begin a comment; the forth character,  if  equal  to  '}'
says  that  the character described by this syntax entry can end a comment.  If
either the beginning or ending comment sequence is two  characters  long,  then
the fifth character provides the second character of the comment sequence.

The  sixth and following characters specify which characters are described by
this entry; a range of characters can be specified by  putting  a  '-'  between
them, a '-' can be described if it appears as the sixth character.

A few examples, to help clear up my muddy exposition:

  (modify-syntax-entry "w    -")  ; makes '-' behave as a normal word
                                  ; character (ESC-F will consider
                                  ; one as part of a word)
  (modify-syntax-entry "(]   [")  ; makes '[' behave as a left parenthesi
                                  ; which is matched by ']'
  (modify-syntax-entry ")[   ]")  ; makes ']' behave as a right parenthes
                                  ; which is matched by '['


move-dot-to-x-y                                                     [unbound]
(move-dot-to-x-y  x  y) switches to the buffer and sets dot to the positon of
the character that was displayed at screen coordinates x,y.  If x and  y  don't
point  to  a  valid character (eg. if they are out of bounds or point to a mode
line) an error is flagged.

This function is intended for use supporting mice and tablets.  One way to do
this is to have depressions  of  the  tablet  button  generate  a  sequence  of
keystrokes  that  Emacs  sees as normal tty input.  If, for example, the tablet
was to transmit the four charcters ESC-M-x-y when the button was depressed over
character x,y then the following function would provide simple support for it:

  (defun (mouse-set-dot x y
             (setq x (get-tty-character))
             (setq y (get-tty-character))
             (move-dot-to-x-y x y)
         ))

  (bind-to-key "mouse-set-dot" "\eM")
                                                                              75


 move-to-comment-column                                                [unbound]
   If  the  cursor  is not at the beginning of a line, ESC-C moves the cursor to
 the column specified by the  comment-column  variable  by  inserting  tabs  and
 spaces  as  needed.    In  any case, it the sets the right margin to the column
 finally reached.    This  is  usually  used  in  macros  for  language-specific
 comments.


 nargs                                                                 [unbound]
   An  MLisp  function  which  returns  the  number  of  arguments passed to the
 invoking MLisp function.  For example, within the execution of foo  invoked  by
 (foo x y) the value of nargs will be 2.


 narrow-region                                                         [unbound]
   The  narrow-region  command  sets  the  restriction  to  encompass the region
 between dot and mark.  Text outside this  region  will  henceforth  be  totally
 invisible.    It  won't appear on the screen and it won't be manipulable by any
 editing commands.  This can be useful, for instance, when you want to perform a
 replacement within a few paragraphs: just narrow down to a region enclosing the
 paragraphs and execute replace-string.


 newline                                                               [unbound]
   Just inserts a newline character into the buffer -- this is what  the  RETURN
 (^M) key is generally bound to.


 newline-and-backup                                                           ^O
   Insert  an end-of-line immediatly after dot, effectivly opening up space.  If
 dot is positioned at the beginning of a line, then ^O will create a blank  line
 preceding the current line and position dot on that new line.


 newline-and-indent                                                     LINEFEED
   Insert a newline, just as typing RETURN does, but then insert enough tabs and
 spaces  so  that the newly created line has the same indentation as the old one
 had.  This is quite useful when you're typing in a block of program  text,  all
 at the same indentation level.


 next-error                                                                 ^X^N
   Take the next error message (as returned from the ^X^E (compile) command), do
 a  visit (^X^V) on the file in which the error occurred and set dot to the line
 on which the error occurred.  The error message will be displayed at the top of
 the window associated with the Error log buffer.
76


next-line                                                                  ^N
Move  dot  to  the  next  line.    ^N  and ^P attempt to keep dot at the same
horizontal position as you move from line to line.


next-page                                                                  ^V
Reposition the current window on the current buffer so that the next page  of
the  buffer is visible in the window (where a page is a group of lines slightly
smaller than a window).  In other words, it flips you forward  a  page  in  the
buffer.  Its inverse is ESC-V.  If possible, dot is kept where it is, otherwise
it is moved to the middle of the new page.


next-window                                                               ^XN
Switches  to  the  window  (and  associated buffer) that is below the current
window.


nothing                                                             [unbound]
Nothing evaluates the same as novalue (ie. it returns a void  result)  except
that  if  it is bound to some key or attached to some hook then the key or hook
behave as though no command was bound to them.  For example,  if  you  want  to
remove the binding of a single key, just bind it to "nothing".


novalue                                                             [unbound]
Does  nothing.    (novalue)  is  a  complete no-op, it performs no action and
returns no value.  Generally the value of a function is the value of  the  last
expression  evaluated  in  it's  body,  but  this  value may not be desired, so
(novalue) is provided so that you can throw it away.


page-next-window                                                       ESC-^V
Repositions the window below the current one (or the top one if  the  current
window  is  the  lowest  one on the screen) on the displayed buffer so that the
next page of the buffer is visible in the window (where a page is  a  group  of
lines  slightly smaller than a window).  In other words, it flips you forward a
page in the buffer of the other window.

If ESC-^V is given an argument it will flip  the  buffer  backwards  a  page,
rather  than  forwards.   So ESC-^V is roughly equivalent to ^V and ^UESC-^V is
roughly equivalent to ESC-V except that they deal with the other window.   Yes,
yes,  yes.    I  realize  that  this is a bogus command structure, but I didn't
invent it.  Besides, you can learn to love it.
                                                                              77


 parse-error-messages-in-region                                        [unbound]
   Parses  the  region  between  dot  and  mark  for  error  messages (as in the
 compile-it (^X^E) command) and sets up for subsequent invocations of next-error
 (^X^N).  See the description of the compile-it command, and  section  10  (page
 13).


 pause-emacs                                                           [unbound]
   Pause,  giving  control  back  to  the  superior  shell using the job control
 facility of Berkeley Unix.  The screen is cleaned up before the  shell  regains
 control,  and  when  the  shell  gives control back to Emacs the screen will be
 fixed up again.  Users of the sea-shell (csh) will  probably  rather  use  this
 command  than  "return-to-monitor", which is similar, except that it recursivly
 invokes a new shell.


 pop-to-buffer                                                         [unbound]
   Switches to a buffer whose name  is  provided  and  ties  that  buffer  to  a
   popped-up  window.    Pop-to-buffer  is  exactly the same as switch-to-buffer
 except  that  switch-to-buffer  ties  the  buffer  to   the   current   window,
 pop-to-buffer finds a new window to tie it to.


 preceding-char                                                        [unbound]
   (preceding-char)  is  an MLisp function that returns the character immediatly
 preceding dot.  The null character (0) is returned if dot is at  the  beginning
 of the buffer.  Remember that dot is not `at' some character, it is between two
 characters.


 prefix-argument-loop                                                  [unbound]
   (prefix-argument-loop  <statements>)  executes  <statements>  prefix-argument
 times.  Every function invocation is always prefixed by some argument,  usually
 by the user typing ^Un.  If no prefix argument has been provided, 1 is assumed.
 See also the command provide-prefix-argument and the variable prefix-argument.


 prepend-region-to-buffer                                              [unbound]
   Prepends  the  region  between dot and mark to the named buffer.  Neither the
 original text in the destination buffer nor the text in the region between  dot
 and mark will be disturbed.


 previous-command                                                      [unbound]
   (previous-command)  usually returns the character value of the keystroke that
 invoked the previous command.  In  is  something  like  last-key-struck,  which
 returns  the  keystroke  that invoked the current command.  However, a function
 may set the variable this-command to some value, which will  be  the  value  of
 previous-command  after  the  next  command  invocation.    This rather bizarre
 command/variable pair is intended to be used in  the  implementation  of  MLisp
 functions  which  behave  differently  when  chained together (ie. executed one
 after the other).  A good example is ^K, kill-to-end-of-line which appends  the
78


text from chained kills to the killbuffer.

To  use  this technique for a set of commands which are to exhibit a chaining
behaviour, first pick a magic number.  -84, say.  Then each command in this set
which is chainable should (setq this-command -84).  Then to tell if  a  command
is  being  chained,  it  suffices to check to see if (previous-command) returns
-84.

Did I hear you scream ``hack''??


previous-line                                                              ^P
Move dot to the previous line.  ^N and ^P attempt to keep  dot  at  the  same
horizontal position as you move from line to line.


previous-page                                                           ESC-V
Repositions  the  current  window  on the current buffer so that the previous
page of the buffer is visible in the window (where a page is a group  of  lines
slightly  smaller than a window).  In other words, it flips you backward a page
in the buffer.  Its inverse is ^V.  If possible,  dot  is  kept  where  it  is,
otherwise it is moved to the middle of the new page.


previous-window                                                           ^XP
Switches  to  the  window  (and  associated buffer) that is above the current
window.


print                                                               [unbound]
Print the value of the named variable.  This is the command you use when  you
want to inquire about the setting of some switch or parameter.


process-filter-name                                                 [unbound]
Returns the name of the filter procedure attached to some buffer.


process-id                                                          [unbound]
Returns the process id of the process attached to some buffer.


process-output                                                      [unbound]
(process-output)  -- Can only be called by the on-output-procedure to procure
the output generated by the process whose name is given by MPX-process. Returns
the output as a string.
                                                                              79


 process-status                                                        [unbound]
   (process-status  "process-name")  --  Returns  -1  if  "process-name" isn't a
 process, 0 if the process is stopped, and 1 if the process is running.


 progn                                                                 [unbound]
   (progn expressions...) is an MLisp function that  evaluates  the  expressions
 and  returns  the  value  of  the  last expression evaluated.  Progn is roughly
 equivalent to a compound  statement  (begin-end  block)  in  more  conventional
 languages  and is used where you want to execute several expressions when there
 is space for only one (eg. the then or else parts of an if expression).


 provide-prefix-argument                                               [unbound]
   (provide-prefix-argument <value> <statement>) provides  the  prefix  argument
 <value>  to  the  <statement>.    For  example,  the most efficient way to skip
 forward 5 words is:  

     (provide-prefix-argument 5 (forward-word))

 See also the command prefix-argument-loop and the variable prefix-argument.  


 push-back-character                                                   [unbound]
   Takes the character provided as its argument and causes it to be used as  the
 next  character  read  from the keyboard.  It is generally only useful in MLisp
 functions which read characters from the keyboard, and upon  finding  one  that
 they  don't  understand, terminate and behave as though the key had been struck
 to the Emacs keyboard command interpreter. For example, ITS  style  incremental
 search.


 put-database-entry                                                    [unbound]
   (put-database-entry  dbname  key) takes the current buffer and stores it into
 the named database under the given key.


 query-replace-string                                                      ESC-Q
   Replace all occurrences of one string  with  another,  starting  at  dot  and
 ending  at the end of the buffer.  Emacs prompts for an old and a new string in
 the minibuffer (the line at the bottom of the screen).    See  the  section  on
 searching,  section 14 page 25 for more information on search strings. For each
 occurrence of the old string, Emacs requests that the user type in a  character
 to  tell  it  what  to do (dot will be positioned just after the found string).
 The possible replies are:

 <space>         Change this occurrence and continue to the next.
 n               Don't change this occurrence, but continue to the next
 r               Enter a recursive-edit.  This  allows  you  to  make  some
                 local  changes,  then continue the query-replace-string by
                 typing ^C.
 !               Change this occurrence and all the rest of the occurrences
80


              without bothering to ask.
.             Change this one and stop: don't do any more replaces.
^G            Don't  change  this occurrence and stop: don't do any more
              replaces.
?             (or anything else) Print a short list of the query/replace
              options.


quietly-read-abbrev-file                                            [unbound]
Read in and define abbrevs appearing in a named file.  This file should  have
been  written  using  write-abbrev-file.    Unlike  read-abbrev-file,  an error
message is not printed if the file cannot be found.


quit-process                                                        [unbound]
(quit-process "process-name") -- Send a quit signal to the process.


quote                                                               [unbound]
Takes a string and inserts quote characters  so  that  any  characters  which
would have been treated specially by the reqular expression search command will
be treated as plain characters.  For example, (quote "a.b") returns "a\.b".


quote-character                                                            ^Q
Insert  into the buffer the next character typed without interpreting it as a
command.  This is how you insert funny characters.  For example, to insert a ^L
(form feed or page break character) type ^Q^L.   This  is  the  only  situation
where ^G isn't interpreted as an abort character.


re-query-replace-string                                             [unbound]
re-query-replace-string  is identical to query-replace-string except that the
search string is a regular expression rather than an uninterpreted sequence  of
characters.    See  the  section  on  searching,  section  14  page 25 for more
information.


re-replace-string                                                   [unbound]
re-replace-string is identical  to  replace-string  except  that  the  search
string  is  a  regular  expression  rather  than  an  uninterpreted sequence of
characters.  See the  section  on  searching,  section  14  page  25  for  more
information.
                                                                              81


 re-search-forward                                                     [unbound]
   re-search-forward  is  identical  to  search-forward  except  that the search
 string is a  regular  expression  rather  than  an  uninterpreted  sequence  of
 characters.    See  the  section  on  searching,  section  14  page 25 for more
 information.


 re-search-reverse                                                     [unbound]
   re-search-reverse is identical  to  search-reverse  except  that  the  search
 string  is  a  regular  expression  rather  than  an  uninterpreted sequence of
 characters.  See the  section  on  searching,  section  14  page  25  for  more
 information.


 read-abbrev-file                                                      [unbound]
   Read  in and define abbrevs appearing in a named file.  This file should have
 been written using write-abbrev-file.  An error message is printed if the  file
 cannot be found.


 read-file                                                                  ^X^R
   Prompt for the name of a file; erase the contents of the current buffer; read
 the file into the buffer and associate the name with the buffer.  Dot is set to
 the beginning of the buffer.


 recursion-depth                                                       [unbound]
   Returns  the  depth  of nesting within recursive-edit's.  It returns 0 at the
 outermost level.


 recursive-edit                                                        [unbound]
   The recursive-edit function is a call on the keyboard  read/interpret/execute
 routine.    After recursive-edit is called the user can enter commands from the
 keyboard as usual, except that  when  he  exits  Emacs  by  calling  exit-emacs
 (typing ^C) it actually returns from the call to recursive-edit.  This function
 is  handy  for  packages that want to pop into some state, let the user do some
 editing, then when they're done perform some cleanup and let the  user  resume.
 For example, a mail system could use this for message composition.


 redraw-display                                                               ^L
   Clear the screen and rewrite it.  This is useful if some transmission glitch,
 or a message from a friend, has messed up the screen.
82


region-around-match                                                 [unbound]
Region-around-match  sets  dot and mark around the region matched by the last
search.  An argument of n puts dot and mark around the n'th subpattern  matched
by `\(' and `\)'.  This can then be used in conjuction with region-to-string to
extract  fields  matched  by  a  patter.    For example, consider the following
fragment that extracts user names and host names from mail addresses:

  (re-search-forward "\\([a-z][a-z]*\\) *@ *\\([a-z][a-z]*\\)")
  (region-around-match 1)
  (setq username (region-to-string))
  (region-around-match 2)
  (setq host (region-to-string))

Applying this MLisp code to the text  "send  it  to  jag@vlsi"  would  set  the
variable `username' to "jag" and `host' to "vlsi".


region-to-process                                                   [unbound]
(region-to-process  "process-name")  --  The region is wrapped up and sent to
the process.


region-to-string                                                    [unbound]
Returns the region between dot and mark as a string.  Please be kind  to  the
storage allocator, don't use huge strings.


remove-all-local-bindings                                           [unbound]
Perform  a remove-local-binding for all possible keys; effectively undoes all
local bindings.  Mode packages should execute  this  to  initialize  the  local
binding table to a clean state.


remove-binding                                                      [unbound]
Removes  the  global binding of the given key.  Actually, it just rebinds the
key to illegal-operation.


remove-local-binding                                                [unbound]
Removes the local binding  of  the  given  key.    The  global  binding  will
subsequently  be  used  when interpreting the key.  Bug: there really should be
some way of saving the current binding of a key, then restoring it later.
                                                                              83


 replace-string                                                            ESC-R
   Replace all occurrences of one string for another, starting at dot and ending
 and  the  end  of the buffer.  Emacs prompts for an old and a new string in the
 minibuffer (the line at the bottom of the screen).  Unlike query-replace-string
 Emacs doesn't ask any questions about particular occurrences, it  just  changes
 them.    Dot  will  be  left after the last changed string.  See the section on
 searching, section 14 page 25 for more information on search strings.


 reset-filter                                                          [unbound]
   Removes the filter that had been bound to some process in a buffer.


 return-prefix-argument                                                [unbound]
   (return-prefix-argument n) sets the numeric prefix argument to be used by the
 next function invocation to n.  The  next  function  may  be  either  the  next
 function  in  the  normal  flow of MLisp execution or the next function invoked
 from a keystroke.  Return-prefix-argument is to be used by functions  that  are
 to  be  bound  to  keys and which are to provide a prefix argument for the next
 keyboard command.


 return-to-monitor                                                            ^
   Recursivly invokes a new shell, allowing  the  user  to  enter  normal  shell
 commands  and run other programs.  Return to Emacs by exiting the shell; ie. by
 typing ^D.


 save-excursion                                                        [unbound]
   (save-excursion expressions...) is an MLisp function that evaluates the given
 expressions and returns the value of the last expression evaluated.  It is much
 like progn except that before any expressions are executed dot and the  current
 buffer  are  "marked" (via the marker mechanism) then after the last expression
 is executed dot and the current buffer are reset to the marked  values.    This
 properly  takes  into account all movements of dot and insertions and deletions
 that occur.  Save-excursion is useful in MLisp functions where you want  to  go
 do  something somewhere else in this or some other buffer but want to return to
 the same place when you're done; for example, inserting a tab at the  beginning
 of the current line.


 save-restriction                                                      [unbound]
   Save-restriction is only useful to people writing MLisp programs.  It is used
 to  save  the  region  restriction  for the current buffer (and only the region
 restriction) during the execution of some subexpression  that  presumably  uses
 region restrictions.  The value of (save-excursion expressions...) is the value
 of the last expression evaluated.
84


save-window-excursion                                               [unbound]
save-window-excursion  is  identical  to  save-excursion  except that it also
saves (in  a  rough  sort  of  way)  the  state  of  the  windows.    That  is,
(save-window-excursion  expressions...) saves the current dot, mark, buffer and
window state, executes the expressions,  restores  the  saved  information  and
returns the value of the last expression evaluated.

When  the  window  state is saved Emacs remembers which buffers were visible.
When it is restored, Emacs makes sure that exactly those buffers  are  visible.
Emacs  does  not  save  and  restore the exact layout of the windows: this is a
feature, not a bug.  


scroll-one-line-down                                                    ESC-Z
Repositions the current window on the current buffer so that the  line  which
is  currently  the  second  to  the  last  line  in the window becomes the last
-- effectivly it moves the buffer down one line in  the  window.    ^Z  is  its
inverse.


scroll-one-line-up                                                         ^Z
Repositions  the  current window on the current buffer so that the line which
is currently the second line in the window becomes the first --  effectivly  it
moves the buffer up one line in the window.  ESC-Z is its inverse.


search-forward                                                             ^S
Prompt  for  a  string  and  search for a match in the current buffer, moving
forwards from dot, stopping at the end of the buffer.  Dot is left at  the  end
of  the  matched  string  if  a  match is found, or is unmoved if not.  See the
section on searching, section 14 page 25 for more information.


search-reverse                                                             ^R
Prompt for a string and search for a match  in  the  current  buffer,  moving
backwards  from  dot,  stopping at the beginning of the buffer.  Dot is left at
the beginning of the matched string if a match is found, or is unmoved if  not.
See the section on searching, section 14 page 25 for more information.


self-insert                                                         [unbound]
This  is tied to those keys which are supposed to self-insert.  It is roughly
the same as (insert-character (last-key-struck)) with  the  exception  that  it
doesn't work unless it is bound to a key.
                                                                              85


 send-string-to-terminal                                               [unbound]
   (send-string-to-terminal  "string")  sends  the  string  argumetn  out to the
 terminal with no conversion or interpretation.  This should only  be  used  for
 such  applications as loading function keys when Emacs starts up.  If you screw
 up the screen, Emacs won't know about it and won't fix it up automatically  for
 you -- you'll have to type ^L.


 set                                                                   [unbound]
   Set  the  value  of  some variable internal to Emacs.  Emacs will ask for the
 name of a variable and a value to set it to.  The variables control such things
 as margins, display layout options, the behavior of search commands,  and  much
 more.  The available variables and switches are described elsewhere.  Note that
 if  set  is  used  from  MLisp  the  variable  name  must  be  a  string:  (set
 "left-margin" 77).


 set-auto-fill-hook                                                    [unbound]
   set-auto-fill-hook associates a command with the current buffer.    When  the
 right  margin  is  passed  by  the  attempt  to  insert some character the hook
 procedure for that buffer is invoked.  The character that  triggered  the  hook
 will  not  have  been  inserted, but will be inserted immediatly after the hook
 procedure returns [unless the procedure returns 0].    The  hook  procedure  is
 responsible for maintaining the position of dot. last-key-struck may be usually
 used  to determine which character triggered the hook.  If no hook procedure is
 associated with a buffer then the old action (break the line and  indent)  will
 be  taken.  This procedure may be used for such things as automatically putting
 boxes around paragraph comments as they are typed.


 set-default                                                           [unbound]
   This commands bears the same relationship to setq-default that  set  does  to
 setq.    It  is  the  command that you use from the keyboard to set the default
 value of some variable.  See the description of setq-default for more  detailed
 information.


 set-mark                                                                     ^@
   Puts  the marker for this buffer at the place where dot is now, and leaves it
 there.  As text is inserted or deleted around the mark, the mark will remain in
 place.  Use ^X^X to move to the currently marked position.


 setq                                                                  [unbound]
   Assigns a new value to a variable.   Variables  may  have  either  string  or
 integer  values.    (setq i 5) sets i to 5; (setq s (concat "a" "b")) sets s to
 "ab".
86


setq-default                                                        [unbound]
Setq-default  is used to set the default value of some variable.  It can be a
global parameter, a buffer-specific variable or a system variable.  It makes no
matter, setq-default will set the default.  Setq-default is the command to  use
from within some MLisp program, like your start up profile (".Emacs pro").  For
example,  (setq-default  right-margin 60) will set the default right margin for
newly created buffers to 60.  In previous  versions  of  Emacs  certain  system
variables had default versions from which default values were taken. So, to set
the   default   value   of   right-margin   one   would   assign   a  value  to
default-right-margin -- but no more.  Use setq-default (or set-default instead.

The precise semantics of setq-default are:

 - If the variable being assigned to has not  yet  been  declared,  then
   declare it as a global variable.

 - If  it  is  a  global  variable  (whether  or not the declaration was
   implicit) then assign the value to it just as the setq command  would
   have done.

 - Otherwise,  if  the  variable is buffer specific then set the default
   value for the variable.  This will be used in all buffers  where  the
   variable  hasn't  been explicitly assigned a value.  Note that if you
   have a global variable which is eventually  declared  buffer-specific
   then  the  global  value  becomes the default.  The intent of this is
   that users should be able to put setq-default's in their .emacs_pro's
   without  concerning  themselves  over  whether  the   variable   will
   eventually be a simple global or buffer-specific.


shell                                                               [unbound]
The  shell  command is used to either start or reenter a shell process.  When
the shell command is executed, if a shell process doesn't  exist  then  one  is
created  (running the standard ``sh'') tied to a buffer named ``shell'.  In any
case, the shell buffer becomes the current one and dot is positioned at the end
of it.  In that buffer output from the shell and  programs  run  with  it  will
appear.  Anything typed into it will get sent to the subprocess when the return
key  is  struck.    This lets you interact with a shell using Emacs, and all of
it's editing capability, as an intermediary.  You can scroll backwards  over  a
session,  pick  up pieces of text from other places and use them as input, edit
while watching the execution of some program, and much more...


shrink-window                                                            ^X^Z
Makes the current window one line shorter, and the window below (or  the  one
above  if there is no window below) one line taller.  Can't be used if there is
only one window on the screen.
                                                                              87


 sit-for                                                               [unbound]
   Updates  the display and pauses for n/10 seconds.  (sit-for 10) waits for one
 second.  This is useful in such things as a Lisp auto-paren balencer.


 split-current-window                                                        ^X2
   Enter two-window mode.  Actually, it takes the current window and  splits  it
 into  two  windows,  dividing  the  space on the screen equally between the two
 windows.  An arbitrary number of windows can be created -- the only limit is on
 the amount of space available on the screen, which, sigh, is only 24  lines  on
 most  terminals  available  these  days  (with the notable exception of the Ann
 Arbor Ambassador which has 60).


 start-filtered-process                                                [unbound]
   (start-filtered-process   "command"   "buffer-name"    "on-output-procedure")
 --  Does  the same thing as start-process except that things are set up so that
 "on-output-procedure" is automatically called whenever output has been received
 from this process.  This procedure can access the name of the process producing
 the output by refering to the variable MPX-process, and can retrieve the output
 itself by calling the procedure process-output.

        The  filter  procedure  must  be  careful   to   avoid   generating
      side-effects (eg. search-forward).  Moreover, if it attempts to go to
      the  terminal  for  information,  output  from other processes may be
      lost.


 start-process                                                         [unbound]
   (start-process "command" "buffer-name") -- The home shell is used to start  a
 process   executing   the  command.    This  process  is  tied  to  the  buffer
 "buffer-name" unless it is null in which case the "Command execution" buffer is
 used.  Output from the process is automatically attached  to  the  end  of  the
 buffer.    Each  time  this  is done, the mark is left at the end of the output
 (which is the end of the buffer).


 start-remembering                                                           ^X(
   All following keystrokes will be remembered by Emacs.


 stop-process                                                          [unbound]
   (stop-process "process-name") -- Tell the process to stop  by  sending  it  a
 stop signal.  Use continue-process to carry on.
88


stop-remembering                                                          ^X)
Stops remembering keystrokes, as initiated by ^X(.  The remembered keystrokes
are not forgotten and may be re-executed with ^XE.


string-to-char                                                      [unbound]
Returns  the  integer  value  of  the first character of its string argument.
(string-to-char "0") = '0'.


string-to-process                                                   [unbound]
(string-to-process "process-name" "string") -- The  string  is  sent  to  the
process.


substr                                                              [unbound]
(substr  str  pos n) returns the substring of string str starting at position
pos (numbering from 1) and running for n characters.  If pos is  less  than  0,
then  length  of  the  string  is  added  to  it;  the  same  is  done  for  n.
(substr "kzin" 2 2) = "zi"; (substr "blotto.c" -2 2) = ".c".


switch-to-buffer                                                          ^XB
Prompt for the name of the buffer and associate it with the  current  window.
The old buffer associated with this window merely loses that association: it is
not erased or changed in any way.  If the new buffer does not exist, it will be
created, in contrast with ^X^O.


system-name                                                         [unbound]
Is  an  MLisp  function that returns the name of the system on which Emacs is
being run.  This should be the ArpaNet or EtherNet (or whatever) host  name  of
the machine.


temp-use-buffer                                                     [unbound]
Switch  to a named buffer without changing window associations.  The commands
pop-to-buffer and switch-to-buffer both cause  a  window  to  be  tied  to  the
selected buffer, temp-use-buffer does not.  There are a couple of problems that
you  must  beware when using this command:  The keyboard command driver insists
that the buffer tied to the current window be the current buffer, if it sees  a
difference then it changes the current buffer to be the one tied to the current
window.  This means that temp-use-buffer will be ineffective from the keyboard,
switch-to-buffer  should  be  used instead.  The other problem is that "dot" is
really a rather funny concept.  There is a value of "dot" associated with  each
window,  not  with  each  buffer.    This  is  done  so  that  there is a valid
interpretation to having the same buffer visible in several windows.  There  is
also a value of "dot" associated with the current buffer.  When you switch to a
buffer  with  temp-use-buffer,  this "transient dot" is what gets used.  So, if
you switch to another buffer, then use temp-use-buffer to get back, "dot"  will
have been set to 1.  You can use save-excursion to remember your position.
                                                                              89


 to-col                                                                [unbound]
   (to-col  n)  is  an  MLisp  function  that insert tabs and spaces to move the
 following character to printing column n.


 transpose-characters                                                         ^T
   Take the two characters preceding dot and exchange them.   One  of  the  most
 common errors for typists to make is transposing two letters, typing "hte" when
 "the"  is  meant.  ^T makes correcting these errors easy, especially if you can
 develop a "^T reflex".


 undo                                                                  [unbound]
   Undoes the effects of  the  last  command  typed.    Arbitrarily  complicated
 commands  may  be  undone successfully.  Only the buffer modifying effects of a
 command may be  undone  --  variable  assignments,  key  bindings  and  similar
 operations  will  not  be undone.  Even `undo' may be undone, so executing undo
 twice in a row effectivly does nothing.  See the section on undoing, page 50.


 undo-boundary                                                         [unbound]
   undo-boundary lays down the boundary between two  undoable  commands.    When
 commands  are  undone, a `command' is considered to be the series of operations
 between undo boundaries.  Normally, they are laid down between  keystrokes  but
 MLisp  functions may choose to lay down more.  See the section on undoing, page
 50.  


 undo-more                                                             [unbound]
   Undoes one more command from  what  was  last  undone.    undo-more  must  be
 preceeded  by  either  an  undo or an undo-more.  This is usually used by first
 invoking undo to undo a command, then invoking  undo-more  repeatedly  to  undo
 more and more commands, until you've retreated to the state you want to be back
 to.  See the section on undoing, page 50.


 unlink-file                                                           [unbound]
   (unlink-file  fn)  attempts to unlink (remove) the file named fn.  It returns
 true if the unlink failed.


 use-abbrev-table                                                      [unbound]
   Sets the current local abbrev table to the one with the given  name.    Local
 abbrev  tables  are  buffer specific and are usually set depending on the major
 mode.  Several buffers may have the same local abbrev table.    If  either  the
 selected  abbrev table or the global abbrev table have had some abbrevs defined
 in them, abbrev-mode is turned on for the current buffer.  
90


use-global-map                                                      [unbound]
(use-global-map  "mapname")  uses  the  named  map  to be used for the global
interpretation of all key strokes.  use-local-map is used to change  the  local
interpretation of key strokes. See the section on keymaps, 15 page 28, for more
information.


use-local-map                                                       [unbound]
(use-local-map  "mapname")  uses  the  named  map  to  be  used for the local
interpretation of all key strokes.  use-global-map is used to change the global
interpretation of key strokes.  See the section on keymaps,  15  page  28,  for
more information.


use-old-buffer                                                           ^X^O
Prompt  for  the name of the buffer and associate it with the current window.
The old buffer associated with this window merely loses that association: it is
not erased or changed in any way.  The buffer must already exist,  in  contrast
with ^XB.


use-syntax-table                                                    [unbound]
Associates  the  named  syntax  table  with  the  current  buffer.    See the
description of the modify-syntax-entry command for more information on  syntax
tables.


users-full-name                                                     [unbound]
MLisp  function  that  returns  the  users full name as a string. [Really, it
returns the contents of the gecos field of the passwd  entry  for  the  current
user, which is used on many systems for the users full name.]


users-login-name                                                    [unbound]
MLisp function that returns the users login name as a string.


visit-file                                                               ^X^V
Visit-file asks for the name of a file and switches to a buffer that contains
it.    The  file  name is expanded to it's full absolute form (that is, it will
start with a '/').  If no buffer contains the  file  already  then  Emacs  will
switch  to a new buffer and read the file into it.  The name of this new buffer
will be just the last component of the file name (everything after the last '/'
in the name).  If there is already a buffer by that name, and it contains  some
other  file,  then Emacs will ask "Enter a new buffer name or <CR> to overwrite
the old buffer".  For example, if my current directory is "/usr/jag/emacs"  and
I  do  a  ^X^V and give Emacs the file name "../.emacs pro"then the name of the
new   buffer   will   be   ".emacs pro"   and   the   file   name    will    be
"/usr/jag/.emacs pro".  ^X^V  is the approved way of switching from one file to
another within an invocation of Emacs.
                                                                              91


 while                                                                 [unbound]
   (while  test  expressions...)  is  an  MLisp function that executes the given
 expressions while the test is true.


 widen-region                                                          [unbound]
   The widen-region command sets the restriction to encompass the entire buffer.
 It is usualy used after a narrow-region to restore  Emacs's  attention  to  the
 whole buffer.


 window-height                                                         [unbound]
   Returns  the number of text lines of a window that are visible on the screen.
 


 working-directory                                                     [unbound]
   Returns the pathname of the current working directory.


 write-abbrev-file                                                     [unbound]
   Write all defined abbrevs to a named file.  This file is suitable for reading
 back with read-abbrev-file.


 write-current-file                                                         ^X^S
   Write the contents of the current buffer to the file whose name is associated
 with the buffer.


 write-file-exit                                                            ^X^F
   Write all modified buffers to their associated files and if  all  goes  well,
 Emacs will exit.


 write-modified-files                                                       ^X^M
   Write each modified buffer (as indicated by ^X^B) onto the file whose name is
 associated  with the buffer.  Emacs will complain if a modified buffer does not
 have an associated file.


 write-named-file                                                           ^X^W
   Prompt for a name; write the contents of the  current  buffer  to  the  named
 file.
92


yank-buffer                                                            ESC-^Y
Take  the  contents of the buffer whose name is prompted for and insert it at
dot in the current buffer.  Dot is left after the inserted text.


yank-from-killbuffer                                                       ^Y
Take the contents of the kill buffer and inserts it at  dot  in  the  current
buffer.  Dot is left after the inserted text.


|                                                                   [unbound]
(| e  e ) MLisp function that returns e  | e .
    1  2                               1    2
                                                                              93


 22. Options
   This chapter describes (in alpahbetical order) all of the variables which the
 user may set to configure Emacs to taste.


 ask-about-buffer-names
   The ask-about-buffer-names variable controls what the visit-file command does
 if   it   detects   a   collision   when   constructing  a  buffer  name.    If
 ask-about-buffer-names is true (the default) then Emacs  will  ask  for  a  new
 buffer  name  to be given, or for <CR> to be typed which will overwrite the old
 buffer.  If it is false then a buffer name will  be  synthesized  by  appending
 "<n>"  to  the  buffer  name,  for  a  unique  value  of  n.  For example, if I
 visit-file "makefile" then the buffer  name  will  be  "makefile";  then  if  I
 visit-file "man/makefile" the buffer name will be "makefile<2>".


 backup-by-copying
   If  true,  then  when  a  backup  of  a  file is made (see the section on the
  backup-before-writing variable) then rather than doing the  fancy  link/unlink
 footwork,  Emacs  copies the original file onto the backup.  This preserves all
 link and owner information & ensures that the  files  I-number  doesn't  change
 (you're  crazy if you worry about a files I-number). Backup-by-copying incurs a
 fairly heafty performance penalty.  See the section on  the  backup-by-copying-
 when-linked variable for a description of a compromise.  (default OFF)


 backup-by-copying-when-linked
   If  true,  then  when  a  backup  of  a  file is made (see the section on the
  backup-before-writing variable) then if the link count of the file is  greater
 than  1,  rather  than  doing  the fancy link/unlink footwork, Emacs copies the
 original file onto the backup.  If the link count is 1,  then  the  link/unlink
 trick  is  pulled.  This  preserves  link information when it is important, but
 still manages reasonable performance the rest of the time. See the  section  on
 the  backup-by-copying  variable  for  a  description  of a how to have owner &
 I-number information preserved.  (default OFF)


 backup-when-writing
   If ON Emacs will make a backup of a file just before the first time  that  it
 is  overwritten.    The  backup will have the same name as the original, except
 that the string ".BAK" will be appended; unless the last name in the  path  has
 more  than  10 characters, in which case it will be truncated to 10 characters.
 "foo.c"    gets    backed    up    on    "foo.c.BAK";    "/usr/jag/foo.c"    on
 "/usr/jag/foo.c.BAK";  and  "EtherService.c"  on  "EtherServi.BAK".  The backup
 will only be made the first time that the file is  rewritten  from  within  the
 same  invocation  of Emacs, so if you write out the file several times the .BAK
 file will contain the file as it was before Emacs was invoked.  The  backup  is
 normally  made  by fancy footwork with links and unlinks, to achieve acceptable
 performance:  when "foo.c" is to be rewritten, Emacs effectivly executes a  "mv
 foo.c  foo.c.BAK"  and  then  creates  foo.c  a  write  the new copy.  The file
 protection of foo.c is copied from the old foo.c, but old links to the file now
 point to the .BAK file, and the owner of the new file  is  the  person  running
94


Emacs.    If  you don't like this behaviour, see the switches backup-by-copying
and backup-by-copying-when-linked.  (default OFF)


buffer-is-modified
Buffer-is-modified is true iff the current buffer has been modified since  it
was  last  written  out.    You  may set if OFF (ie. to 0) if you want Emacs to
ignore the mods that have been made to this buffer -- it doesn't get  you  back
to  the  unmodified  version,  it just tells Emacs not to write it out with the
other modified files.  Emacs sets buffer-is-modified true any time  the  buffer
is modified.


case-fold-search
If  set  ON  all  searches  will  ignore  the  case of alphabetics when doing
comparisons.  (default OFF)


checkpoint-frequency
The number of keystrokes between  checkpoints.  Every  "checkpoint-frequency"
keystrokes   all  buffers  which  have  been  modified  since  they  were  last
checkpointed are written to a file named "file.CKP".  File  is  the  file  name
associated with the buffer, or if that is null, the name of the buffer.  Proper
account  is  taken of the restriction on file names to 14 characters.  (default
300)


comment-column
The column at which comments are to start.  Used  by  the  language-dependent
commenting features through the move-to-comment-column command.  (default 33)


ctlchar-with-^
If  set ON control characters are printed as ^C (an '^' character followed by
the upper case alphabetic that corresponds to the control character), otherwise
they are printed according to the usual Unix  convention  ('\'  followed  by  a
three digit octal number).  (default OFF)


files-should-end-with-newline
Indicates that when a buffer is written to a file, and the buffer doesn't end
in  a  newline,  then  the  user should be asked if they want to have a newline
appended.  It used to be that this was the  default  action,  but  some  people
objected to the question being asked. (default ON)
                                                                              95


 global-mode-string
   Global-mode-string  is  a  global  variable  used in the construction of mode
 lines see section 17, page 32 for more information.


 help-on-command-completion-error
   If ON Emacs will print a list of possibilities when an ambiguous  command  is
 given,  otherwise  it  just  rings  the  bell  and  waits for you to type more.
 (default ON)


 left-margin
   The left margin for automatic text justification.    After  an  automatically
 generated newline the new line will be indented to the left margin.


 mode-line-format
   mode-line-format  is a buffer specific variable used to specify the format of
 a mode line.  See section 17, page 32 for more information.


 mode-string
   Mode-string is a buffer specific variable used in the  construction  of  mode
 lines see section 17, page 32 for more information.


 needs-checkpointing
   A  buffer-specific  variable  which if ON indicates that the buffer should be
 checkpointed periodically.  If it is OFF, then no  checkpoints  will  be  done.
 (default ON)


 pop-up-windows
   If  ON  Emacs  will try to use some window other than the current one when it
 spontaneously generates a buffer that it wants you to see or when you  visit  a
 file  (it  may  split the current window).  If OFF the current window is always
 used.  (default ON)


 prefix-argument
   Every function invocation is always prefixed by a  numeric  argument,  either
   explicitly  with  ^Un  or provide-prefix-argument.  The value of the variable
 prefix-argument is the argument prefixed to the invocation of the current MLisp
 function.  For example, if the following function:

     (defun
         (show-it
             (message (concat "The prefix argument is " prefix-argument))
         )
     )

 were bound to the key ^A then typing ^U^A would cause the message ``The  prefix
96


argument  is 4'' to be printed, and ^U13^A would print ``The prefix argument is
13''.  See also the commands prefix-argument-loop and provide-prefix-argument.


prefix-argument-provided
True iff the execution of the current function  was  prefixed  by  a  numeric
argument.  Use prefix-argument to get it's value.


prefix-string
The  string that is inserted after an automatic newline has been generated in
response to going past the right  margin.    This  is  generally  used  by  the
language-dependent commenting features.  (default "")


quick-redisplay
If ON Emacs won't worry so much about the case where you have the same buffer
on  view in several windows -- it may let the other windows be inaccurate for a
short while (but they will eventually be fixed up).  Turning this ON speeds  up
Emacs  substantially  when the same buffer is on view in several windows.  When
it is OFF, all windows are always accurate.  (default OFF)


replace-case
If ON Emacs will alter the case of strings substituted with replace-string or
query-replace-string to match the case of the original string.    For  example,
replacing  "which" by "that" in the string "Which is silly" results in "That is
silly"; in the string "the car which is red" results in "the car that is  red";
and in the string "WHICH THING?"  results in "THAT THING?".


right-margin
The  right  margin  for  automatic  text  justification.    If a character is
inserted at the end of a line and to the right of the right margin  Emacs  will
automatically insert at the beginning of the preceding word a newline, tabs and
spaces  to  indent  to  the left margin, and the prefix string.  With the right
margin set to something like (for eg.) 72 you can type in  a  document  without
worrying  about  when to hit the return key, Emacs will automatically do it for
you at exactly the right place.


scroll-step
The number of lines by which windows are scrolled if dot  moves  outside  the
window.  If  dot has moved more than scroll-step lines outside of the window or
scroll-step is zero then dot is centered in the window.  Otherwise  the  window
is moved up or down scroll-step lines.  Setting scroll-step to 1 will cause the
window  to  scroll  by 1 line if you're typing at the end of the window and hit
RETURN.
                                                                              97


 silently-kill-processes
   If  ON  Emacs will kill processes when it exits without asking any questions.
 Normally, if you have processes running when Emacs  exits,  the  question  "You
 have  processes  on  the  prowl,  should  I  hunt  them down for you" is asked.
 (default OFF)


 stack-trace-on-error
   If ON Emacs will write a MLisp  stack  trace  to  the  "Stack  trace"  buffer
 whenever  an error is encountered from within an MLisp function (even inside an
 error-occured).  This is all there is in  the  way  of  a  debugging  facility.
 (default OFF)


 tab-size
   A  buffer-specific  variable which specifies the number of characters between
 tab stops.  It's not clear that user specifiable tabs are a  good  idea,  since
 the  rest  of  Unix  and most other DEC styled operating systems have the magic
 number 8 so deeply wired into them. (default 8)


 this-command
   The meaning of the variable this-command  is  tightly  intertwined  with  the
 meaning  of  the  function  previous-command.   Look at its documentation for a
 description of this-command.


 track-eol-on-^N-^P
   If ON then ^N and ^P will "stick" to the end of a line if  they  are  started
 there.  If OFF ^N and ^P will try to stay in the same column as you move up and
 down even if you started at the end of a line.  (default ON)


 unlink-checkpoint-files
   If  ON  Emacs  will unlink the corresponding checkpoint file after the master
 copy is written -- this avoids having a lot of .CKP files lying around  but  it
 does  compromise safety a little.  For example, as you're editing a file called
 "foo.c" Emacs  will  be  periodically  be  writing  a  checkpoint  file  called
 "foo.c.CKP"  that  contains  all  of your recent changes.  When you rewrite the
 file (with ^X^F or ^X^S for example) if unlink-checkpoint-files is ON then  the
 .CKP file will be unlinked, otherwise it will be left.  (default OFF)


 visible-bell
   If ON Emacs will attempt to use a visible bell, usually a horrendous flashing
 of  the  screen,  instead of the audible bell, when it is notifying you of some
 error.  This is a more "socially acceptable" technique when people are  working
 in a crowded terminal room.  (default OFF)
98


wrap-long-lines
If ON Emacs will display long lines by "wrapping" their continuation onto the
next  line  (the  first line will be terminated with a '\').  If OFF long lines
get truncated at the right edge of the screen and a '$' is display to  indicate
that this has happened.  (default OFF)
                                                                              99


          Unix Emacs Reference Card    ESC-d   Delete word right
 SOME NECESSARY NOTATION               ESC-h   Delete word left
         Any ordinary character goes   ESC-c   Capitalize word
         into  the buffer (no insert   ESC-l   Lowercase word
         command needed).   Commands   ESC-u   Uppercase word
         are  all control characters   ESC-^   Invert case of word
         or     other     characters   LINE OPERATIONS
         prefixed  by  Escape  or  a   ^A      Move to  the  beginning  of
         control-X.  Escape is some-           the line
         times   called   Meta    or   ^E      Move to the end of the line
         Altmode in EMACS.             ^O      Open up a line for typing
 ^       A  control  character.   ^F   ^K      Kill from  dot  to  end  of
         means "control F".                    line  (^Y  yanks it back at
 ESC-    A   two-character   command           dot)
         sequence  where  the  first   PARAGRAPH OPERATIONS
         character is Escape.  ESC-F   ESC-[   Move to  beginning  of  the
         means "ESCAPE then F".                paragraph
 ESC-X string    A   command  desig-   ESC-]   Move   to   end   of    the
         nated  "by  hand".   "ESC-x           paragraph
         read-file"  means:     type   ESC-j   Justify     the     current
         "Escape",  then  "x",  then           paragraph
         "read-file", then <cr>.       GETTING OUT
 dot     EMACS   term   for   cursor   ^X-^S   Save the file being  worked
         position in current buffer.           on
 mark    An  invisible  set position   ^X-^W   Write  the  current  buffer
         in   the   buffer  used  by           into a  file  with  a  dif-
         region commands.                      ferent name
 region  The   area  of  the  buffer   ^X-^M   Write  out   all   modified
         between the dot and mark.             files
 CHARACTER OPERATIONS                  ^X-^F   Write   out   all  modified
 ^B      Move left (Back)                      files and exit
 ^F      Move right (Forward)          ^C or ESC-^C or ^X-^C   Finish   by
 ^P      Move up (Previous)                    exiting to the shell
 ^N      Move down (Next)              ^_      Recursively  push  (escape)
 ^D      Delete right                          to a new shell
 ^H or BS or DEL or RUBOUT             SCREEN AND SCREEN OPERATIONS
         Delete left                   ^V      Show next screen page
 ^T      Transpose    previous     2   ESC-V   Show previous screen page
         characters (ht_ -> th_)       ^L      Redisplay screen
 ^Q      Literally  inserts (quotes)   ^Z      Scroll screen up
         the  next  character  typed   ESC-Z   Scroll screen down
         (e.g. ^Q-^L)                  ESC-!   Move  the line dot is on to
 ^U-n    Provide a numeric  argument           top of the screen
         of  n  to  the command that   ESC-,   Move cursor to beginning of
         follows (n defaults  to  4,           window
         eg. try ^U-^N and ^U-^U-^F)   ESC-.   Move   cursor   to  end  of
 ^M or CR    newline                           window
 ^J or NL    newline followed by  an   ^X-2    Split the current window in
         indent                                two  windows  (same  buffer
 WORD OPERATIONS                               shown in each)
 ESC-b   Move left (Back)              ^X-1    Resume single window (using
 ESC-f   Move right (Forward)                  current buffer)
100


^X-d  Delete  the current window,           of the region)
      giving  space   to   window   ^W      Kill  region  (^Y  yanks it
      below                                 back at dot)
^X-n  Move cursor to next window    MACRO OPERATIONS
^X-p  Move  cursor  to   previous   ^X-(    Start           remembering
      window                                keystrokes,    ie.    start
ESC-^VDisplay   the  next  screen           defining a keyboard macro
      page in the other window      ^X-)    Stop            remembering
^X-^Z Shrink window                         keystrokes,   ie.  end  the
^X-z  Enlarge window                        definition
BUFFER AND FILE OPERATIONS          ^X-e    Execute          remembered
^Y    Yank  back  the  last thing           keystrokes, ie. execute the
      killed (kill and delete are           keyboard macro
      different)                    COMPILING (MAKE) OPERATIONS.
^X-^V Get a file  into  a  buffer   ^X-^E   Execute   the   "make"  (or
      for editing                           other) command, saving out-
^X-^R Read a  file  into  current           put in a buffer
      buffer,  erasing  old  con-   ^X-^N   Go to the next error in the
      tents                                 file
^X-^I Insert file at dot            ^X-!    Execute the given  command,
^X-^O Select  a  different buffer           saving output in a buffer
      (it must already exist)       MAIL
^X-B  Select a  different  buffer   ^X-r    Read mail.
      (it need not pre-exist)       ^X-m    Send mail
^X-^B Display a list of available
      buffers
ESC-^YInsert  selected  buffer at
      dot
ESC-< Move  to  the  top  of  the
      current buffer
ESC-> Move  to  the  end  of  the
      current buffer
HELP AND HELPER FUNCTIONS
^G    Abort anything at any time.
ESC-? Show every command contain-
      ing string (try ESC-? para)
ESC-X infoBrowse   through    the
      Emacs manual.
^X^U  Undo  the  effects  of pre-
      vious commands.
SEARCH
^S    Search forward
^R    Search backward
REPLACE
ESC-r Replace  one  string   with
      another
ESC-q Query  Replace,  one string
      with another
REGION OPERATIONS
^@    Set the mark
^X-^X Interchange  dot  and  mark
      (i.e.  go  to the other end
                                                                             101


 Index

           !   51
           !=   51

           %   51

           &   51
           &Occurances-Extra-Lines   43

           *   51

           +   51

           -   51

           .emacs_pro   23, 71, 86

           /   51

           <   51
           <<   51
           <=   52

           =   52

           >   52
           >=   52
           >>   52

           ^   52

           Abbrev-expansion   16, 60
           Abbrev-mode   16, 89
           Active-process   34, 52
           Append-region-to-buffer   52
           Append-to-file   52
           Apropos   10, 52
           Arg   53
           Argc   53
           Argument-prefix   53
           Argv   53
           Ask-about-buffer-names   93
           Auto-execute   53
           Autoload   54

           Backup-before-writing   93
           Backup-by-copying   93, 94
           Backup-by-copying-when-linked   93, 94
           Backup-when-writing   93
           Backward-balanced-paren-line   54
           Backward-character   54
102


        Backward-paragraph   54
        Backward-paren   54
        Backward-sentence   55
        Backward-word   55
        Baud-rate   55
        Begin-C-comment   40
        Beginning-of-file   55
        Beginning-of-line   55
        Beginning-of-window   55
        Bibliography support for Scribe   48
        Bind-to-key   17, 28, 55, 65, 72
        Bobp   55
        Bolp   56
        Buff   40
        Buffer list   40
        Buffer-is-modified   94
        Buffer-size   56
        Buffer-specific   20, 59, 85, 86

        C-mode   56
        C=   56
        Case-fold-search   56, 94
        Case-region-capitalize   56
        Case-region-invert   56
        Case-region-lower   56
        Case-region-upper   56
        Case-word-capitalize   56, 73
        Case-word-invert   57
        Case-word-lower   57
        Case-word-upper   57
        Cd   44
        Change-current-process   34, 57
        Change-directory   57
        Char-to-string   57
        Checkpoint   57
        Checkpoint-frequency   57, 94
        Clock   50
        Command prefix, also known as META   57
        Command-prefix   58
        Comment-column   40, 75, 94
        Compile-it   58
        Concat   58
        Continue-process   35, 36, 58, 87
        Copy-region-to-buffer   58
        Ctlchar-with-^   94
        Current-buffer-name   58
        Current-column   59
        Current-file-name   59
        Current-indent   59
        Current-process   35, 59
        Current-time   59
                                                                             103


           Declare-buffer-specific   20, 59, 85, 86
           Declare-global   18, 19, 59
           Default-mode-line-format   32
           Define-buffer-macro   59, 63
           Define-global-abbrev   16, 60
           Define-hooked-global-abbrev   60
           Define-hooked-local-abbrev   60
           Define-keyboard-macro   17, 60, 65
           Define-keymap   28, 60
           Define-local-abbrev   16, 60
           Define-string-macro   17, 60, 65
           Defun   20, 61
           Delete-buffer   61
           Delete-macro   61
           Delete-next-character   61
           Delete-next-word   61
           Delete-other-windows   61
           Delete-previous-character   61, 62
           Delete-previous-word   62
           Delete-region-to-buffer   62
           Delete-to-killbuffer   62, 64
           Delete-white-space   62
           Delete-window   62
           Deleting files   40
           Describe-bindings   10, 62
           Describe-command   10, 62, 63
           Describe-key   10, 63
           Describe-variable   63
           Describe-word-in-buffer   63
           Digit   63
           Directory   44
           Dired   40
           Display-file-percentage   55
           Dot   63
           Dump-syntax-table   63, 73

           Edit-macro   59, 63
           Electric-c   16
           Emacs-version   64
           End-C-comment   40
           End-of-file   64
           End-of-line   64
           End-of-window   64
           Enlarge-window   64
           Eobp   64
           Eolp   64
           Eot-process   35, 64
           Erase-buffer   64
           Erase-region   64
           Error-message   65
           Error-occured   65, 97
           Exchange-dot-and-mark   65
104


        Execute-extended-command   65
        Execute-keyboard-macro   17, 65
        Execute-mlisp-buffer   65
        Execute-mlisp-line   65
        Execute-monitor-command   66
        Exit-emacs   66
        Expand-file-name   66
        Expand-mlisp-variable   66, 69
        Expand-mlisp-word   66, 68
        Extend-database-search-list   38, 66

        Fetch-database-entry   38, 67
        File-exists   67
        Files-should-end-with-newline   94
        Filter-region   67
        Following-char   67
        Forward-balanced-paren-line   67
        Forward-character   9, 67
        Forward-paragraph   68
        Forward-paren   68, 73
        Forward-sentence   68
        Forward-word   68, 73

        Get-tty-buffer   68
        Get-tty-character   68
        Get-tty-command   68
        Get-tty-string   68
        Get-tty-variable   69
        Getenv   69
        Global-binding-of   69
        Global-mode-string   32, 33, 95
        Goto-character   69
        Goto-line   41
        Goto-percent   41
        Grab-last-line   44

        Help facilities   10, 38, 46, 50, 65, 95
        Help-on-command-completion-error   95

        If   69
        Illegal-operation   69, 82
        Indent-C-procedure   40, 69
        Info   43
        Insert-character   70
        Insert-file   70
        Insert-filter   70
        Insert-string   70
        Int-process   35, 70
        Interactive   70
        Is-bound   70

        Justify-paragraph   69, 70
                                                                             105



           Kill-process   35, 70
           Kill-to-end-of-line   71

           Last-key-struck   71
           Left-margin   95
           Length   71
           Line-to-top-of-window   71
           Lisp   43
           Lisp-kill-output   44
           List-buffers   71
           List-databases   38, 71
           List-processes   35, 71
           Load   71
           Local-bind-to-key   28, 72
           Local-binding-of   72
           Looking-at   25, 72

           Mail, sending and receiving   44
           Mark   73
           Message   73
           Mode lines   5, 32, 95
           Mode-line-format   32, 95
           Mode-string   32, 95
           Modify-syntax-entry   73, 90
           Move-dot-to-x-y   74
           Move-to-comment-column   75, 94

           Nargs   75
           Narrow-region   31, 75
           Needs-checkpointing   95
           Newline   75
           Newline-and-backup   75
           Newline-and-indent   75
           Next-error   75
           Next-line   76
           Next-page   76
           Next-window   76
           Nothing   69, 72, 76
           Novalue   76

           Occur   43
           Occurances   43
           Occurances of a string   43
           On-output-procedure   35, 36, 78, 87
           One-line-buffer-list   40

           Page-next-window   76
           Parse-error-messages-in-region   77
           Pause-emacs   77
           Pop-to-buffer   77, 88
           Pop-up-windows   95
106


        Pr-newline   44
        Preceding-char   77
        Prefix arguments   53, 77, 79, 83, 95, 96
        Prefix-argument   77, 79, 95
        Prefix-argument-loop   77, 79, 96
        Prefix-argument-provided   96
        Prefix-string   96
        Prepend-region-to-buffer   77
        Previous-command   77
        Previous-line   78
        Previous-page   78
        Previous-window   78
        Print   78
        Process-filter-name   35, 78
        Process-id   35, 78
        Process-output   35, 78
        Process-status   35, 79
        Processes, high level access   43
        Profile   23, 71, 86
        Progn   18, 79
        Provide-prefix-argument   77, 79, 95
        Push-back-character   79
        Put-database-entry   38, 79
        Pwd   44

        Query-replace-string   25, 79, 96
        Quick-redisplay   96
        Quietly-read-abbrev-file   16, 80
        Quit-process   36, 80
        Quote   80
        Quote-character   80

        Re-query-replace-string   25, 80
        Re-replace-string   25, 80
        Re-search-forward   25, 81
        Re-search-reverse   25, 81
        Read-abbrev-file   16, 80, 81, 91
        Read-file   31, 53, 81
        Reading mail   46
        Receiving mail   46
        Recursion-depth   81
        Recursive-edit   32, 81
        Redraw-display   81
        Reference Card   99
        Region restrictions   31, 75, 83, 91
        Region-around-match   82
        Region-to-process   36, 82
        Region-to-string   82
        Remove-all-local-bindings   82
        Remove-binding   82
        Remove-local-binding   82
        Replace-case   96
                                                                             107


           Replace-string   25, 31, 83, 96
           Reset-filter   83
           Return-prefix-argument   83
           Return-to-monitor   77, 83
           Right-margin   96

           Save-excursion   83, 88
           Save-restriction   31, 83
           Save-window-excursion   84
           Scribe bibliography support   48
           Scribe-bib   48
           Scroll-one-line-down   84
           Scroll-one-line-up   84
           Scroll-step   96
           Search-forward   25, 84
           Search-reverse   25, 84
           Self-insert   84
           Send-eot   44
           Send-int-signal   44
           Send-quit-signal   44
           Send-string-to-terminal   85
           Sending mail   45
           Set   85
           Set-auto-fill-hook   85
           Set-default   19, 59, 85, 86
           Set-mark   85
           Setq   85, 86
           Setq-default   19, 59, 85, 86
           Shell   43, 86
           Shrink-window   10, 86
           Silently-kill-processes   36, 97
           Sit-for   87
           Spell   49
           Split-current-window   87
           Stack-trace-on-error   97
           Start-filtered-process   36, 87
           Start-process   36, 87
           Start-remembering   17, 87
           Stop-process   35, 36, 58, 87
           Stop-remembering   17, 88
           String-to-char   88
           String-to-process   36, 88
           Substr   88
           Summary   99
           Switch-to-buffer   19, 77, 88
           System-name   88

           Tab-size   97
           Temp-use-buffer   88
           Text-mode   50
           This-command   97
           Time   50
108


        To-col   89
        Track-eol-on-^N-^P   97
        Transpose-characters   89

        Undo   50, 89
        Undo-boundary   50, 89
        Undo-more   50, 89
        Unlink-checkpoint-files   97
        Unlink-file   89
        Use-abbrev-table   16, 60, 89
        Use-global-map   28, 90
        Use-local-map   28, 90
        Use-old-buffer   90
        Use-syntax-table   73, 90
        Users-full-name   90
        Users-login-name   90

        Visible-bell   97
        Visit-file   18, 53, 90

        While   91
        Widen-region   31, 91
        Window-height   91
        Working-directory   91
        Wrap-long-lines   98
        Write-abbrev-file   16, 80, 81, 91
        Write-current-file   31, 91
        Write-file-exit   91
        Write-modified-files   91
        Write-named-file   91
        Write-region-to-file   50

        Yank-buffer   92
        Yank-from-killbuffer   92

        |   92

